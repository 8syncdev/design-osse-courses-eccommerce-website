[
    {
        "model": "web_app.detaillesson",
        "pk": 1,
        "fields": {
            "name": "Bài 00. Hướng dẫn Python",
            "content": "# Bài 00. Hướng dẫn Python\n\nHiện nay, Python là một trong những ngôn ngữ lập trình phổ biến nhất. Mặc dù nó là một ngôn ngữ đa mục đích, nhưng được sử dụng trong các lĩnh vực ứng dụng khác nhau như Machine Learning, Artificial Intelligence, phát triển web, IoT và nhiều hơn nữa.\n\nHướng dẫn Python này đã được viết dành cho người mới bắt đầu để giúp họ hiểu các khái niệm cơ bản đến nâng cao của Ngôn ngữ lập trình Python. Sau khi hoàn thành hướng dẫn này, bạn sẽ thấy mình ở mức độ thành thạo tốt về Python, từ đó bạn có thể tiến thêm vào các cấp độ cao hơn để trở thành một Kỹ sư Phần mềm hàng đầu thế giới.\n\nHướng dẫn Python này dựa trên phiên bản Python 3.11.2 mới nhất.\n\n## Python là gì?\n\nPython là một ngôn ngữ lập trình phổ biến rất được ưa chuộng, được dịch, tương tác, hướng đối tượng và mức độ cao. Python là một ngôn ngữ lập trình được thu gom và kiểu động. Nó được tạo ra bởi Guido van Rossum trong khoảng thời gian từ 1985 đến 1990. Giống như Perl, mã nguồn Python cũng có sẵn dưới Giấy phép Công cộng GNU (GPL).\n\nPython hỗ trợ nhiều mô hình lập trình, bao gồm lập trình Thủ\n\n## Công việc với Python\n\nNếu bạn biết Python một cách thành thạo, bạn sẽ có một sự nghiệp tốt. Dưới đây là một số lựa chọn sự nghiệp nơi Python là một kỹ năng chính:\n\n- Nhà phát triển game\n- Thiết kế web\n- Nhà phát triển Python\n- Nhà phát triển Full-stack\n- Kỹ sư Machine Learning\n- Nhà khoa học dữ liệu\n- Nhà phân tích dữ liệu\n- Kỹ sư dữ liệu\n- Kỹ sư DevOps\n- Kỹ sư phần mềm\n- Và nhiều vai trò khác\n\n## Đặc điểm của Python\n\nDưới đây là các đặc điểm quan trọng của Ngôn ngữ lập trình Python:\n\n- Hỗ trợ phương pháp lập trình hàm và cấu trúc cũng như OOP.\n- Có thể sử dụng như một ngôn ngữ kịch bản hoặc có thể biên dịch thành mã byte để xây dựng các ứng dụng lớn.\n- Cung cấp các loại dữ liệu động cấp cao và hỗ trợ kiểm tra loại động.\n- Hỗ trợ thu gom rác tự động.\n- Có thể dễ dàng tích hợp với C, C++, COM, ActiveX, CORBA và Java.\n\n## Ứng dụng của Python\n\nPhiên bản Python mới nhất là 3.x. Như đã đề cập trước đó, Python là một trong những ngôn ngữ được sử dụng rộng rãi nhất trên web. Dưới đây là một số ví dụ:\n\n- Dễ học: Python có ít từ khóa, cấu trúc đơn giản và cú pháp rõ ràng. Điều này cho phép sinh viên nắm bắt ngôn ngữ nhanh chóng.\n- Dễ đọc: Mã Python được định nghĩa và hiển thị rõ ràng hơn.\n- Dễ bảo trì: Mã nguồn Python khá dễ bảo trì.\n- Thư viện tiêu chuẩn rộng lớn: Hầu hết thư viện Python rất di động và tương thích trên nhiều nền tảng như UNIX, Windows và Macintosh.\n- Chế độ tương tác: Python hỗ trợ chế độ tương tác cho phép kiểm tra và gỡ lỗi mã mẫu một cách tương tác.\n- Di động: Python có thể chạy trên nhiều nền tảng phần cứng khác nhau và có cùng giao diện trên tất cả các nền tảng.\n- Mở rộng: Bạn có thể thêm các mô-đun cấp thấp vào trình thông dịch Python. Các mô-đun này cho phép các nhà lập trình thêm hoặc tùy chỉnh công cụ của họ để trở nên hiệu quả hơn.\n- Cơ sở dữ liệu: Python cung cấp giao diện cho tất cả các cơ sở dữ liệu thương mại lớn.\n- Lập trình GUI: Python hỗ trợ các ứng dụng GUI có thể được tạo ra và chuyển sang nhiều hệ thống gọi, thư viện và hệ thống cửa sổ, như Windows MFC, Macintosh và hệ thống cửa sổ X của Unix.\n- Có thể mở rộng: Python cung cấp một cấu trúc tốt hơn và hỗ trợ cho các chương trình lớn hơn so với lập trình script shell.\n\n## Đối tượng mục tiêu\n\nHướng dẫn này đã được chuẩn bị cho người mới bắt đầu để giúp họ hiểu các khái niệm một cách toàn diện.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 2,
        "fields": {
            "name": "Bài 01. Python - Tổng quan",
            "content": "# Bài 01. Python - Tổng quan\n\nPython là một ngôn ngữ lập trình kịch bản cao cấp, được phiên dịch, tương tác và hướng đối tượng. Python được thiết kế để có tính đọc hiểu cao. Nó thường sử dụng các từ khóa tiếng Anh thay vì dấu câu, và có ít cấu trúc cú pháp hơn so với các ngôn ngữ khác.\n\n## Đặc điểm của Python\n\n- **Phiên dịch**: Python được xử lý vào thời gian chạy bởi trình phiên dịch. Bạn không cần phải biên dịch chương trình trước khi thực thi nó.\n- **Tương tác**: Bạn có thể ngồi tại dấu nhắc Python và tương tác trực tiếp với trình phiên dịch để viết chương trình của bạn.\n- **Hướng đối tượng**: Python hỗ trợ phong cách lập trình hướng đối tượng, trong đó mã được đóng gói trong các đối tượng.\n- **Dành cho người mới bắt đầu**: Python là một ngôn ngữ tuyệt vời cho các lập trình viên mới bắt đầu và hỗ trợ phát triển một loạt các ứng dụng từ xử lý văn bản đơn giản đến trình duyệt WWW và trò chơi.\n\n## Triết lý thiết kế của Python\n\nTriết lý thiết kế của Python tập trung vào đơn giản, đọc hiểu và không mơ hồ. Python nổi tiếng với cách tiếp cận \"batteries included\", với một thư viện chuẩn toàn diện của các hàm và module.\n\n## Kiểu mã Pythonic\n\nPython để bạn tự do lựa chọn lập trình theo cách hướng đối tượng, thủ tục, chức năng, hướng khía cạnh, hoặc thậm chí là hướng logic. Những tự do này khiến Python trở thành một ngôn ngữ tuyệt vời để viết mã sạch và đẹp.\n\nMã Pythonic là mã có tính đọc hiểu cao, ngắn gọn và dễ bảo trì.\n\n## Triết lý Pythonic\n\nTriết lý Pythonic liên quan đến mã không chỉ hoạt động, mà còn là Pythonic. Mã Pythonic là mã có thể đọc được, ngắn gọn và dễ bảo trì.\n\n**Lưu ý**: Bạn có thể xem triết lý Python bằng cách nhập `import this` trong Python Shell.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 3,
        "fields": {
            "name": "Bài 02. Python - Lịch sử",
            "content": "# Bài 02. Python - Lịch sử\n\nPython được phát triển bởi Guido van Rossum vào cuối thập kỷ 1980 và đầu thập kỷ 1990 tại Viện Nghiên cứu Toán học và Khoa học Máy tính Quốc gia Hà Lan.\n\nPython được phát triển dựa trên nhiều ngôn ngữ khác nhau, bao gồm ABC, Modula-3, C, C++, Algol-68, SmallTalk, và Unix shell cùng với các ngôn ngữ lập trình kịch bản khác.\n\nPython được bản quyền. Giống như Perl, mã nguồn Python hiện đã có sẵn dưới Giấy phép Công cộng GNU (GPL).\n\nĐối với nhiều người không am hiểu, từ \"Python\" liên quan đến một loài rắn. Tuy nhiên, Rossum cho biết việc chọn tên Python liên quan đến một series hài hước phổ biến trên BBC có tên Monty Python's Flying Circus.\n\nLà kiến trúc sư chính của Python, cộng đồng phát triển đã trao cho ông danh hiệu \"Benevolent Dictator for Life\" (BDFL - Đại diện Từ thiện Vĩnh viễn). Tuy nhiên, vào năm 2018, Rossum từ bỏ danh hiệu đó. Sau đó, việc phát triển và phân phối phiên bản tham chiếu của Python được thực hiện bởi một tổ chức phi lợi nhuận có tên là Python Software Foundation.\n\n## Ai đã phát minh ra Python?\n\nPython được phát minh bởi một lập trình viên Hà Lan là Guido Van Rossum vào cuối thập kỷ 1980. Và, phiên bản đầu tiên của Python (0.9.0) đã được phát hành vào năm 1991.\n\n## Sự phát triển của Python - Các phiên bản quan trọng\n\nDưới đây là các giai đoạn quan trọng trong lịch sử của Python −\n\n- **Python 0.9.0**: Phiên bản đầu tiên của Python là 0.9.0. Nó được phát hành vào tháng 2 năm 1991. Nó bao gồm hỗ trợ cho các nguyên tắc lập trình hướng đối tượng cốt lõi.\n  \n- **Python 1.0**: Vào tháng 1 năm 1994, phiên bản 1.0 đã được phát hành, được trang bị các công cụ lập trình chức năng, các tính năng như hỗ trợ cho số phức, v.v.\n  \n- **Python 2.0**: Phiên bản chính tiếp theo - Python 2.0 được ra mắt vào tháng 10 năm 2000. Nhiều tính năng mới như comprehension của danh sách, thu gom rác và hỗ trợ Unicode được bao gồm với nó.\n  \n- **Python 3.0**: Python 3.0, một phiên bản hoàn toàn được tái cấu trúc của Python được phát hành vào tháng 12 năm 2008. Mục tiêu chính của việc tái cấu trúc này là loại bỏ nhiều không đồng nhất đã xuất hiện trong các phiên bản Python 2.x. Python 3 được trở lại thành Python 2.6. Nó cũng bao gồm một tiện ích có tên là python2to3 để hỗ trợ dịch tự động mã Python 2 sang Python 3.\n\n- **Kết thúc vòng đời (EOL) cho Python 2.x**: Ngay cả sau khi Python 3 được phát hành, Python Software Foundation vẫn tiếp tục hỗ trợ nhánh Python 2 với các phiên bản nhỏ về mặt kỹ thuật cho đến năm 2019. Tuy nhiên, họ quyết định ngừng hỗ trợ vào cuối năm 2020, lúc đó Python 2.7.17 là phiên bản cuối cùng trong nhánh này.\n\n## Phiên bản hiện tại của Python\n\nTrong khi đó, ngày càng nhiều tính năng đã được tích hợp vào nhánh 3.x của Python. Hiện nay, Python 3.11.2 là phiên bản ổn định hiện tại, được phát hành vào tháng 2 năm 2023.\n\n## Các tính năng mới trong Python 3.11\n\nMột trong những tính năng quan trọng nhất của Python phiên bản 3.11 là cải tiến đáng kể về tốc độ. Theo tài liệu chính thức của Python, phiên bản này nhanh hơn phiên bản trước (3.10) lên đến 60%. Nó cũng nói rằng bộ kiểm tra tiêu chuẩn cho thấy tỷ lệ thực thi nhanh hơn 25%.\n\nPython 3.11 cũng có thông báo ngoại lệ tốt hơn. Thay vì tạo ra một traceback dài khi xảy ra một ngoại lệ, chúng ta bây giờ nhận được biểu thức chính xác gây ra lỗi.\n\nTheo đề xuất của PEP 678, phương thức add_note() được thêm vào lớp BaseException. Bạn có thể gọi phương thức này bên trong mệnh đề except và truyền một thông báo lỗi tùy chỉnh.\n\nNó cũng thêm hàm cbroot() vào module maths. Nó trả về căn bậc ba của một số cho trước.\n\nMột module mới là tomlib",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 4,
        "fields": {
            "name": "Bài 03. Python - Các Đặc Điểm và Ưu Điểm",
            "content": "# Bài 03. Python - Các Đặc Điểm và Ưu Điểm\n\nPython là một ngôn ngữ lập trình mạnh mẽ với nhiều đặc điểm và ưu điểm hấp dẫn, làm cho nó trở thành lựa chọn phổ biến của các nhà phát triển. Dưới đây là một bản tóm tắt chi tiết về các đặc điểm và ưu điểm của Python:\n\n## Các Đặc Điểm Quan Trọng của Python\n\n### 1. Dễ Học\n   - Python được biết đến với việc dễ học nhất đối với các lập trình viên mới. Với cú pháp đơn giản, Python giúp người học dễ dàng tiếp cận và hiểu được cách làm việc của nó một cách nhanh chóng.\n   - Sử dụng thụt lề thay vì dấu ngoặc nhọn giúp giảm bớt sự phức tạp cú pháp và làm cho mã nguồn trở nên dễ đọc hơn.\n\n### 2. Dựa trên Trình Biên Dịch\n   - Python là một ngôn ngữ dựa trên trình biên dịch, cho phép người lập trình thực thi và gỡ lỗi mã nguồn một cách dễ dàng và linh hoạt hơn.\n   - Với tính năng này, người lập trình có thể thực hiện và thử nghiệm mã nguồn từng phần một, giúp tăng tốc quá trình phát triển.\n\n### 3. Tương Tác\n   - Python cung cấp một shell tương tác, cho phép người dùng nhập các lệnh và biểu thức Python trực tiếp và nhận kết quả ngay lập tức.\n   - Chế độ tương tác giúp người lập trình thử nghiệm và hiểu rõ hơn về các tính năng và thư viện của Python mà không cần viết mã hoàn chỉnh.\n\n### 4. Đa Mô Hình\n   - Python hỗ trợ nhiều mô hình lập trình, bao gồm lập trình hướng đối tượng, lập trình cấu trúc, và thậm chí là lập trình hàm.\n   - Điều này cho phép các nhà phát triển chọn lựa phong cách lập trình phù hợp với nhu cầu và yêu cầu cụ thể của dự án.\n\n### 5. Thư Viện Tiêu Chuẩn\n   - Python đi kèm với một thư viện tiêu chuẩn phong phú, bao gồm nhiều mô-đun và gói cho các nhu cầu lập trình khác nhau.\n   - Sự phong phú của thư viện tiêu chuẩn giúp giảm bớt thời gian phát triển và tăng hiệu suất của các dự án.\n\n### 6. Mã nguồn mở và Đa Nền Tảng\n   - Python là một ngôn ngữ mã nguồn mở, cho phép các nhà phát triển tùy chỉnh và mở rộng mã nguồn theo nhu cầu của họ.\n   - Python có sẵn trên nhiều nền tảng, bao gồm Windows, Linux, và macOS, giúp dễ dàng triển khai ứng dụng trên nhiều môi trường khác nhau.\n\n### 7. Ứng Dụng Giao Diện Đồ Họa (GUI)\n   - Python hỗ trợ xây dựng các ứng dụng giao diện người dùng đồ họa thông qua các thư viện như TKinter, PyQt, và WxPython.\n   - Việc hỗ trợ GUI cho phép người lập trình tạo ra các ứng dụng người dùng cuối thân thiện và hấp dẫn một cách dễ dàng.\n\n### 8. Kết Nối Cơ Sở Dữ Liệu\n   - Python hỗ trợ kết nối với nhiều loại cơ sở dữ liệu khác nhau thông qua giao diện DB-API.\n   - Người lập trình có thể kết nối với các hệ quản trị cơ sở dữ liệu quan hệ (SQL) cũng như các hệ quản trị cơ sở dữ liệu NoSQL.\n\n### 9. Mở Rộng\n   - Python có khả năng mở rộng, cho phép người lập trình thêm các tính năng mới hoặc sửa đổi các tính năng hiện có một cách dễ dàng.\n   - Việc viết và tích hợp các mô-đun bổ sung cho Python giúp tăng khả năng mở rộng của ứng dụng và dễ dàng mở rộng chức năng.\n\n### 10. Cộng Đồng Phát Triển Chủ Động\n   - Python có một cộng đồng lớn và tích cực của các nhà phát triển trên toàn thế giới.\n   - Sự phổ biến và tính đa dạng của Python đã tạo ra một môi trường phát triển sôi động với nhiều tài nguyên, hỗ trợ, và thông tin hữu ích.\n\n## Kết Luận\n\nPython không chỉ là một ngôn ngữ lập trình, mà còn là một hệ sinh thái đa dạng và mạnh mẽ.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 5,
        "fields": {
            "name": "Bài 04. Python - Chương Trình Hello World",
            "content": "# Bài 04. Python - Chương Trình Hello World\n\nTrong hướng dẫn này, chúng ta sẽ học cách viết một chương trình Hello World đơn giản bằng ngôn ngữ lập trình Python. Chương trình này sẽ sử dụng hàm print() tích hợp sẵn trong Python để in ra chuỗi.\n\n## Chương Trình Hello World trong Python\n\nIn ra chuỗi \"Hello World\" là chương trình đầu tiên trong Python. Chương trình này không yêu cầu bất kỳ đầu vào nào từ người dùng, nó chỉ in ra văn bản trên màn hình đầu ra. Nó được sử dụng để kiểm tra xem phần mềm cần thiết để biên dịch và chạy chương trình đã được cài đặt đúng cách hay chưa.\n\n## Các Bước\n\nDưới đây là các bước để viết một chương trình Python để in ra Hello World:\n\n1. **Cài đặt Python:** Đảm bảo rằng Python đã được cài đặt trên hệ thống của bạn hoặc không. Nếu Python chưa được cài đặt, hãy cài đặt từ đây: [https://www.python.org/downloads/](https://www.python.org/downloads/)\n2. **Chọn Trình Soạn Thảo Văn Bản hoặc Môi Trường Phát Triển (IDE) để viết mã.**\n3. **Mở Trình Soạn Thảo Văn Bản hoặc IDE, tạo một tệp mới, và viết mã để in ra Hello World.**\n4. **Lưu tệp với tên và phần mở rộng \".py\".**\n5. **Biên dịch/Chạy chương trình.**\n\n## Chương Trình Python để In Ra Hello World\n\n```python\n# Mã Python để in ra \"Hello World\"\nprint(\"Hello World\")\n```\n\nTrong mã trên, chúng ta viết hai dòng. Dòng đầu tiên là bình luận Python sẽ được bỏ qua bởi trình biên dịch Python, và dòng thứ hai là câu lệnh print() sẽ in ra thông điệp được chỉ định (\"Hello World\") trên màn hình đầu ra.\n\n## Đầu Ra\n\n```\nHello World\n```\n\n## Cách Viết và Thực Thi Chương Trình Hello World\n\n### Sử dụng Chế Độ Lệnh Dịch Thông Thường của Python\n\nRất dễ dàng để hiển thị thông điệp Hello World bằng cách sử dụng trình dịch Python. Khởi chạy trình dịch Python từ một cửa sổ dòng lệnh của Hệ điều hành Windows và gõ lệnh print từ dấu nhắc Python như sau -\n\n**Ví dụ:**\n\n```\nPS C:\\> python\nPython 3.11.2 (tags/v3.11.2:878ead1, Feb 7 2023, 16:38:35) [MSC v.1934 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>> print(\"Hello World\")\nHello World\n```\n\nTương tự, thông điệp Hello World cũng được in ra trên Hệ điều hành Linux.\n\n**Ví dụ:**\n\n```\n$ python3\nPython 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>> print(\"Hello World\")\nHello World\n```\n\n### Sử dụng Chế Độ Kịch Bản Dịch của Python\n\nTrình dịch Python cũng hoạt động trong chế độ kịch bản. Mở bất kỳ trình soạn thảo văn bản nào, nhập văn bản sau đây và lưu với tên Hello.py\n\n```python\nprint(\"Hello World\")\n```\n\nĐối với Hệ điều hành Windows, mở cửa sổ dòng lệnh (CMD) và chạy chương trình như sau -\n\n```\nC:\\>python hello.py\n```\n\nĐiều này sẽ hiển thị đầu ra sau:\n\n```\nHello World\n```\n\nĐể chạy chương trình từ terminal Linux\n\n```\n$ python3 hello.py\n```\n\nĐiều này sẽ hiển thị đầu ra sau:\n\n```\nHello World\n```\n\n### Sử dụng Shebang #! trong Tập Lệnh Linux\n\nTrong Linux, bạn có thể chuyển đổi một chương trình Python thành một tập lệnh tự chạy. Câu lệnh đầu tiên trong mã nên là một dòng Shebang #!. Nó phải chứa đường dẫn đến chương trình Python. Trong Linux, Python được cài đặt trong thư mục /usr/bin, và tên của chương trình thực thi là python3. Do đó, chúng ta thêm câu lệnh này vào tệp hello.py\n\n```python\n#!/usr/bin/python3\n\nprint(\"Hello World\")\n```\n\nBạn cũng cần cấp quyền thực thi cho tệp bằng cách sử dụng lệnh chmod +x\n\n```\n$ chmod +x hello.py\n```\n\nSau đó, bạn có thể chạy chương trình với dòng lệnh sau -\n\n```\n$ ./hello.py\n```\n\nĐiều này sẽ hiển thị đầu ra sau:\n\n```\nHello World\n```\n\n## Câu Hỏi Thường Gặp (FAQs)\n\n1. Tại sao chương trình đầu tiên được gọi là Hello World?\n   - Đó chỉ là một chương trình đơn giản để kiểm tra cú pháp cơ bản và cấu hình trình biên dịch/phiên dịch của ngôn ngữ lập trình Python.\n\n2. Có cần cài đặt Python để chạy chương trình Hello World không?\n   - Có, việc cài đặt Python là cần thiết để chạy chương trình Hello World.\n\n3. Làm thế nào để chạy một chương trình Python mà không cần cài đặt nó?\n   - Python đã phát triển một môi trường trực tuyến nơi bạn có thể chạy mã của mình. Bạn có thể sử dụng trình biên dịch trực tuyến của Python để chạy chương trình Python của mình.\n\n4. Sự khác biệt giữa Chương trình Đầu tiên và Chương trình Hello World trong Python là gì?\n   - Không có sự khác biệt. Chương trình đầu tiên của Python thường được biết đến là chương trình Hello World.\n\n5. Phương pháp/những phương pháp nào để in ra Hello World hoặc bất kỳ thông điệp nào khác?\n   - Bạn có thể sử dụng các phương pháp sau:\n     + Phương thức print()\n     + Phương thức sys.stdout.write() bằng cách nhập mô-đun sys\n     + Sử dụng f-string của Python\n\nĐó là một bản tóm tắt về cách viết và thực thi chương trình Hello World trong Python cùng với một số câu hỏi thường gặp liên quan. Chúc bạn may mắn trong việc học lập trình với Python!",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 6,
        "fields": {
            "name": "Bài 05.Python - Các Lĩnh Vực Ứng Dụng",
            "content": "# Bài 05.Python - Các Lĩnh Vực Ứng Dụng\n\nPython là một ngôn ngữ lập trình đa năng phổ biến, được sử dụng trong nhiều lĩnh vực ứng dụng khác nhau. Dưới đây là một cái nhìn tổng quan về các lĩnh vực ứng dụng chính của Python:\n\n## 1. Khoa Học Dữ Liệu\n\nPython đã trở thành công cụ quan trọng đối với các nhà khoa học dữ liệu. Các thư viện như NumPy, Pandas, và Matplotlib được sử dụng rộng rãi để phân tích và biểu đồ hóa dữ liệu. Điều này giúp các doanh nghiệp phát hiện thông tin quan trọng từ dữ liệu và đưa ra các quyết định chiến lược.\n\n## 2. Học Máy\n\nPython cung cấp các thư viện như Scikit-learn và TensorFlow để xây dựng các mô hình máy học. Các ứng dụng của học máy bao gồm dự đoán xu hướng, chẩn đoán y tế, phân tích giỏ hàng mua sắm và dự báo doanh số bán hàng.\n\n## 3. Phát Triển Web\n\nPython có các framework phát triển web như Django, Pyramid và Flask giúp tạo và triển khai ứng dụng web nhanh chóng. Các phiên bản mới của Python hỗ trợ lập trình bất đồng bộ, giúp phát triển ứng dụng web và API hiệu suất cao.\n\n## 4. Thị Giác Máy Tính và Xử Lý Hình Ảnh\n\nThư viện OpenCV là một công cụ phổ biến để xử lý hình ảnh và thị giác máy tính. OpenCV được sử dụng trong nhiều lĩnh vực như robot học, giám sát công nghiệp và nhận diện khuôn mặt.\n\n## 5. Hệ Thống Nhúng và IoT\n\nPython thích hợp cho việc phát triển ứng dụng nhúng và IoT. Micropython là một phiên bản nhẹ dành cho vi điều khiển nhúng như Arduino và Raspberry Pi.\n\n## 6. Lập Lịch Công Việc và Tự Động Hóa\n\nPython được sử dụng để tự động hóa các công việc như sao lưu dữ liệu định kỳ. Các sản phẩm như Maya sử dụng Python API để viết các script tự động hóa.\n\n## 7. Ứng Dụng Desktop GUI\n\nPython là một lựa chọn tuyệt vời cho việc xây dựng các ứng dụng desktop GUI thân thiện với người dùng. Các thư viện như Tkinter, PyQt và WxPython cho phép tạo giao diện người dùng đồ họa.\n\n## 8. Ứng Dụng Dòng Lệnh\n\nPython thường được sử dụng để xây dựng các ứng dụng dòng lệnh. Các thư viện như argparse giúp phân tích các đối số dòng lệnh.\n\n## 9. Ứng Dụng CAD\n\nCác kỹ sư CAD có thể sử dụng Python để tự động hóa các công việc lặp đi lặp lại trong thiết kế.\n\n## 10. Phát Triển Trò Chơi\n\nPython cũng được sử dụng để phát triển các trò chơi máy tính. Các thư viện như Pygame và Kivy cho phép xây dựng các ứng dụng trò chơi đa nền tảng.\n\nPython mang lại sự linh hoạt và hiệu suất cao cho nhiều loại ứng dụng khác nhau, làm cho nó trở thành một trong những ngôn ngữ lập trình phổ biến nhất hiện nay.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 7,
        "fields": {
            "name": "Bài 06. Python - Trình Diễn và Các Chế Độ Hoạt Động",
            "content": "# Bài 06. Python - Trình Diễn và Các Chế Độ Hoạt Động\n\nPython là một ngôn ngữ dựa trên trình diễn viên. Trong hệ thống Linux, chương trình thực thi Python được cài đặt trong thư mục /usr/bin/. Đối với Windows, chương trình thực thi (python.exe) được tìm thấy trong thư mục cài đặt (ví dụ: C:\\python311).\n\nHướng dẫn này sẽ giúp bạn hiểu cách Trình Diễn Python hoạt động ở chế độ tương tác và chế độ viết kịch bản. Mã Python được thực thi bằng cách từng câu lệnh một. Trình diễn viên Python có hai thành phần. Trình dịch kiểm tra câu lệnh để kiểm tra cú pháp. Nếu tìm thấy đúng, nó tạo ra một mã byte trung gian. Có một máy ảo Python sau đó chuyển đổi mã byte thành nhị phân cơ bản và thực thi nó. Sơ đồ dưới đây mô tả cơ chế:\n\n## Trình Diễn Python\n\nTrình diễn viên Python có hai chế độ: chế độ tương tác và chế độ viết kịch bản.\n\n### Trình Diễn Python - Chế Độ Tương Tác\n\nKhi được khởi chạy từ một dòng lệnh mà không có tùy chọn bổ sung, một lời nhắc Python >>> xuất hiện và trình diễn viên Python hoạt động dựa trên nguyên tắc REPL (Đọc, Đánh Giá, In, Lặp). Mỗi lệnh nhập vào trước dấu nhắc Python được đọc, dịch và thực thi. Một phiên tương tác điển hình như sau.\n\n```\n>>> price = 100\n>>> qty = 5\n>>> total = price * qty\n>>> total\n500\n>>> print(\"Tổng = \", total)\nTổng = 500\n```\n\nĐể đóng phiên tương tác, nhập ký tự cuối dòng (ctrl+D cho Linux và ctrl+Z cho Windows). Bạn cũng có thể gõ quit() trước dấu nhắc Python và nhấn Enter để trở về dấu nhắc hệ điều hành.\n\n```\n>>> quit()\n$\n```\n\nBộ môi trường tương tác có sẵn với bản phân phối Python chuẩn không được trang bị các tính năng như chỉnh sửa dòng, tìm kiếm lịch sử, tự động hoàn thành v.v. Bạn có thể sử dụng các phần mềm trình diễn tương tác nâng cao khác như IPython và bpython để có các chức năng bổ sung.\n\n### Trình Diễn Python - Chế Độ Viết Kịch Bản\n\nThay vì nhập và nhận kết quả của một hướng dẫn một lần như trong môi trường tương tác, bạn có thể lưu một tập hợp các hướng dẫn trong một tệp văn bản, đảm bảo rằng nó có phần mở rộng .py, và sử dụng tên đó làm tham số dòng lệnh cho lệnh Python.\n\nLưu các dòng sau đây vào prog.py, với sự sử dụng của bất kỳ trình soạn thảo văn bản nào như vim trên Linux hoặc Notepad trên Windows.\n\n```python\nprint(\"Chương trình đầu tiên của tôi\")\nprice = 100\nqty = 5\ntotal = price * qty\nprint(\"Tổng = \", total)\n```\n\nKhi chúng ta thực thi chương trình trên máy tính Windows, nó sẽ tạo ra kết quả sau:\n\n```\nC:\\Users\\Acer>python prog.py\nChương trình đầu tiên của tôi\nTổng = 500\n```\n\nLưu ý rằng mặc dù Python thực thi toàn bộ tập lệnh một cách liên tục, nhưng bên trong, nó vẫn được thực thi theo dòng.\n\nTrong trường hợp của bất kỳ ngôn ngữ dựa trên trình biên dịch nào như Java, mã nguồn không được chuyển đổi sang mã byte trừ khi toàn bộ mã nguồn không có lỗi. Trong Python, ngược lại, các câu lệnh được thực thi cho đến khi gặp lỗi đầu tiên.\n\nHãy giả định một lỗi một cách cố ý trong mã trên.\n\n```python\nprint(\"Chương trình đầu tiên của tôi\")\nprice = 100\nqty = 5\ntotal = prive * qty #Lỗi ở câu lệnh này\nprint(\"Tổng = \", total)\n```\n\nChú ý biến viết sai prive thay vì price. Hãy thử thực thi lại chương trình như trước -\n\n```\nC:\\Users\\Acer>python prog.py\nChương trình đầu tiên của tôi\nTraceback (most recent call last):\n  File \"C:\\Python311\\prog.py\", line 4, in <module>\n    total = prive * qty\nNameError: name 'prive' is not defined. Did you mean: 'price'?\n```\n\nLưu ý rằng các câu lệnh trước câu lệnh lỗi được thực thi trước và sau đó thông báo lỗi xuất hiện. Do đó, bây giờ đã rõ ràng rằng kịch bản Python được thực thi theo cách thông dịch.\n\n### Trình Diễn Python - Sử Dụng Shebang #!\n\nNgoài việc thực thi kịch bản Python như trên, chính kịch bản cũng có thể là một tệp tự thực thi trong Linux, giống như một tập lệnh shell. Bạn phải thêm một dòng shebang ở đầu kịch bản. Dòng shebang chỉ ra loại trình diễn Python nào được sử dụng để giải thích các câu lệnh Python trong kịch bản. Dòng đầu tiên của kịch bản bắt đầu bằng #! và tiếp theo là đường dẫn đến trình diễn Python.\n\nChỉnh sửa kịch bản prog.py như sau −\n\n```python\n#! /usr/bin/python3.11\n\nprint(\"Chương trình đầu tiên của tôi\")\nprice = 100\nqty = 5\ntotal = price * qty\nprint(\"Tổng = \", total)\n```\n\nĐể đánh dấu kịch bản là tự thực thi, sử dụng lệnh chmod\n\n```\n$ chmod +x prog.py\n```\n\nBạn có thể thực thi kịch bản trực tiếp, mà không cần sử dụng nó như một đối số dòng lệnh.\n\n```\n$ ./hello.py\n```\n\n### Python Tương Tác - IPython\n\nIPython (viết tắt của Interactive Python) là một môi trường tương tác nâng cao và mạnh mẽ cho Python với nhiều chức năng so với shell Python tiêu chuẩn. IPython được phát triển ban đầu bởi Fernando Perez vào năm 2001.\n\nIPython có các tính năng quan trọng sau đây −\n\n- Khả năng nội suy đối tượng của IPython để kiểm tra các thuộc tính của một đối tượng trong thời gian chạy.\n- Cú pháp sáng tạo của nó giúp xác định các phần tử ngôn ngữ như từ khóa, biến v.v.\n- Lịch sử các tương tác được lưu trữ bên trong và có thể được tạo lại.\n- Tự động hoàn thành của từ khóa, biến và tên hàm là một trong những tính năng quan trọng nhất.\n- Hệ thống lệnh phép của IPython hữu ích để kiểm soát môi trường Python và thực hiện các tác vụ hệ điều hành.\n\nNó là nhân chính chính cho notebook Jupyter và các công cụ phía trước khác của Dự án Jupyter.\n\nCài đặt IPython với công cụ cài đặt PIP.\n\n```\npip3 install ipython\n```\n\nKhởi chạy IPython từ dòng lệnh\n\n```\nC:\\Users\\Acer>ipython\nPython 3.11.2 (tags/v3.11.2:878ead1, Feb 7 2023, 16:38:35) [MSC v.1934\n64 bit (AMD64)] on win32\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.4.0 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]:\n```\n\nThay vì dấu nhắc >>> thông thường như trong trình diễn viên tiêu chuẩn, bạn sẽ thấy hai dấu nhắc quan trọng của IPython được giải thích dưới đây −\n\n- In[1] xuất hiện trước bất kỳ biểu thức nhập nào.\n- Out[1] xuất hiện trước Kết quả xuất hiện.\n\n```\nIn [1]: price = 100\nIn [2]: quantity = 5\nIn [3]: total = price * quantity\nIn [4]: total\nOut[4]: 500\nIn [5]:\n```\n\nHoàn thành tab là một trong những cải tiến hữu ích nhất do IPython cung cấp. IPython hiện ra danh sách phương thức phù hợp khi bạn nhấn phím tab sau dấu chấm trước đối tượng.\n\nIPython cung cấp thông tin (nội suy) của bất kỳ đối tượng nào bằng cách đặt ? trước nó. Điều này bao gồm chuỗi tài liệu, định nghĩa hàm và chi tiết constructor của lớp. Ví dụ, để khám phá đối tượng chuỗi var được xác định ở trên, nhập var? vào dấu nhắc nhập.\n\n```\nIn [5]: var = \"Hello World\"\nIn [6]: var?\nType: str\nString form: Hello World\nLength: 11\nDocstring",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 8,
        "fields": {
            "name": "Bài 07. Python - Thiết Lập Môi Trường",
            "content": "# Bài 07. Python - Thiết Lập Môi Trường\n\n## Cài Đặt Môi Trường Cục Bộ\n\nBước đầu tiên trong hành trình học Python là cài đặt nó trên máy tính của bạn. Hiện nay, hầu hết các máy tính, đặc biệt là có hệ điều hành Linux, đã có Python được cài đặt sẵn. Tuy nhiên, có thể nó không phải là phiên bản mới nhất.\n\nPython có sẵn trên nhiều nền tảng khác nhau bao gồm Linux và Mac OS X. Hãy hiểu cách thiết lập môi trường Python của chúng ta.\n\n### Thiết Lập Môi Trường Cục Bộ\n\nMở một cửa sổ terminal và gõ \"python\" để tìm hiểu xem nó đã được cài đặt chưa và phiên bản nào đã được cài đặt. Nếu Python đã được cài đặt sẵn thì bạn sẽ nhận được một thông báo giống như sau:\n\n```bash\n$ python\nPython 3.11.2 (main, Feb 8 2023, 14:49:24) [GCC 9.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>>\n```\n\n### Tải Về Python\n\nMã nguồn, nhị phân, tài liệu, tin tức, v.v., mới nhất và hiện tại, đều có sẵn trên trang web chính thức của Python [https://www.python.org/](https://www.python.org/).\n\nBạn có thể tải về tài liệu Python từ [https://www.python.org/doc/](https://www.python.org/doc/). Tài liệu có sẵn dưới dạng HTML, PDF và PostScript.\n\n### Cài Đặt Python\n\nPhân phối Python có sẵn cho nhiều nền tảng khác nhau. Bạn chỉ cần tải mã nhị phân phù hợp với nền tảng của mình và cài đặt Python.\n\nNếu mã nhị phân cho nền tảng của bạn không có sẵn, bạn cần một trình biên dịch C để biên dịch mã nguồn thủ công. Việc biên dịch mã nguồn cung cấp nhiều linh hoạt hơn trong việc lựa chọn các tính năng mà bạn cần trong cài đặt của mình.\n\nDưới đây là một cái nhìn nhanh chóng về cách cài đặt Python trên các nền tảng khác nhau −\n\n#### Cài Đặt Python trên Ubuntu Linux\n\nĐể kiểm tra xem Python đã được cài đặt sẵn chưa, mở terminal Linux và nhập lệnh sau −\n\n```bash\n$ python3.11 --version\n```\n\nTrong Ubuntu Linux, cách dễ nhất để cài đặt Python là sử dụng apt – Công cụ Đóng Gói Nâng Cao. Luôn luôn được khuyến khích cập nhật danh sách các gói trong tất cả các kho lưu trữ được cấu hình.\n\n```bash\n$ sudo apt update\n```\n\nNgay cả sau khi cập nhật, phiên bản Python mới nhất có thể không có sẵn để cài đặt, phụ thuộc vào phiên bản Ubuntu bạn đang sử dụng. Để khắc phục điều này, hãy thêm kho deadsnakes.\n\n```bash\n$ sudo apt-get install software-properties-common\n$ sudo add-apt-repository ppa:deadsnakes/ppa\n```\n\nCập nhật lại danh sách các gói.\n\n```bash\n$ sudo apt update\n```\n\nĐể cài đặt phiên bản Python 3.11 mới nhất, nhập lệnh sau vào terminal −\n\n```bash\n$ sudo apt-get install python3.11\n```\n\nKiểm tra xem nó đã được cài đặt đúng cách chưa.\n\n```bash\n$ python3\nPython 3.11.2 (main, Feb 8 2023, 14:49:24) [GCC 9.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>> print(\"Hello World\")\nHello World\n```\n\n### Cài Đặt Python trên các Hệ Điều Hành Khác\n\n#### Cài Đặt Python trên các Hệ Điều Hành Linux/Unix khác\n\nDưới đây là các bước đơn giản để cài đặt Python trên máy Unix/Linux:\n\n1. Mở trình duyệt Web và truy cập vào [https://www.python.org/downloads/](https://www.python.org/downloads/).\n2. Theo đường link để tải mã nguồn nén có sẵn cho Unix/Linux.\n3. Tải xuống và giải nén các tệp.\n4. Chỉnh sửa tệp Modules/Setup nếu bạn muốn tùy chỉnh một số tùy chọn.\n5. Bây giờ thực hiện các lệnh sau:\n\n```bash\n$ ./configure # chạy tập lệnh configure\n$ make # biên dịch mã nguồn\n$ make install # cài đặt\n```\n\nĐiều này cài đặt Python ở vị trí tiêu chuẩn /usr/local/bin và các thư viện của nó ở /usr/local/lib/pythonXX, trong đó XX là phiên bản của Python.\n\n#### Sử Dụng Lệnh Yum\n\nRed Hat Enterprise Linux (RHEL 8) không cài đặt Python 3 theo mặc định. Chúng ta thường sử dụng lệnh yum trên CentOS và các biến thể liên quan khác. Quy trình cài đặt Python-3 trên RHEL 8 như sau:\n\n```bash\n$ sudo yum install python3\n```\n\n#### Cài Đặt Python trên Windows\n\nLưu ý rằng Python từ phiên bản 3.10 trở đi không thể cài đặt trên các hệ điều hành Windows 7 hoặc cũ hơn.\n\nCách khuyến nghị để cài đặt Python là sử dụng trình cài đặt chính thức. Một liên kết đến phiên bản ổn định mới nhất được đưa ra trên trang chủ. Nó cũng được tìm thấy tại [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/).\n\nBạn có thể tìm thấy các gói nhúng và trình cài đặt cho cả kiến trúc 32 và 64 bit.\n\n![](https://www.python.org/static/img/emacs.png)\n\nHãy tải xuống trình cài đặt 64 bit Windows.\n\n[Double click](https://www.python.org/ftp/python/3.11.2/python-3.11.2-amd64.exe) vào tệp đã tải xuống để bắt đầu quá trình cài đặt.\n\nMặc dù bạn có thể tiếp tục bằng cách nhấn nút Cài đặt Ngay bây giờ, nhưng nên chọn thư mục cài đặt với đường dẫn ngắn hơn, và đánh dấu ô kiểm thứ hai để cập nhật biến PATH.\n\nChấp nhận các giá trị mặc định cho các bước còn lại trong thuật sĩ cài đặt này để hoàn tất quá trình cài đặt.\n\nMở terminal Command Prompt trên Windows và chạy Python để kiểm tra việc cài đặt đã thành công hay không.\n\n```bash\nC:\\Users\\Acer>python\nPython 3.11.2 (tags/v3.11.2:878ead1, Feb 7 2023, 16:38:35) [MSC v.1934\n64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```\n\nThư viện chuẩn của Python có một mô-đun thực thi được gọi là IDLE – viết tắt của Môi Trường Phát Triển và Học Tập Tích Hợp. Tìm nó từ menu Start của Windows và khởi chạy.\n\n![](https://www.python.org/static/img/pythonwin_screenshot.jpg)\n\nIDLE chứa Python shell (trình thông dịch tương tác) và một trình soạn thảo văn bản đa cửa sổ có thể tùy chỉnh với các tính năng như làm nổi bật cú pháp, lùi thông minh, hoàn thành tự động, v.v. Nó là đa nền tảng nên hoạt động giống nhau trên Windows, MacOS và Linux. Nó cũng có một bộ gỡ lỗi với khả năng đặt điểm dừng, bước tiếp theo và xem các không gian tên toàn cục và cục bộ.\n\nDưới đây là các bước để cài đặt Python trên máy Windows.\n\n1. Mở trình duyệt Web và truy cập vào [https://www.python.org/downloads/](https://www.python.org/downloads/).\n2. Theo liên kết cho tệp cài đặt Windows python-XYZ.msi nơi XYZ là phiên bản bạn cần cài đặt.\n3. Để sử dụng trình cài đặt python-XYZ.msi này, hệ thống Windows phải hỗ trợ Trình cài đặt Microsoft 2.0. Lưu tệp cài đặt xuống máy cục bộ của bạn và sau đó chạy nó để biết máy của bạn có hỗ trợ MSI hay không.\n4. Chạy tệp đã tải xuống. Điều này đưa ra Trình cài đặt Python, rất dễ sử dụng. Chỉ cần chấp nhận các thiết lập mặc định, chờ đợi cho đến khi cài đặt hoàn tất và bạn đã xong.\n\n#### Cài Đặt trên Macintosh\n\nCác máy Mac gần đây đi kèm với Python được cài đặt sẵn, nhưng nó có thể đã cũ vài năm. Truy cập [http://www.python.org/download/mac/](http://www.python.org/download/mac/) để biết hướng dẫn cách lấy phiên bản hiện tại cùng với các công cụ bổ sung để hỗ trợ phát triển trên Mac. Đối với các phiên bản cũ hơn của macOS trước khi Mac OS X 10.3 (phát hành vào năm 2003), có sẵn MacPython.\n\nJack Jansen duy trì nó và bạn có thể truy cập vào toàn bộ tài liệu tại trang web của anh ấy − [http://www.cwi.nl/~jack/macpython.html](http://www.cwi.nl/~jack/macpython.html). Bạn có thể tìm thấy các thông tin chi tiết về cách cài đặt hoàn chỉnh cho việc cài đặt Mac OS.\n\n### Thiết Lập Biến Môi Trường PATH\n\nCác chương trình và các tệp thực thi khác có thể nằm ở nhiều thư mục khác nhau, vì vậy hệ điều hành cung cấp một đường dẫn tìm kiếm liệt kê các thư mục mà hệ điều hành tìm kiếm các tệp thực thi.\n\nĐường dẫn được lưu trữ trong một biến môi trường, là một chuỗi có tên được duy trì bởi hệ điều hành. Biến này chứa thông tin có sẵn cho bộ nhớ đệm lệnh và các chương trình khác.\n\nBiến đường dẫn được đặt tên là PATH trong Unix hoặc Path trong Windows (Unix phân biệt chữ hoa; Windows không phân biệt chữ hoa).\n\nTrong macOS, trình cài đặt xử lý các chi tiết về đường dẫn. Để gọi trình thông dịch Python từ bất kỳ thư mục cụ thể nào, bạn phải thêm thư mục Python vào đường dẫn của mình.\n\n#### Thiết Lập Đường Dẫn trong Unix/Linux\n\nĐể thêm thư mục Python vào đường dẫn cho một phiên trong Unix −\n\n- Trong shell csh − gõ `setenv PATH \"$PATH:/usr/local/bin/python\"` và nhấn Enter.\n- Trong shell bash (Linux) − gõ `export PATH=\"$PATH:/usr/local/bin/python\"` và nhấn Enter.\n- Trong shell sh hoặc ksh − gõ `PATH=\"$PATH:/usr/local/bin/python\"` và nhấn Enter.\n\n#### Thiết Lập Đường Dẫn trong Windows\n\nĐể thêm thư mục Python vào đường dẫn cho một phiên trong Windows −\n\n- Ở dấu nhắc lệnh − gõ `path %path%;C:\\Python` và nhấn Enter.\n\nBiến `PYTHONPATH` có vai trò tương tự như `PATH`. Biến này cho biết trình thông dịch Python nơi nào để đặt các tệp mô-đun được nhập vào một chương trình. Nó nên bao gồm thư viện nguồn Python và các thư mục chứa mã nguồn Python. `PYTHONPATH` đôi khi được thiết lập trước bởi trình cài đặt Python.\n\nBiến `PYTHONSTARTUP` chứa đường dẫn của một tệp khởi tạo chứa mã nguồn Python. Nó được thực thi mỗi khi bạn bắt đầu trình thông dịch. Nó có tên là .pythonrc.py trong Unix và nó chứa các lệnh để tải các tiện ích hoặc sửa đổi `PYTHONPATH`.\n\nBiến `PYTHONCASEOK` được sử dụng trong Windows để hướng dẫn Python tìm kiếm sự phù hợp không phân biệt chữ hoa đầu tiên trong một câu lệnh nhập. Đặt biến này thành bất kỳ giá trị nào để kích hoạt nó.\n\nBiến `PYTHONHOME` là một đường dẫn thư mục mô-đun thay thế. Thông thường nó được nhúng trong các thư mục `PYTHONSTARTUP` hoặc `PYTHONPATH` để làm cho việc chuyển đổi thư viện mô-đun dễ dàng hơn.\n\n### Chạy Python\n\nCó ba cách khác nhau để bắt đầu Python −\n\n#### Trình Thông Dịch Tương Tác\n\nBạn có thể bắt đầu Python từ Unix, DOS, hoặc bất kỳ hệ thống nào cung cấp cho bạn một bộ thông dịch dòng lệnh hoặc cửa sổ shell.\n\nNhập `python` vào dòng lệnh.\n\nBắt đầu viết mã ngay",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 9,
        "fields": {
            "name": "Bài 08. Python - Môi Trường Ảo",
            "content": "# Bài 08. Python - Môi Trường Ảo\n\nTrong hướng dẫn này, chúng ta sẽ tìm hiểu về các môi trường ảo trong Python và cách tạo và kích hoạt một môi trường ảo để xây dựng một ứng dụng Python.\n\n## Môi Trường Ảo Python\n\nMôi trường ảo Python tạo ra một cài đặt Python ảo bên trong một thư mục dự án. Người dùng sau đó có thể cài đặt và quản lý các gói Python cho mỗi dự án. Điều này cho phép người dùng có thể cài đặt các gói và sửa đổi môi trường Python của họ mà không sợ làm hỏng các gói được cài đặt trong các môi trường khác.\n\n### Môi Trường Ảo trong Python là gì?\n\nMột môi trường ảo Python là:\n\n- Được xem như là một thứ không cần thiết.\n- Được sử dụng để chứa một bản cụ thể của trình thông dịch Python và các thư viện và tập lệnh phần mềm cần thiết để hỗ trợ một dự án.\n- Được chứa trong một thư mục, thông thường được đặt tên là venv hoặc .venv trong thư mục dự án.\n- Không được coi là có thể di chuyển hoặc sao chép.\n\nKhi bạn cài đặt phần mềm Python trên máy tính của mình, nó sẽ có sẵn để sử dụng từ bất kỳ đâu trên hệ thống tệp. Đây là một cài đặt toàn cầu trên toàn hệ thống.\n\n### Tạo Môi Trường Ảo trong Python bằng venv\n\nChức năng này được hỗ trợ bởi module venv trong bản phân phối Python tiêu chuẩn. Sử dụng các lệnh sau để tạo một môi trường ảo mới.\n\n```bash\nC:\\Users\\Acer>md\\pythonapp\nC:\\Users\\Acer>cd\\pythonapp\nC:\\pythonapp>python -m venv myvenv\n```\n\nỞ đây, myvenv là thư mục mà một môi trường ảo Python mới sẽ được tạo ra hiển thị các cấu trúc thư mục sau:\n\n```\nDirectory of C:\\pythonapp\\myvenv\n22-02-2023 09:53 <DIR> .\n22-02-2023 09:53 <DIR> ..\n22-02-2023 09:53 <DIR> Include\n22-02-2023 09:53 <DIR> Lib\n22-02-2023 09:53 77 pyvenv.cfg\n22-02-2023 09:53 <DIR> Scripts\n```\n\nCác tiện ích để kích hoạt và vô hiệu hóa môi trường ảo cũng như bản sao cục bộ của trình thông dịch Python sẽ được đặt trong thư mục Scripts.\n\n```bash\nDirectory of C:\\pythonapp\\myvenv\\scripts\n22-02-2023 09:53 <DIR> .\n22-02-2023 09:53 <DIR> ..\n22-02-2023 09:53 2,063 activate\n22-02-2023 09:53 992 activate.bat\n22-02-2023 09:53 19,611 Activate.ps1\n22-02-2023 09:53 393 deactivate.bat\n22-02-2023 09:53 106,349 pip.exe\n22-02-2023 09:53 106,349 pip3.10.exe\n22-02-2023 09:53 106,349 pip3.exe\n22-02-2023 09:53 242,408 python.exe\n22-02-2023 09:53 232,688 pythonw.exe\n```\n\n### Kích Hoạt Môi Trường Ảo\n\nĐể kích hoạt môi trường ảo mới này, thực hiện activate.bat trong thư mục Scripts.\n\n```bash\n(myvenv) C:\\pythonapp>\n```\n\nLưu ý tên của môi trường ảo trong dấu ngoặc đơn. Thư mục Scripts chứa bản sao cục bộ của trình thông dịch Python. Bạn có thể bắt đầu một phiên Python trong môi trường ảo này.\n\n### Kiểm Tra xem Python có đang Chạy Bên Trong Một Môi Trường Ảo không?\n\nĐể xác nhận liệu phiên Python này có ở trong môi trường ảo hay không, hãy kiểm tra sys.path.\n\n```bash\n(myvenv) C:\\pythonapp>python\nPython 3.10.1 (tags/v3.10.1:2cd268a, Dec 6 2021, 19:10:37) [MSC v.1929\n64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import sys\n>>> sys.path\n['', 'C:\\\\Python310\\\\python310.zip', 'C:\\\\Python310\\\\DLLs',\n'C:\\\\Python310\\\\lib', 'C:\\\\Python310', 'C:\\\\pythonapp\\\\myvenv',\n'C:\\\\pythonapp\\\\myvenv\\\\lib\\\\site-packages']\n>>>\n```\n\nThư mục Scripts của môi trường ảo này cũng chứa các tiện ích pip. Nếu bạn cài đặt một gói từ PyPI, gói đó sẽ chỉ hoạt động trong môi trường ảo hiện tại.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 10,
        "fields": {
            "name": "Bài 09. Python - Hướng dẫn về Cú Pháp",
            "content": "# Bài 09. Python - Hướng dẫn về Cú Pháp\n\nTrong hướng dẫn này, chúng ta sẽ tìm hiểu về cú pháp trong Python và cách tạo và kích hoạt một môi trường ảo để xây dựng ứng dụng Python.\n\n## Môi Trường Ảo Python\n\nMôi trường ảo Python tạo ra một cài đặt ảo của Python trong một thư mục dự án. Người dùng sau đó có thể cài đặt và quản lý các gói Python cho mỗi dự án. Điều này cho phép người dùng cài đặt gói và sửa đổi môi trường Python mà không lo sợ làm hỏng các gói được cài đặt trong các môi trường khác.\n\n### Khái Niệm về Môi Trường Ảo trong Python\n\nMột môi trường ảo Python là:\n\n- Được coi là có thể bỏ đi.\n- Được sử dụng để chứa một trình thông dịch Python cụ thể và các thư viện và tập lệnh cần thiết để hỗ trợ một dự án.\n- Được chứa trong một thư mục, thường là có tên là venv hoặc .venv trong thư mục dự án.\n- Không được coi là có thể di chuyển hoặc sao chép.\n\n### Tạo Môi Trường Ảo trong Python sử dụng venv\n\nChức năng này được hỗ trợ bởi module venv trong bản phân phối Python tiêu chuẩn. Sử dụng các lệnh sau để tạo một môi trường ảo mới.\n\n```bash\nmkdir pythonapp\ncd pythonapp\npython -m venv myvenv\n```\n\nỞ đây, myvenv là thư mục mà một môi trường ảo Python mới sẽ được tạo ra với cấu trúc thư mục như sau:\n\n```\nDirectory of C:\\pythonapp\\myvenv\n22-02-2023 09:53 <DIR> .\n22-02-2023 09:53 <DIR> ..\n22-02-2023 09:53 <DIR> Include\n22-02-2023 09:53 <DIR> Lib\n22-02-2023 09:53 77 pyvenv.cfg\n22-02-2023 09:53 <DIR> Scripts\n```\n\nCác tiện ích để kích hoạt và vô hiệu hóa môi trường ảo cũng như bản sao cục bộ của trình thông dịch Python sẽ được đặt trong thư mục Scripts.\n\n### Kích Hoạt Môi Trường Ảo\n\nĐể kích hoạt môi trường ảo mới này, thực thi activate.bat trong thư mục Scripts.\n\n```bash\nmyvenv\\scripts\\activate\n```\n\nLưu ý tên của môi trường ảo trong dấu ngoặc đơn. Thư mục Scripts chứa một bản sao cục bộ của trình thông dịch Python. Bạn có thể bắt đầu một phiên Python trong môi trường ảo này.\n\n### Kiểm Tra Python Đang Chạy Trong Một Môi Trường Ảo Hay Không?\n\nĐể xác nhận liệu phiên Python này có trong môi trường ảo hay không, kiểm tra sys.path.\n\n```bash\npython\n```\n\n```python\nPython 3.10.1 (tags/v3.10.1:2cd268a, Dec 6 2021, 19:10:37) [MSC v.1929\n64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import sys\n>>> sys.path\n['', 'C:\\\\Python310\\\\python310.zip', 'C:\\\\Python310\\\\DLLs',\n'C:\\\\Python310\\\\lib', 'C:\\\\Python310', 'C:\\\\pythonapp\\\\myvenv',\n'C:\\\\pythonapp\\\\myvenv\\\\lib\\\\site-packages']\n```\n\nThư mục Scripts của môi trường ảo này cũng chứa các tiện ích pip. Nếu bạn cài đặt một gói từ PyPI, gói đó sẽ chỉ hoạt động trong môi trường ảo hiện tại.\n\n## Python - Cú Pháp\n\n### Chương Trình Python Đầu Tiên\n\nChúng ta hãy thực thi một chương trình Python để in ra \"Hello, World!\" ở hai chế độ lập trình Python khác nhau. (a) Lập trình Chế Độ Tương Tác (b) Lập Trình Chế Độ Kịch Bản.\n\n#### Python - Lập Trình Chế Độ Tương Tác\n\nChúng ta có thể gọi trình thông dịch Python từ dòng lệnh bằng cách nhập python tại dấu nhắc lệnh như sau:\n\n```bash\n$ python3\n```\n\n```python\nPython 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```\n\nỞ đây >>> cho biết Dấu Nhắc Lệnh Python nơi bạn có thể nhập các lệnh của mình. Hãy nhập văn bản sau tại dấu nhắc Python và nhấn Enter:\n\n```python\n>>> print (\"Hello, World!\")\n```\n\nNếu bạn đang chạy phiên bản cũ hơn của Python, như Python 2.4.x, thì bạn cần sử dụng câu lệnh print mà không có dấu ngoặc đơn như in print \"Hello, World!\". Tuy nhiên, trong phiên bản Python 3.x, điều này tạo ra kết quả sau:\n\n```\nHello, World!\n```\n\n#### Python - Lập Trình Chế Độ Kịch Bản\n\nChúng ta có thể gọi trình thông dịch Python với tham số script để bắt đầu thực thi kịch bản và tiếp tục cho đến khi kịch bản kết thúc. Khi kịch bản kết thúc, trình thông dịch không còn hoạt động nữa.\n\nHãy viết một chương trình Python đơn giản trong một tập tin script, là một tệp văn bản đơn giản. Các tệp Python có phần mở rộng .py. Nhập mã nguồn sau vào một tệp test.py −\n\n```python\nprint (\"Hello, World!\")\n```\n\nChúng ta giả sử rằng bạn đã cài đặt đường dẫn trình thông dịch Python trong biến PATH. Bây giờ, hãy thử chạy chương trình này như sau:\n\n```bash\n$ python3 test.py\n```\n\nKết quả sẽ là:\n\n```\nHello, World!\n```\n\nHãy thử một cách khác để thực thi một kịch bản Python. Đây là tệp test.py được sửa đổi −\n\n```python\n#!/usr/bin/python3\n\nprint (\"Hello, World!\")\n```\n\nChúng ta giả sử rằng bạn đã cài đặt trình thông dịch Python có sẵn trong thư mục /usr/bin. Bây giờ, hãy thử chạy chương trình này như sau:\n\n```bash\n$ chmod +x test.py     # Điều này làm cho tệp có thể thực thi được\n$ ./test.py\n```\n\nKết quả sẽ là:\n\n```\nHello, World!\n```\n\n### Nhận Diện Biến trong Python\n\nMột nhận dạng Python là một tên được sử dụng để xác định một biến, hàm, lớp, module hoặc đối tượng khác. Một nhận dạng bắt đầu bằng một chữ cái A đến Z hoặc a đến z hoặc một gạch dưới (_) theo sau là không hoặc nhiều chữ cái, gạch dưới và chữ số (0 đến 9).\n\nPython không cho phép các ký tự dấu chấm câu như @, $ và % trong nhận dạng.\n\nPython là một ngôn ngữ lập trình phân biệt chữ hoa chữ thường. Do đó, Manpower và manpower là hai nhận dạng khác nhau trong Python.\n\nDưới đây là các quy tắc đặt tên cho các nhận dạng Python:\n\n- Tên lớp Python bắt đầu bằng một chữ cái in hoa. Tất cả các nhận dạng khác bắt đầu bằng một chữ cái thường.\n- Bắt đầu một nhận dạng với một gạch dưới đơn làm cho nhận dạng là một nhận dạng riêng tư.\n- Bắt đầu một nhận dạng với hai gạch dưới đầu tiên chỉ ra một nhận dạng mạnh mẽ riêng tư.\n- Nếu nhận dạng cũng kết thúc với hai gạch dưới, nhận dạng là một tên đặc biệt được định nghĩa bởi ngôn ngữ.\n\n### Từ Khóa Đã Được Dành Riêng trong Python\n\nDanh sách sau đây hiển thị các từ khóa Python. Đây là các từ khóa được dành riêng và bạn không thể sử dụng chúng như tên hằng số hoặc biến hoặc bất kỳ nhận dạng nào khác. Tất cả các từ khóa Python chứa các chữ cái thường.\n\n```\nand     as      assert\nbreak   class   continue\ndef     del     elif\nelse    except  False\nfinally for     from\nglobal  if      import\nin      is      lambda\nNone    nonlocal    not\nor      pass   ",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 11,
        "fields": {
            "name": "Bài 10. Biến trong Python",
            "content": "# Bài 10. Biến trong Python\n\nBiến Python là các vị trí bộ nhớ được dành riêng để lưu trữ các giá trị trong chương trình Python. Điều này có nghĩa là khi bạn tạo một biến, bạn đặt dành một số không gian trong bộ nhớ.\n\nDựa trên kiểu dữ liệu của một biến, trình thông dịch Python phân bổ bộ nhớ và quyết định những gì có thể được lưu trữ trong bộ nhớ dành riêng đó. Do đó, bằng cách gán các kiểu dữ liệu khác nhau cho các biến Python, bạn có thể lưu trữ số nguyên, số thập phân hoặc ký tự trong các biến này.\n\n### Địa Chỉ Bộ Nhớ\n\nCác mục dữ liệu thuộc các loại dữ liệu khác nhau được lưu trữ trong bộ nhớ của máy tính. Các vị trí bộ nhớ của máy tính có một số hoặc địa chỉ, được biểu diễn bên trong dưới dạng nhị phân. Dữ liệu cũng được lưu trữ dưới dạng nhị phân vì máy tính hoạt động theo nguyên lý biểu diễn nhị phân. Trong biểu đồ dưới đây, một chuỗi May và một số 18 được hiển thị là được lưu trữ tại các vị trí bộ nhớ.\n\n[Memory Diagram]\n\nNếu bạn biết ngôn ngữ hợp ngữ, bạn sẽ chuyển đổi các mục dữ liệu này và địa chỉ bộ nhớ, và đưa ra một hướng dẫn ngôn ngữ máy. Tuy nhiên, điều này không dễ dàng đối với mọi người. Trình dịch ngôn ngữ như trình thông dịch Python thực hiện loại chuyển đổi này. Nó lưu trữ đối tượng trong một vị trí bộ nhớ được chọn ngẫu nhiên. Hàm id() được tích hợp sẵn trong Python trả về địa chỉ nơi đối tượng được lưu trữ.\n\n```python\n>>> \"May\"\nMay\n>>> id(\"May\")\n2167264641264\n\n>>> 18\n18\n>>> id(18)\n140714055169352\n```\n\nKhi dữ liệu được lưu trữ trong bộ nhớ, nó nên được truy cập lặp đi lặp lại để thực hiện một quy trình nhất định. Rõ ràng, việc trích xuất dữ liệu từ ID của nó là rườm rà. Ngôn ngữ cao cấp như Python giúp cho việc đặt một biệt danh hoặc nhãn phù hợp để tham chiếu đến vị trí bộ nhớ.\n\nTrong ví dụ trên, hãy đặt nhãn cho vị trí của May là month và vị trí mà 18 được lưu trữ là age. Python sử dụng toán tử gán (=) để liên kết một đối tượng với nhãn.\n\n```python\n>>> month = \"May\"\n>>> age = 18\n```\n\nĐối tượng dữ liệu (May) và tên của nó (month) có cùng id(). id() của 18 và age cũng giống nhau.\n\n```python\n>>> id(month)\n2167264641264\n>>> id(age)\n140714055169352\n```\n\nNhãn là một nhận dạng. Thông thường, nó được gọi là một biến. Một biến Python là một tên biểu tượng là một tham chiếu hoặc con trỏ đến một đối tượng.\n\n### Tạo Biến Python\n\nBiến Python không cần khai báo rõ ràng để đặt dành không gian bộ nhớ hoặc bạn có thể nói để tạo ra một biến. Một biến Python được tạo ra tự động khi bạn gán một giá trị cho nó. Dấu bằng (=) được sử dụng để gán giá trị cho biến.\n\nToán hạng bên trái của toán tử = là tên của biến và toán hạng bên phải của toán tử = là giá trị được lưu trữ trong biến. Ví dụ −\n\n#### Ví dụ Tạo Biến Python\n\nVí dụ này tạo ra các loại biến khác nhau (một số nguyên, một số thực và một chuỗi).\n\n```python\ncounter = 100          # Tạo ra một biến số nguyên\nmiles = 1000.0         # Tạo ra một biến số thực\nname = \"8 Sync Dev\"      # Tạo ra một biến chuỗi\n```\n\n### In Các Biến Python\n\nSau khi chúng ta tạo một biến Python và gán một giá trị cho nó, chúng ta có thể in nó bằng cách sử dụng hàm print(). Dưới đây là phần mở rộng của ví dụ trước và chỉ ra cách in các biến khác nhau trong Python:\n\n#### Ví dụ In Các Biến Python\n\nVí dụ này in các biến.\n\n```python\ncounter = 100          # Tạo ra một biến số nguyên\nmiles = 1000.0         # Tạo ra một biến số thực\nname = \"8 Sync Dev\"      # Tạo ra một biến chuỗi\n\nprint(counter)\nprint(miles)\nprint(name)\n```\n\nỞ đây, 100, 1000.0 và \"8 Sync Dev\" là các giá trị được gán cho các biến counter, miles và name, tương ứng. Khi chạy chương trình Python trên, điều này tạo ra kết",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 12,
        "fields": {
            "name": "Bài 11. Tài liệu Hướng dẫn về Các Loại Dữ Liệu và Ép Kiểu trong Python",
            "content": "# Bài 11. Tài liệu Hướng dẫn về Các Loại Dữ Liệu và Ép Kiểu trong Python\n\n## Giới thiệu\n\nTrong lập trình, dữ liệu là một phần quan trọng và đóng vai trò quan trọng trong việc xử lý thông tin. Trong Python, các loại dữ liệu được sử dụng để định nghĩa loại dữ liệu mà ta sẽ lưu trữ trong một biến và xử lý trong chương trình. Dữ liệu được lưu trữ trong bộ nhớ của máy tính có thể là nhiều loại khác nhau, ví dụ: tuổi của một người được lưu trữ dưới dạng một giá trị số và địa chỉ của họ được lưu trữ dưới dạng các ký tự chữ và số.\n\n## Loại Dữ Liệu trong Python\n\nPython hỗ trợ nhiều loại dữ liệu tích hợp sẵn, bao gồm:\n\n1. **Dữ liệu Số:** int, float, complex\n2. **Dữ liệu Chuỗi:** str (kiểu dữ liệu dạng văn bản)\n3. **Dữ liệu Dãy:** list, tuple, range\n4. **Dữ liệu Nhị Phân:** bytes, bytearray, memoryview\n5. **Dữ liệu Ánh Xạ:** dict\n6. **Dữ liệu Boolean:** bool\n7. **Dữ liệu Tập hợp:** set, frozenset\n8. **Dữ liệu None:** NoneType\n\n## Dữ Liệu Số trong Python\n\nDữ liệu số trong Python được sử dụng để lưu trữ các giá trị số. Có bốn loại số khác nhau trong Python:\n\n- **int:** Số nguyên\n- **float:** Số thực\n- **complex:** Số phức\n\nVí dụ:\n\n```python\nvar1 = 1       # int\nvar2 = True    # bool\nvar3 = 10.023  # float\nvar4 = 10+3j   # complex\n```\n\n## Dữ Liệu Chuỗi trong Python\n\nDữ liệu chuỗi trong Python là một chuỗi gồm một hoặc nhiều ký tự Unicode, được bao quanh bởi dấu nháy đơn, dấu nháy kép hoặc dấu nháy ba. Chuỗi trong Python là không thể thay đổi, có nghĩa là khi bạn thực hiện một phép toán trên chuỗi, bạn luôn tạo ra một đối tượng chuỗi mới cùng loại, thay vì biến đổi một chuỗi hiện tại.\n\n```python\nstr1 = 'Hello World!'\n```\n\n## Dữ Liệu Dãy trong Python\n\nDãy trong Python là một tập hợp có thứ tự của các phần tử. Có ba loại dãy trong Python:\n\n- **List:** Dãy có thể thay đổi\n- **Tuple:** Dãy không thể thay đổi\n- **Range:** Dãy số liên tục\n\nVí dụ:\n\n```python\nlist1 = [1, 2, 3, 4, 5]     # list\ntuple1 = (1, 2, 3, 4, 5)    # tuple\nrange1 = range(1, 6)        # range\n```\n\n## Dữ Liệu Nhị Phân trong Python\n\nDữ liệu nhị phân trong Python là cách biểu diễn dữ liệu dưới dạng một chuỗi các chữ số nhị phân, chỉ bao gồm các số 0 và 1. Python cung cấp ba cách khác nhau để biểu diễn dữ liệu nhị phân:\n\n- **bytes:** Dữ liệu bytes không thể thay đổi\n- **bytearray:** Dữ liệu bytearray có thể thay đổi\n- **memoryview:** Dữ liệu memoryview\n\nVí dụ:\n\n```python\nbytes1 = b'Hello'           # bytes\nbytearray1 = bytearray(b'Hello')  # bytearray\n```\n\n## Dữ Liệu Ánh Xạ trong Python\n\nDữ liệu ánh xạ trong Python là một cấu trúc dữ liệu dạng hash table. Mỗi phần tử trong ánh xạ được xác định bằng một cặp key:value. Trong Python, ánh xạ là một đối tượng của lớp dict.\n\n```python\ndict1 = {'name': 'John', 'age': 30, 'city': 'New York'}  # dict\n```\n\n## Dữ Liệu Boolean trong Python\n\nDữ liệu Boolean trong Python biểu diễn một trong hai giá trị: True hoặc False. Dữ liệu Boolean thường được sử dụng để kiểm tra điều kiện trong các biểu thức điều kiện.\n\n```python\nbool1 = True   # bool\nbool2 = False  # bool\n```\n\n## Ép Kiểu Dữ Liệu trong Python\n\nĐôi khi, bạn có thể cần thực hiện chuyển đổi giữa các loại dữ liệu Python. Để chuyển đổi dữ liệu giữa các loại khác nhau trong Python, bạn đơn giản sử dụng tên loại dữ liệu như một hàm.\n\nVí dụ:\n\n```python\na = int(1)        # Ép kiểu thành số nguyên\nb = float(2.2)    # Ép kiểu thành số thực\nc = str(3.3)      # Ép kiểu thành chuỗi\n```\n",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 13,
        "fields": {
            "name": "Bài 12. Hướng dẫn Ép Kiểu trong Python",
            "content": "# Bài 12. Hướng dẫn Ép Kiểu trong Python\n\n## Giới thiệu\n\nÉp kiểu trong lập trình là quá trình chuyển đổi một đối tượng từ một kiểu dữ liệu sang kiểu dữ liệu khác. Trong phần này, chúng ta sẽ tìm hiểu về việc ép kiểu trong lập trình Python.\n\nÉp kiểu trong Python là quá trình chuyển đổi một giá trị của một kiểu dữ liệu sang một kiểu dữ liệu khác. Python hỗ trợ hai loại ép kiểu - ép kiểu ngầm định và ép kiểu tường minh.\n\n## Ép Kiểu Ngầm Định trong Python\n\nKhi bất kỳ trình biên dịch/ngôn ngữ nào tự động chuyển đổi đối tượng của một kiểu sang kiểu khác, đó được gọi là ép kiểu tự động hoặc ngầm định. Python là một ngôn ngữ có kiểu dữ liệu mạnh mẽ. Nó không cho phép chuyển đổi kiểu tự động giữa các kiểu dữ liệu không liên quan. Ví dụ, một chuỗi không thể được chuyển đổi thành bất kỳ kiểu số nào. Tuy nhiên, một số nguyên có thể được ép kiểu thành số thực. Các ngôn ngữ khác như JavaScript là ngôn ngữ có kiểu dữ liệu yếu, trong đó một số nguyên được ép kiểu thành chuỗi để nối chuỗi.\n\nLưu ý rằng yêu cầu bộ nhớ cho mỗi kiểu dữ liệu là khác nhau. Ví dụ, một đối tượng số nguyên trong Python chiếm 4 byte bộ nhớ, trong khi một đối tượng số thực cần 8 byte vì phần thập phân của nó. Do đó, trình thông dịch Python không tự động chuyển đổi một số thực sang số nguyên, vì điều này sẽ dẫn đến mất dữ liệu. Ngược lại, số nguyên có thể dễ dàng được chuyển đổi thành số thực bằng cách đặt phần thập phân của nó bằng 0.\n\nÉp kiểu ngầm định từ số nguyên sang số thực xảy ra khi thực hiện bất kỳ phép toán số học nào giữa các toán hạng số nguyên và số thực.\n\nGiả sử chúng ta có một biến số nguyên và một biến số thực:\n\n```python\na = 10   # Đối tượng số nguyên\nb = 10.5 # Đối tượng số thực\n```\n\nĐể thực hiện phép cộng giữa chúng, 10 - đối tượng số nguyên được nâng cấp thành 10.0. Đây là một số thực, nhưng tương đương với giá trị số của nó trước đó. Bây giờ chúng ta có thể thực hiện phép cộng của hai số thực.\n\n```python\nc = a + b\nprint(c)  # Output: 20.5\n```\n\nTrong ép kiểu ngầm định, một đối tượng Python với kích thước byte nhỏ hơn được nâng cấp để phù hợp với kích thước byte lớn hơn của đối tượng khác trong phép toán. Ví dụ, một đối tượng Boolean được nâng cấp trước thành số nguyên, sau đó trở thành số thực, trước khi thực hiện phép cộng với một đối tượng số thực. Trong ví dụ sau, chúng ta cố gắng cộng một đối tượng Boolean với một số thực. Lưu ý rằng True tương đương với 1 và False tương đương với 0.\n\n```python\na = True\nb = 10.5\nc = a + b\nprint(c)  # Output: 11.5\n```\n\n## Ép Kiểu Tường Minh trong Python\n\nMặc dù ép kiểu tự động hoặc ngầm định chỉ giới hạn ở việc chuyển đổi từ số nguyên sang số thực, bạn có thể sử dụng các hàm tích hợp sẵn của Python như int(), float() và str() để thực hiện các chuyển đổi tường minh như chuỗi thành số nguyên.\n\n### Hàm int() trong Python\n\nHàm int() tích hợp sẵn của Python chuyển đổi một hằng số số nguyên thành một đối tượng số nguyên, một số thực thành số nguyên, và một chuỗi thành số nguyên nếu chuỗi đó có biểu diễn số nguyên hợp lệ.\n\nNếu đối số cho hàm int() là một đối tượng số thực hoặc biểu thức số thực, nó trả về một đối tượng số nguyên. Ví dụ:\n\n```python\na = int(10.5)     # Chuyển đổi một đối tượng số thực thành số nguyên\nprint(a)          # Output: 10\n```\n\nNếu đối số cho hàm int() là một đối tượng Boolean, giá trị trả về là số nguyên 1.\n\n```python\na = int(True)     # Chuyển đổi một đối tượng Boolean thành số nguyên\nprint(a)          # Output: 1\n```\n\nChuyển đổi từ chuỗi thành số nguyên chỉ xảy ra nếu chuỗi đó chứa biểu diễn số nguyên hợp lệ.\n\n```python\na = int(\"100\")    # Chuyển đổi một chuỗi thành số nguyên\nprint(a)          # Output: 100\n```\n\nNếu chuỗi chứa một biểu diễn không hợp lệ của số nguyên, Python sẽ raise một ValueError.\n\n```python\na = int(\"10.5\")   # Lỗi: chuỗi không hợp lệ cho int()\n```\n\n### Hàm float() trong Python\n\nHàm float() của Python chuyển đổi một hằng số số nguyên thành một đối tượng số thực, một số thực thành một số thực, và một chuỗi thành một số thực nếu chuỗi đó có biểu diễn số thực hợp lệ.\n\nNếu đối số cho hàm float() là một đối tượng số nguyên, nó trả về một đối tượng số thực.\n\n```python\na = float(100)    # Chuyển đổi một đối tượng số nguyên thành số thực\nprint(a)          # Output: 100.0\n```\n\nNếu đối số cho hàm float() là một chuỗi, và chuỗi đó chứa một biểu diễn số thực hợp lệ, nó sẽ trả về một đối tượng số thực.\n\n```python\na = float(\"10.5\") # Chuyển đổi một chuỗi thành số thực\nprint(a)          # Output: 10.5\n```\n\nNếu chuỗi chứa một biểu diễn không hợp lệ của số thực, Python sẽ raise một ValueError.\n\n```python\na = float(\"Hello\") # Lỗi: chuỗi không hợp lệ cho float()\n```\n\n### Hàm str() trong Python\n\nHàm str() của Python chuyển đổi một đối tượng thành một biểu diễn chuỗi của đối tượng đó.\n\n```python\na = str(10)     # Chuyển đổi một số nguyên thành chuỗi\nprint(a)        # Output: '10'\n```\n\n```python\na = str(10.5)   # Chuyển đổi một số thực thành chuỗi\nprint(a)        # Output: '10.5'\n```\n\n```python\na = str(True)   # Chuyển đổi một Boolean thành chuỗi\nprint(a)        # Output: 'True'\n```\n\nHàm str() cũng có thể chuyển đổi một danh sách hoặc một bộ thành một chuỗi.\n\n```python\na = str([1, 2, 3])    # Chuyển đổi một danh sách thành chuỗi\nprint(a)              # Output: '[1, 2, 3]'\n```\n\n```python\na = str((1, 2, 3))    # Chuyển đổi một bộ thành chuỗi\nprint(a)              # Output: '(1, 2, 3)'\n```\n\n## Kết Luận\n\nTrong Python, ép kiểu là một phần quan trọng của việc xử lý dữ liệu. Bằng cách sử dụng các hàm tích hợp sẵn như int(), float() và str(), bạn có thể chuyển đổi giữa các kiểu dữ liệu một cách dễ dàng và linh hoạt. Điều này cho phép bạn làm việc với dữ liệu một cách hiệu quả trong các ứng dụng Python của mình.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 14,
        "fields": {
            "name": "Bài 13. Hệ thống Unicode trong Python",
            "content": "# Bài 13. Hệ thống Unicode trong Python\n\nCác ứng dụng phần mềm thường cần hiển thị các thông điệp ra màn hình bằng nhiều ngôn ngữ khác nhau như Tiếng Anh, Tiếng Pháp, Tiếng Nhật, Tiếng Do Thái hoặc Tiếng Hindi. Kiểu chuỗi của Python sử dụng Tiêu chuẩn Unicode để biểu diễn các ký tự. Điều này giúp cho chương trình có thể làm việc với tất cả các ký tự khác nhau này.\n\nMột ký tự là thành phần nhỏ nhất của một văn bản. 'A', 'B', 'C', v.v., tất cả đều là các ký tự khác nhau. Tương tự như vậy là 'È' và 'Í'. Một chuỗi Unicode là một chuỗi các điểm mã, là các số từ 0 đến 0x10FFFF (tương đương với 1.114.111 dạng thập phân). Chuỗi này của các điểm mã cần được biểu diễn trong bộ nhớ dưới dạng một tập hợp các đơn vị mã, và các đơn vị mã sau đó được ánh xạ thành các byte 8-bit.\n\n### Mã hóa ký tự\n\nMột chuỗi các điểm mã được biểu diễn trong bộ nhớ dưới dạng một tập hợp các đơn vị mã, ánh xạ thành các byte 8-bit. Quy tắc cho việc dịch một chuỗi Unicode thành một chuỗi byte được gọi là mã hóa ký tự.\n\nCó ba loại mã hóa: UTF-8, UTF-16 và UTF-32. UTF viết tắt của Unicode Transformation Format.\n\n### Hỗ trợ Unicode của Python\n\nTừ Python 3.0 trở đi, Python tích hợp sẵn hỗ trợ cho Unicode. Kiểu str chứa các ký tự Unicode, do đó bất kỳ chuỗi nào được tạo bằng cú pháp chuỗi đơn, chuỗi kép hoặc chuỗi ba dấu ngoặc kép đều được lưu trữ dưới dạng Unicode. Mã hóa mặc định cho mã nguồn Python là UTF-8.\n\nDo đó, chuỗi có thể chứa biểu diễn chữ của một ký tự Unicode (3/4) hoặc giá trị Unicode của nó (\\u00BE).\n\n#### Ví dụ\n\n```python\nvar = \"3/4\"\nprint(var)\nvar = \"\\u00BE\"\nprint(var)\n```\n\nĐoạn mã trên sẽ tạo ra đầu ra như sau:\n\n```\n3/4\n¾\n```\n\n#### Ví dụ\n\nTrong ví dụ sau, một chuỗi '10' được lưu trữ bằng các giá trị Unicode của 1 và 0, lần lượt là \\u0031 và u0030.\n\n```python\nvar = \"\\u0031\\u0030\"\nprint(var)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n10\n```\n\nChuỗi hiển thị văn bản dưới dạng dễ đọc cho con người, và byte lưu trữ các ký tự dưới dạng dữ liệu nhị phân. Mã hóa chuyển đổi dữ liệu từ một chuỗi ký tự thành một chuỗi byte. Giải mã chuyển đổi các byte trở lại thành các ký tự và ký hiệu dễ đọc cho con người. Quan trọng là không nên nhầm lẫn giữa hai phương pháp này. `encode` là một phương thức chuỗi, trong khi `decode` là một phương thức của đối tượng byte của Python.\n\n#### Ví dụ\n\nTrong ví dụ sau, chúng ta có một biến chuỗi mà gồm các ký tự ASCII. ASCII là một phần của bộ ký tự Unicode. Phương thức `encode()` được sử dụng để chuyển đổi nó thành một đối tượng byte.\n\n```python\nstring = \"Hello\"\ntobytes = string.encode('utf-8')\nprint(tobytes)\nstring = tobytes.decode('utf-8')\nprint(string)\n```\n\nPhương thức `decode()` chuyển đổi đối tượng byte trở lại thành đối tượng str. Phương thức mã hóa được sử dụng là utf-8.\n\n```\nb'Hello'\nHello\n```\n\n#### Ví dụ\n\nTrong ví dụ sau, biểu tượng Rupee (₹) được lưu trữ trong biến bằng giá trị Unicode của nó. Chúng tôi chuyển đổi chuỗi thành byte và sau đó trở lại str.\n\n```python\nstring = \"\\u20B9\"\nprint(string)\ntobytes = string.encode('utf-8')\nprint(tobytes)\nstring = tobytes.decode('utf-8')\nprint(string)\n```\n\nKhi bạn thực thi mã trên, nó sẽ tạo ra đầu ra sau:\n\n```\n₹\nb'\\xe2\\x82\\xb9'\n₹\n```\n",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 15,
        "fields": {
            "name": "Bài 14. Python - Các Kiểu Chữ Số",
            "content": "# Bài 14. Python - Các Kiểu Chữ Số\n\n**1. Giới Thiệu về Các Kiểu Chữ Số trong Python**\n\nCác kiểu chữ số hoặc hằng số trong Python là cách biểu diễn một giá trị cố định trong mã nguồn. Khác với biến, các hằng số (123, 4.3, \"Hello\") là các giá trị tĩnh hoặc bạn có thể nói là các hằng số không thay đổi trong suốt hoạt động của chương trình hoặc ứng dụng. Ví dụ, trong câu lệnh gán sau:\n\n```python\nx = 10\n```\n\nỞ đây, 10 là một hằng số là giá trị số, được lưu trữ trực tiếp trong bộ nhớ. Tuy nhiên,\n\n```python\ny = x*2\n```\n\nỞ đây, ngay cả khi biểu thức tính toán ra 20, nó không được thêm vào mã nguồn một cách trực tiếp. Bạn cũng có thể khai báo một đối tượng int bằng hàm `int()` tích hợp sẵn. Tuy nhiên, đây cũng là một cách khởi tạo gián tiếp và không phải là sử dụng các hằng số.\n\n```python\nx = int(10)\n```\n\n**2. Các Loại Kiểu Chữ Số trong Python**\n\nPython cung cấp các hằng số sau sẽ được giải thích trong bài hướng dẫn này:\n\n- Kiểu Chữ Số Nguyên\n- Kiểu Chữ Số Phẩy Động\n- Kiểu Chữ Số Phức\n- Kiểu Chữ Số Chuỗi\n- Kiểu Chữ Số Danh Sách\n- Kiểu Chữ Số Tuple\n- Kiểu Chữ Số Từ Điển\n\n**3. Kiểu Chữ Số Nguyên Python**\n\nBất kỳ biểu diễn nào chỉ bao gồm các ký tự số (0 đến 9) sẽ tạo ra một đối tượng kiểu int. Đối tượng được khai báo như vậy có thể được tham chiếu bằng một biến bằng toán tử gán.\n\n**Ví dụ: Biểu Diễn Số Thập Phân**\n\n```python\nx = 10\ny = -25\nz = 0\n```\n\n**Ví dụ: Biểu Diễn Số Bát Phân**\n\nPython cho phép một số nguyên được biểu diễn dưới dạng số bát phân hoặc số thập lục phân. Một biểu diễn số học với chỉ tám ký tự số (0 đến 7) nhưng được tiền tố bởi 0o hoặc 0O là một số bát phân trong Python.\n\n```python\nx = 0O34\n```\n\n**Ví dụ: Biểu Diễn Số Thập Lục Phân**\n\nTương tự, một chuỗi các ký tự thập lục phân (0 đến 9 và a đến f), tiền tố bởi 0x hoặc 0X đại diện cho một số nguyên dưới dạng thập lục phân trong Python.\n\n```python\nx = 0X1C\n```\n\n**Ví dụ: Biểu Diễn Số Thập Phân và Thập Lục Phân**\n\nTuy nhiên, có thể lưu ý rằng, ngay cả khi bạn sử dụng biểu diễn số học bát phân hoặc thập lục phân, Python nội bộ xem xét chúng như là kiểu int.\n\n```python\n# Sử dụng biểu diễn bát phân\nx = 0O34\nprint(\"0O34 trong bát phân là\", x, type(x))\n# Sử dụng biểu diễn thập lục phân\nx = 0X1c\nprint(\"0X1c trong Thập lục phân là\", x, type(x))\n```\n\nKhi bạn chạy mã này, nó sẽ tạo ra đầu ra sau:\n\n```\n0O34 trong bát phân là 28 <class 'int'>\n0X1c trong Thập lục phân là 28 <class 'int'>\n```\n\n**4. Kiểu Chữ Số Phẩy Động Python**\n\nMột số phẩy động bao gồm một phần nguyên và một phần thập phân. Theo quy ước, một ký tự dấu chấm thập phân (.) phân tách hai phần này trong biểu diễn hằng số của một số thực.\n\n**Ví dụ: Kiểu Chữ Số Phẩy Động**\n\n```python\nx = 25.55\ny = 0.05\nz = -12.2345\n```\n\nĐối với một số thực quá lớn hoặc quá nhỏ, trong đó số chữ số trước hoặc sau dấu thập phân là nhiều hơn, một biểu diễn khoa học được sử dụng cho biểu diễn hằng số ngắn gọn. Ký hiệu E hoặc e được theo sau bởi số nguyên dương hoặc số nguyên âm, đến sau phần nguyên.\n\n**Ví dụ: Kiểu Chữ Số Phẩy Động Biểu Diễn Khoa Học**\n\nVí dụ, số 1.23E05 tương đương với 123000.00. Tương tự, 1.23e-2 tương đương với 0.0123.\n\n```python\n# Sử dụng biểu diễn phẩy động thông thường\nx = 1.23\nprint(\"1.23 trong kiểu chữ số phẩy động thông thường là\", x, type(x))\n# Sử dụng biểu diễn khoa học\nx = 1.23E5\nprint(\"1.23E5 trong biểu diễn khoa học là\", x, type(x))\nx = 1.23E-2\nprint(\"1.23E-2 trong biểu diễn khoa học là\", x, type(x))\n```\n\nỞ đây, bạn sẽ nhận được đầu ra sau:\n\n```\n1.23 trong kiểu chữ số phẩy động thông thường là 1.23 <class 'float'>\n1.23E5 trong biểu diễn khoa học là 123000.0 <class 'float'>\n1.23E-2 trong biểu diễn khoa học là 0.0123 <class 'float'>\n```\n\n**5. Kiểu Chữ Số Phức Python**\n\nMột số phức bao gồm một phần thực và một phần ảo. Phần ảo là bất kỳ số nào (nguyên hoặc phẩy động) nhân với căn bậc hai của \"-1\" (√ −1). Trong biểu diễn hằng số, (−1−−−√\n) được biểu diễn bởi \"j\" hoặc \"J\". Do đó, một biểu diễn hằng số phức có dạng x+yj.\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Phức**\n\n```python\n# Sử dụng biểu diễn hằng số phức\nx = 2+3j\nprint(\"2+3j trong biểu diễn kiểu chữ số phức là\", x, type(x))\ny = 2.5+4.6j\nprint(\"2.5+4.6j trong biểu diễn kiểu chữ số phức là\", x, type(x))\n```\n\nMã này sẽ tạo ra đầu ra sau:\n\n```\n2+3j trong biểu diễn kiểu chữ số phức là (2+3j) <class 'complex'>\n2.5+4.6j trong biểu diễn kiểu chữ số phức là (2+3j) <class 'complex'>\n```\n\n**6. Kiểu Chữ Số Chuỗi Python**\n\nMột đối tượng chuỗi là một trong các loại dữ liệu dãy trong Python. Đó là một dãy không thể thay đổi của các điểm mã Unicode. Điểm mã là một số tương ứng với một ký tự theo tiêu chuẩn Unicode. Chuỗi là các đối tượng của lớp 'str' tích hợp sẵn của Python.\n\nChuỗi chữ số được viết bằng cách bao bọc một chuỗi các ký tự trong dấu nháy đơn ('hello'), dấu nháy kép (\"hello\") hoặc ba dấu nháy ('''hello''' hoặc \"\"\"hello\"\"\").\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Chuỗi**\n\n```python\nvar1 = 'hello'\nprint(\"'hello' trong dấu nháy đơn là:\", var1, type(var1))\nvar2 = \"hello\"\nprint('\"hello\" trong dấu nháy kép là:', var1, type(var1))\nvar3 = '''hello'''\nprint(\"'''hello''' trong ba dấu nháy là:\", var1, type(var1))\nvar4 = \"\"\"hello\"\"\"\nprint('\"\"\"hello\"\"\" trong ba dấu nháy là:', var1, type(var1))\n```\n\nỞ đây, bạn sẽ nhận được đầu ra sau:\n\n```\n'hello' trong dấu nháy đơn là: hello <class 'str'>\n\"hello\" trong dấu nháy kép là: hello <class 'str'>\n'''hello''' trong ba dấu nháy là: hello <class 'str'>\n\"\"\"hello\"\"\" trong ba dấu nháy là: hello <class 'str'>\n```\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Chuỗi Với Dấu Nháy Đôi Trong Chuỗi**\n\nNếu cần nhúng dấu nháy kép là một phần của chuỗi, chuỗi chính phải được đặt trong dấu nháy đơn. Ngược lại, nếu văn bản có dấu nháy đơn cần được nhúng, chuỗi phải được viết trong dấu nháy kép.\n\n```python\nvar1 = 'Welcome to \"Python Tutorial\" from 8 Sync Dev'\nprint(var1)\nvar2 = \"Welcome to 'Python Tutorial' from 8 Sync Dev\"\nprint(var2)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nWelcome to \"Python Tutorial\" from 8 Sync Dev\nWelcome to 'Python Tutorial' from 8 Sync Dev\n```\n\n**7. Kiểu Chữ Số Danh Sách Python**\n\nĐối tượng danh sách trong Python là một bộ sưu tập các đối tượng của các kiểu dữ liệu khác nhau. Danh sách là một bộ sưu tập được sắp xếp các mục không nhất thiết cùng loại. Các đối tượng cá nhân trong bộ sưu tập có thể được truy cập bằng chỉ số bắt đầu từ không.\n\nBiểu diễn hằng số của một đối tượng danh sách được thực hiện với một hoặc nhiều mục được phân tách bằng dấu phẩy và được bao bọc trong dấu ngoặc vuông [].\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Danh Sách**\n\n```python\nL1 = [1, \"Ravi\", 75.50, True]\nprint(L1, type(L1))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n[1, 'Ravi', 75.5, True] <class 'list'>\n```\n\n**8. Kiểu Chữ Số Tuple Python**\n\nĐối tượng tuple trong Python là một bộ sưu tập các đối tượng của các kiểu dữ liệu khác nhau. Tuple là một bộ sưu tập được sắp xếp các mục không nhất thiết cùng loại. Các đối tượng cá nhân trong bộ sưu tập có thể được truy cập bằng chỉ số bắt đầu từ không.\n\nBiểu diễn hằng số của một đối tượng tuple được thực hiện với một hoặc nhiều mục được phân tách bằng dấu phẩy và được bao bọc trong dấu ngoặc đơn ().\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Tuple**\n\n```python\nT1 = (1, \"Ravi\", 75.50, True)\nprint(T1, type(T1))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n(1, 'Ravi', 75.5, True) <class 'tuple'>\n```\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Tuple Không Có Dấu Ngoặc Đơn**\n\nDấu phân cách mặc định cho chuỗi Python là dấu ngoặc đơn, có nghĩa là một chuỗi phân tách bằng dấu phẩy mà không có dấu ngoặc đơn cũng tạo ra một tuple.\n\n```python\nT1 = 1, \"Ravi\", 75.50, True\nprint(T1, type(T1))\n```\n\nỞ đây, bạn cũng sẽ nhận được đầu ra:\n\n```\n(1, 'Ravi', 75.5, True) <class 'tuple'>\n```\n\n**9. Kiểu Chữ Số Từ Điển Python**\n\nGiống như danh sách hoặc tuple, từ điển cũng là một kiểu dữ liệu bộ sưu tập. Tuy nhiên, nó không phải là một chuỗi. Đó là một bộ sưu tập không có thứ tự của các mục, mỗi mục là một cặp khóa-giá trị. Giá trị được gán cho khóa bằng dấu \":\". Một hoặc nhiều cặp khóa:giá trị phân tách bằng dấu phẩy được đặt trong dấu ngoặc nhọn để tạo ra một đối tượng từ điển.\n\n**Ví dụ: Biểu Diễn Kiểu Chữ Số Từ Điển**\n\n```python\ncapitals = {\"USA\": \"New York\", \"France\": \"Paris\", \"Japan\": \"Tokyo\", \"India\": \"New Delhi\"}\nnumbers = {1: \"one\", 2: \"Two\", 3: \"three\", 4: \"four\"}\npoints = {\"p1\": (10, 10), \"p2\": (20, 20)}\n\nprint(capitals, type(capitals))\nprint(numbers, type(numbers))\nprint(points, type(points))\n```\n\nĐối tượng từ điển có thể sử dụng một đối tượng không thay đổi làm khóa. Số, chuỗi hoặc tuple có thể được sử dụng làm khóa. Một khóa không thể xuất hiện nhiều hơn một lần trong một bộ sưu tập. Nếu một khóa xuất hiện nhiều lần, chỉ có khóa cuối cùng được giữ lại. Giá trị có thể là bất kỳ kiểu dữ liệu nào. Một giá trị có thể được gán cho nhiều hơn một khóa. Ví dụ:\n\n```python\nstaff = {\"Krishna\": \"Officer\", \"Rajesh\": \"Manager\", \"Ragini\": \"officer\", \"Anil\": \"Clerk\", \"Kavita\": \"Manager\"}\n```\n\nHy vọng rằng những giải thích trên đã giúp bạn hiểu rõ về các loại kiểu chữ số trong Python. Nếu bạn có bất kỳ câu hỏi hoặc cần thêm thông tin, đừng ngần ngại hỏi!",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 16,
        "fields": {
            "name": "Bài 15. Python - Các Toán Tử",
            "content": "# Bài 15. Python - Các Toán Tử\n\n## Giới thiệu\nCác toán tử trong Python là những ký hiệu đặc biệt (đôi khi được gọi là từ khóa) được sử dụng để thực hiện các phép toán phổ biến trên một hoặc nhiều toán hạng (giá trị, biến hoặc biểu thức).\n\nPython hỗ trợ các loại toán tử sau:\n\n- Toán tử số học\n- Toán tử so sánh (tương đối)\n- Toán tử gán\n- Toán tử logic\n- Toán tử bitwise (bit)\n- Toán tử thành viên\n- Toán tử nhận diện\n\nChúng ta sẽ xem xét từng loại toán tử một.\n\n## Toán tử Số học Python\n\nToán tử số học được sử dụng để thực hiện các phép toán cơ bản như cộng, trừ, nhân, chia, vv.\n\nGiả sử biến `a` chứa giá trị 10 và biến `b` chứa giá trị 20, sau đó:\n\n| Toán tử | Tên             | Ví dụ           |\n| ------- | --------------- | --------------- |\n| +       | Cộng            | `a + b = 30`    |\n| -       | Trừ             | `a - b = -10`   |\n| *       | Nhân            | `a * b = 200`   |\n| /       | Chia            | `b / a = 2`     |\n| %       | Chia lấy dư     | `b % a = 0`     |\n| **      | Lũy thừa        | `a**b = 10**20` |\n| //      | Chia lấy nguyên | `9//2 = 4`      |\n\nVí dụ về Toán tử Số học Python:\n\n```python\na = 21\nb = 10\nc = 0\n\nc = a + b\nprint(\"a: {} b: {} a+b: {}\".format(a, b, c))\n\nc = a - b\nprint(\"a: {} b: {} a-b: {}\".format(a, b, c))\n\nc = a * b\nprint(\"a: {} b: {} a*b: {}\".format(a, b, c))\n\nc = a / b\nprint(\"a: {} b: {} a/b: {}\".format(a, b, c))\n\nc = a % b\nprint(\"a: {} b: {} a%b: {}\".format(a, b, c))\n\na = 2\nb = 3\nc = a**b \nprint(\"a: {} b: {} a**b: {}\".format(a, b, c))\n\na = 10\nb = 5\nc = a//b \nprint(\"a: {} b: {} a//b: {}\".format(a, b, c))\n```\n\nKết quả:\n\n```\na: 21 b: 10 a+b: 31\na: 21 b: 10 a-b: 11\na: 21 b: 10 a*b: 210\na: 21 b: 10 a/b: 2.1\na: 21 b: 10 a%b: 1\na: 2 b: 3 a**b: 8\na: 10 b: 5 a//b: 2\n```\n\n## Toán tử So sánh (Tương đối) Python\n\nToán tử so sánh so sánh các giá trị ở hai bên và quyết định mối quan hệ giữa chúng.\n\nGiả sử biến `a` chứa giá trị 10 và biến `b` chứa giá trị 20, sau đó:\n\n| Toán tử | Tên               | Ví dụ                 |\n| ------- | ----------------- | --------------------- |\n| ==      | Bằng              | `(a == b)` không đúng |\n| !=      | Không bằng        | `(a != b)` đúng       |\n| >       | Lớn hơn           | `(a > b)` không đúng  |\n| <       | Nhỏ hơn           | `(a < b)` đúng        |\n| >=      | Lớn hơn hoặc bằng | `(a >= b)` không đúng |\n| <=      | Nhỏ hơn hoặc bằng | `(a <= b)` đúng       |\n\nVí dụ về Toán tử So sánh Python:\n\n```python\na = 21\nb = 10\n\nif (a == b):\n   print(\"Dòng 1 - a bằng b\")\nelse:\n   print(\"Dòng 1 - a không bằng b\")\n\nif (a != b):\n   print(\"Dòng 2 - a không bằng b\")\nelse:\n   print(\"Dòng 2 - a bằng b\")\n\nif (a < b):\n   print(\"Dòng 3 - a nhỏ hơn b\")\nelse:\n   print(\"Dòng 3 - a không nhỏ hơn b\")\n\nif (a > b):\n   print(\"Dòng 4 - a lớn hơn b\")\nelse:\n   print(\"Dòng 4 - a không lớn hơn b\")\n\na, b = b, a  # Giá trị của a và b đã đổi. a trở thành 10, b trở thành 21\n\nif (a <= b):\n   print(\"Dòng 5 - a nhỏ hơn hoặc bằng b\")\nelse:\n   print(\"Dòng 5 - a không nhỏ hơn hoặc bằng b\")\n\nif (b >= a):\n   print(\"Dòng 6 - b lớn hơn hoặc bằng b\")\nelse:\n   print(\"Dòng 6 - b không lớn hơn hoặc bằng b\")\n```\n\nKết quả:\n\n```\nDòng 1 - a không bằng b\nDòng 2 - a không bằng b\nDòng 3 - a không nhỏ hơn b\nDòng 4 - a lớn hơn b\nDòng 5 - a nhỏ hơn hoặc bằng b\nDòng 6 - b lớn hơn hoặc bằng a\n```\n\n\n## Toán tử Gán Python\n\nToán tử gán được sử dụng để gán giá trị cho các biến. Bảng dưới đây liệt kê tất cả các toán tử gán trong Python:\n\n| Toán tử | Ví dụ     | Tương đương  |\n| ------- | --------- | ------------ |\n| =       | `a = 10`  | `a = 10`     |\n| +=      | `a += 30` | `a = a + 30` |\n| -=      | `a -= 15` | `a = a - 15` |\n| *=      | `a *= 10` | `a = a * 10` |\n| /=      | `a /= 5`  | `a = a / 5`  |\n| %=      | `a %= 5`  | `a = a % 5`  |\n| **=     | `a **= 4` | `a = a ** 4` |\n| //=     | `a //= 5` | `a = a // 5` |\n| &=      | `a &= 5`  | `a = a & 5`  |\n| \\|=     | `a \\|= 5` | `a = a \\| 5` |\n| ^=      | `a ^= 5`  | `a = a ^ 5`  |\n| >>=     | `a >>= 5` | `a = a >> 5` |\n| <<=     | `a <<= 5` | `a = a << 5` |\n\nVí dụ về Toán tử Gán Python:\n\n```python\na = 21\nb = 10\nc = 0\nprint(\"a: {} b: {} c : {}\".format(a, b, c))\n\nc = a + b\nprint(\"a: {}  c = a + b: {}\".format(a, c))\n\nc += a\nprint(\"a: {} c += a: {}\".format(a, c))\n\nc *= a\nprint(\"a: {} c *= a: {}\".format(a, c))\n\nc /= a\nprint(\"a: {} c /= a : {}\".format(a, c))\n\nc = 2\nprint(\"a: {} b: {} c : {}\".format(a, b, c))\nc %= a\nprint(\"a: {} c %= a: {}\".format(a, c))\n\nc **= a\nprint(\"a: {} c **= a: {}\".format(a, c))\n\nc //= a\nprint(\"a: {} c //= a: {}\".format(a, c))\n```\n\nKết quả:\n\n```\na: 21 b: 10 c : 0\na: 21  c = a + b: 31\na: 21 c += a: 52\na: 21 c *= a: 1092\na: 21 c /= a : 52.0\na: 21 b: 10 c : 2\na: 21 c %= a: 2\na: 21 c **= a: 2097152\na: 21 c //= a: 99864\n```\n\n## Toán tử Bitwise Python\n\nToán tử Bitwise hoạt động trên các bit và thực hiện các phép toán bit từng bit. Những toán tử này được sử dụng để so sánh các số nhị phân.\n\nPython hỗ trợ các toán tử Bitwise sau:\n\n| Toán tử | Tên       | Ví dụ    |\n| ------- | --------- | -------- |\n| &       | AND       | `a & b`  |\n| \\|      | OR        | `a \\| b` |\n| ^       | XOR       | `a ^ b`  |\n| ~       | NOT       | `~a`     |\n| <<      | Dịch trái | `a << 3` |\n| >>      | Dịch phải | `a >> 3` |\n\nVí dụ về Toán tử Bitwise Python:\n\n```python\na = 20            \nb = 10            \n\nprint('a =', a, ':', bin(a), 'b =', b, ':', bin(b))\nc = 0\n\nc = a & b        \nprint(\"Kết quả của AND là \", c, ':', bin(c))\n\nc = a | b     \nprint(\"Kết quả của OR là \", c, ':', bin(c))\n\nc = a ^ b        \nprint(\"Kết quả của XOR là \", c, ':', bin(c))\n\nc = ~a           \nprint(\"Kết quả của NOT là \", c, ':', bin(c))\n\nc = a << 2       \nprint(\"Kết quả của Dịch trái là \", c, ':', bin(c))\n\nc = a >> 2       \nprint(\"Kết quả của Dịch phải là \", c, ':', bin(c))\n```\n\nKết quả:\n\n```\na = 20 : 0b10100 b = 10 : 0b1010\nKết quả của AND là  0 : 0b0\nKết quả của OR là  30 : 0b11110\nKết quả của XOR là  30 : 0b11110\nKết quả của NOT là  -21 : -0b10101\nKết quả của Dịch trái là  80 : 0b1010000\nKết quả của Dịch phải là  5 : 0b101\n```\n\n## Toán tử Logic Python\n\nToán tử logic Python được sử dụng để kết hợp hai hoặc nhiều điều kiện và kiểm tra kết quả cuối cùng. Có ba toán tử logic sau được hỗ trợ bởi ngôn ngữ Python:\n\n| Toán tử | Tên | Ví dụ     |\n| ------- | --- | --------- |\n| and     | AND | `a and b` |\n| or      | OR  | `a or b`  |\n| not     | NOT | `not(a)`  |\n\nVí dụ về Toán tử Logic Python:\n\n```python\nvar = 5\n\nprint(var > 3 and var < 10)\nprint(var > 3 or var < 4)\nprint(not (var > 3 and var < 10))\n```\n\nKết quả:\n\n```\nTrue\nTrue\nFalse\n```\n\n## Toán tử Thành viên Python\n\nToán tử thành viên của Python kiểm tra sự tồn tại của một biến trong một chuỗi, như chuỗi, danh sách hoặc tuple. Có hai toán tử thành viên như sau:\n\n| Toán tử | Mô tả                                                                | Ví dụ        |\n| ------- | -------------------------------------------------------------------- | ------------ |\n| in      | Trả về True nếu nó tìm thấy một biến trong chuỗi được chỉ định       | `a in b`     |\n| not in  | Trả về True nếu nó không tìm thấy một biến trong chuỗi được chỉ định | `a not in b` |\n\nVí dụ về Toán tử Thành viên Python:\n\n```python\na = 10\nb = 20\nlist = [1, 2, 3, 4, 5]\n\nprint(\"a:\", a, \"b:\", b, \"list:\", list)\n\nif (a in list):\n   print(\"a có trong danh sách đã cho\")\nelse:\n   print(\"a không có trong danh sách đã cho\")\n\nif (b not in list):\n   print(\"b không có trong danh sách đã cho\")\nelse:\n   print(\"b có trong danh sách đã cho\")\n\nc = b / a\nprint(\"c:\", c, \"list:\", list)\n\nif (c in list):\n   print(\"c có trong danh sách đã cho\")\nelse:\n    print(\"c không có trong danh sách đã cho\")\n```\n\nKết quả:\n\n```\na: 10 b: 20 list: [1, 2, 3, 4, 5]\na không có trong danh sách đã cho\nb không có trong danh sách đã cho\nc có trong danh sách đã cho\n```\n\n## Toán tử Nhận diện Python\n\nToán tử nhận diện so sánh các vị trí bộ nhớ của hai đối tượng. Có hai toán tử nhận diện như sau:\n\n| Toán tử | Mô tả                                                        | Ví dụ        |\n| ------- | ------------------------------------------------------------ | ------------ |\n| is      | Trả về True nếu cả hai biến đều trỏ đến cùng một đối tượng   | `a is b`     |\n| is not  | Trả về True nếu cả hai biến không trỏ đến cùng một đối tượng | `a is not b` |\n\nVí dụ về Toán tử Nhận diện Python:\n\n```python\na = [1, 2, 3, 4, 5]\nb = [1, 2, 3, 4, 5]\nc = a\n\nprint(a is c)\nprint(a is b)\n\nprint(a is not c)\nprint(a is not b)\n```\n\nKết quả:\n\n```\nTrue\nFalse\nFalse\nTrue\n```\n\n## Ưu Tiên Toán Tử Python\n\nBảng dưới đây liệt kê tất cả các toán tử từ ưu tiên cao nhất đến thấp nhất.\n\n| STT | Toán tử                                    | Mô tả                                    |\n| --- | ------------------------------------------ | ---------------------------------------- |\n| 1   | **                                         | Lũy thừa                                 |\n| 2   | ~ + -                                      | Bù 1, dấu âm, dấu dương                  |\n| 3   | * / % //                                   | Nhân, chia, chia lấy dư, chia lấy nguyên |\n| 4   | + -                                        | Cộng, trừ                                |\n| 5   | >> <<                                      | Dịch trái, dịch phải                     |\n| 6   | &                                          | AND                                      |\n| 7   | ^ \\|                                       | XOR, OR                                  |\n| 8   | <= < > >=                                  | So sánh                                  |\n| 9   | == !=                                      | So sánh                                  |\n| 10  | = %= /= //= -= += *= **= <<= >>= &= \\|= ^= | Gán                                      |\n| 11  | is is not                                  | Nhận diện                                |\n| 12  | in not in                                  | Thành viên                               |\n| 13  | not or and                                 | Logic                                    |\n\nĐây là tài liệu về các toán tử trong Python. Hy vọng nó hữu ích cho bạn!\n\n--- \n\nTrên đây là tài liệu chi tiết về các toán tử trong Python, được viết bằng tiếng Việt với định dạng đẹp và tổ chức cấu trúc rõ ràng. Nếu bạn có bất kỳ câu hỏi nào, đừng ngần ngại để lại cho chúng tôi biết!",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 17,
        "fields": {
            "name": "Bài 16. Python - Các Toán Tử Số Học",
            "content": "# Bài 16. Python - Các Toán Tử Số Học\n\nTrong Python, các số là loại dữ liệu được sử dụng phổ biến nhất. Python sử dụng các ký hiệu giống như các phép toán số học cơ bản mà mọi người đều quen thuộc, tức là \"+\" cho phép cộng, \"-\" cho phép trừ, \"*\" cho phép nhân (hầu hết các ngôn ngữ lập trình sử dụng \"*\" thay vì \"x\" như được sử dụng trong toán học / đại số), và \"/\" cho phép chia (một lần nữa cho \"÷\" được sử dụng trong Toán học).\n\nNgoài ra, Python định nghĩa một số toán tử số học khác. Chúng là \"%\" (Phần dư), \"**\" (Lũy thừa) và \"//\" (Chia lấy phần nguyên).\n\n## Các Toán Tử Số Học Python\n\nCác toán tử số học là các toán tử nhị phân vì chúng hoạt động trên hai toán hạng. Python hỗ trợ hoàn toàn phép tính hỗn hợp. Đó là, hai toán hạng có thể thuộc hai loại số khác nhau. Trong tình huống như vậy, Python mở rộng toán hạng hẹp hơn. Một đối tượng số nguyên hẹp hơn một đối tượng số thực, và số thực hẹp hơn số phức. Do đó, kết quả của phép toán số học giữa số nguyên và số thực là một số thực. Kết quả của số thực và một số phức là một số phức, tương tự, phép tính trên một số nguyên và một đối tượng số phức sẽ cho kết quả là một đối tượng số phức.\n\n## Các Toán Tử Số Học Khác nhau trong Python\n\nDưới đây là bảng liệt kê tất cả các toán tử số học có sẵn trong Python:\n\n| Toán tử | Tên         | Ví dụ        |\n| ------- | ----------- | ------------ |\n| +       | Cộng        | a + b = 30   |\n| -       | Trừ         | a – b = -10  |\n| *       | Nhân        | a * b = 200  |\n| /       | Chia        | b / a = 2    |\n| %       | Phần dư     | b % a = 0    |\n| **      | Lũy thừa    | a**b =10**20 |\n| //      | Chia lấy dư | 9//2 = 4     |\n\nHãy cùng tìm hiểu các toán tử này thông qua các ví dụ.\n\n### Toán Tử Cộng (+)\n\nToán tử này được phát âm là \"cộng\", là một toán tử số học cơ bản. Nó cộng hai toán hạng số học ở hai bên và trả về kết quả cộng.\n\n#### Ví dụ: Cộng Hai Số Nguyên\n\nTrong ví dụ sau, hai biến số nguyên là các toán hạng cho toán tử \"+\".\n\n```python\na=10\nb=20\nprint (\"Tổng của hai số nguyên:\")\nprint (\"a =\",a,\"b =\",b,\"tổng =\",a+b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTổng của hai số nguyên\na = 10 b = 20 tổng = 30\n```\n\n#### Ví dụ: Cộng Số Nguyên và Số Thực\n\nCộng một số nguyên và một số thực sẽ cho kết quả là một số thực.\n\n```python\na=10\nb=20.5\nprint (\"Tổng của số nguyên và số thực\")\nprint (\"a =\",a,\"b =\",b,\"tổng =\",a+b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTổng của số nguyên và số thực\na = 10 b = 20.5 tổng = 30.5\n```\n\n#### Ví dụ: Cộng Hai Số Phức\n\nKết quả của việc thêm số thực vào số phức là một số phức.\n\n```python\na=10+5j\nb=20.5\nprint (\"Tổng của số phức và số thực\")\nprint (\"a=\",a,\"b=\",b,\"tổng=\",a+b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTổng của số phức và số thực\na= (10+5j) b= 20.5 tổng= (30.5+5j)\n```\n\n### Toán Tử Trừ (-)\n\nToán tử này, được biết đến như là \"trừ\", trừ toán hạng thứ hai khỏi toán hạng đầu tiên. Số kết quả là âm nếu toán hạng thứ hai lớn hơn.\n\n#### Ví dụ: Trừ Hai Số Nguyên\n\nVí dụ đầu tiên cho thấy sự trừ của hai số nguyên.\n\n```python\na=10\nb=20\nprint (\"Hiệu của hai số nguyên:\")\nprint (\"a =\",a,\"b =\",b,\"a-b =\",a-b)\nprint (\"a =\",a,\"b =\",b,\"b-a =\",b-a)\n```\n\nKết quả −\n\n```\nHiệu của hai số nguyên\na = 10 b = 20 a-b = -10\na = 10 b = 20 b-a = 10\n```\n\n#### Ví dụ: Trừ Số Nguyên và Số Thực\n\nPhép trừ của một số nguyên và một số thực tuân theo nguyên tắc tương tự.\n\n```python\na=10\nb=20.5\nprint (\"Hiệu của python số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a-b=\",a-b)\nprint (\"a=\",a,\"b=\",b,\"b-a=\",b-a)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nHiệu của số nguyên và số thực\na= 10 b= 20.5 a-b= -10.5\na= 10 b= 20.5 b-a= 10.5\n```\n\n#### Ví dụ: Trừ Hai Số Phức\n\nTrong phép trừ liên quan đến một số phức và một số thực, phần thực được sử dụng trong phép tính.\n\n```python\na=10+5j\nb=20.5\nprint (\"Hiệu của số phức và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a-b=\",a-b)\nprint (\"a=\",a,\"b=\",b,\"b-a=\",b-a)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nHiệu của số phức và số thực\na= (10+5j) b= 20.5 a-b= (-10.5+5j)\na= (10+5j) b= 20.5 b-a= (10.5-5j)\n```\n\n### Toán Tử Nhân (*)\n\nKý hiệu * (dấu hoa thị) được định nghĩa như một toán tử nhân trong Python (như trong nhiều ngôn ngữ). Nó trả về tích của hai toán hạng ở hai bên của nó. Nếu bất kỳ toán hạng nào là số âm, kết quả cũng là số âm. Nếu cả hai đều âm, kết quả là dương. Thay đổi thứ tự của các toán hạng không làm thay đổi kết quả.\n\n#### Ví dụ: Nhân Hai Số Nguyên\n\n```python\na=10\nb=20\nprint (\"Tích của hai số nguyên\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTích của hai số nguyên\na = 10 b = 20 a*b = 200\n```\n\n#### Ví dụ: Nhân Số Nguyên và Số Thực\n\nTrong phép nhân, một toán hạng số thực có thể có một biểu thức thập phân tiêu chuẩn, hoặc một biểu thức khoa học.\n\n```python\na=10\nb=20.5\nprint (\"Tích của số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a*b=\",a*b)\n\na=-5.55\nb=6.75E-3\nprint (\"Tích của số thực và số thực\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTích của số nguyên và số thực\na = 10 b = 20.5 a-b = -10.5\nTích của số thực và số thực\na = -5.55 b = 0.00675 a*b = -0.037462499999999996\n```\n\n#### Ví dụ: Nhân Với Số Phức\n\nĐối với phép nhân có một toán hạng số phức, toán hạng khác nhân cả phần thực và phần ảo.\n\n```python\na=10+5j\nb=20.5\nprint (\"Tích của số phức và số thực\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTích của số phức và số thực\na = (10+5j) b = 20.5 a*b = (205+102.5j)\n```\n\n### Toán Tử Chia (/)\n\nToán tử \"/\" (dấu gạch chéo) thường được gọi là gạch chéo phía trước. Kết quả của toán tử chia là tử số (toán hạng bên trái) chia cho mẫu số (toán hạng bên phải). Số kết quả là âm nếu bất kỳ toán hạng nào là số âm. Vì vô cùng không thể được lưu trữ trong bộ nhớ, Python ném ra lỗi ZeroDivisionError nếu mẫu số là 0. Kết quả của toán tử chia trong Python luôn là một số thực, ngay cả khi cả hai toán hạng đều là số nguyên.\n\n#### Ví dụ: Chia Hai Số Nguyên\n\n```python\na=10\nb=20\nprint (\"Chia của hai số nguyên\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\nprint (\"a=\",a,\"b=\",b,\"b/a=\",b/a)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nChia của hai số nguyên\na= 10 b= 20 a/b= 0.5\na= 10 b= 20 b/a= 2.0\n```\n\n#### Ví dụ: Chia Với Số Thực\n\nTrong phép chia, một toán hạng số thực có thể có một biểu thức thập phân tiêu chuẩn, hoặc một biểu thức khoa học.\n\n```python\na=10\nb=-20.5\nprint (\"Chia của số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\n\na=-2.50\nb=1.25E2\nprint (\"Chia của số thực và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nChia của số nguyên và số thực\na= 10 b= -20.5 a/b= -0.4878048780487805\nChia của số thực và số thực Số nguyên và số thực\n```python\na=10\nb=20.5\nprint (\"Hiệu của số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a-b=\",a-b)\nprint (\"a=\",a,\"b=\",b,\"b-a=\",b-a)\n```\nSẽ tạo ra đầu ra sau:\n\n```\nHiệu của số nguyên và số thực\na= 10 b= 20.5 a-b= -10.5\na= 10 b= 20.5 b-a= 10.5\n```\n\n#### Ví dụ: Trừ Hai Số Phức\n\nTrong phép trừ liên quan đến một số phức và một số thực, thành phần thực được sử dụng trong phép tính.\n\n```python\na=10+5j\nb=20.5\nprint (\"Hiệu của số phức và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a-b=\",a-b)\nprint (\"a=\",a,\"b=\",b,\"b-a=\",b-a)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nHiệu của số phức và số thực\na= (10+5j) b= 20.5 a-b= (-10.5+5j)\na= (10+5j) b= 20.5 b-a= (10.5-5j)\n```\n\n### Toán Tử Nhân (*)\n\nKý hiệu * (asterisk) được định nghĩa là toán tử nhân trong Python (như trong nhiều ngôn ngữ). Nó trả về tích của hai toán hạng ở hai bên. Nếu bất kỳ toán hạng nào là số âm, kết quả cũng là số âm. Nếu cả hai đều âm, kết quả là dương. Thay đổi thứ tự của các toán hạng không làm thay đổi kết quả.\n\n#### Ví dụ: Nhân Hai Số Nguyên\n\n```python\na=10\nb=20\nprint (\"Tích của hai số nguyên\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nTích của hai số nguyên\na = 10 b = 20 a*b = 200\n```\n\n#### Ví dụ: Nhân Số Nguyên và Số Thực\n\nTrong phép nhân, một toán hạng số thực có thể có một biểu diễn thập phân tiêu chuẩn hoặc một biểu diễn toán học.\n\n```python\na=10\nb=20.5\nprint (\"Tích của số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a*b=\",a*b)\n\na=-5.55\nb=6.75E-3\nprint (\"Tích của số thực và số thực\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nTích của số nguyên và số thực\na = 10 b = 20.5 a-b = -10.5\nTích của số thực và số thực\na = -5.55 b = 0.00675 a*b = -0.037462499999999996\n```\n\n#### Ví dụ: Nhân Với Số Phức\n\nĐối với phép nhân liên quan đến một toán hạng phức, toán hạng còn lại nhân cả phần thực và phần ảo.\n\n```python\na=10+5j\nb=20.5\nprint (\"Tích của số phức và số thực\")\nprint (\"a =\",a,\"b =\",b,\"a*b =\",a*b)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nTích của số phức và số thực\na = (10+5j) b = 20.5 a*b = (205+102.5j)\n```\n\n### Toán Tử Chia (/)\n\nDấu \"/\" thường được gọi là dấu gạch chéo. Kết quả của toán tử chia là tử số (toán hạng trái) chia cho mẫu số (toán hạng phải). Số kết quả là âm nếu bất kỳ toán hạng nào là số âm. Vì vô hạn không thể được lưu trữ trong bộ nhớ, Python ném ra ZeroDivisionError nếu mẫu số là 0. Kết quả của toán tử chia trong Python luôn là một số thực, ngay cả khi cả hai toán hạng đều là số nguyên.\n\n#### Ví dụ: Chia Hai Số Nguyên\n\n```python\na=10\nb=20\nprint (\"Chia của hai số nguyên\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\nprint (\"a=\",a,\"b=\",b,\"b/a=\",b/a)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nChia của hai số nguyên\na= 10 b= 20 a/b= 0.5\na= 10 b= 20 b/a= 2.0\n```\n\n#### Ví dụ: Chia Với Số Thực\n\nTrong phép chia, một toán hạng số thực có thể có một biểu diễn thập phân tiêu chuẩn hoặc một biểu diễn toán học.\n\n```python\na=10\nb=-20.5\nprint (\"Chia của số nguyên và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\na=-2.50\nb=1.25E2\nprint (\"Chia của số thực và số thực\")\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nChia của số nguyên và số thực\na= 10 b= -20.5 a/b= -0.4878048780487805\nChia của số thực và số thực\na= -2.50 b= 125.0 a/b= -0.02\n```\n\n#### Ví dụ: Chia Với Số Phức\n\nKhi một trong các toán hạng là một số phức, phép chia giữa toán hạng còn lại và cả hai phần của đối tượng số phức (phần thực và ảo) đều xảy ra.\n\n```python\na=7.5+7.5j\nb=2.5\nprint (\"Chia của số phức và số thực\")\nprint (\"a =\",a,\"b =\",b,\"a/b =\",a/b)\nprint (\"a =\",a,\"b =\",b,\"b/a =\",b/a)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\nChia của số phức và số thực\na = (7.5+7.5j) b = 2.5 a/b = (3+3j)\na = (7.5+7.5j) b = 2.5 b/a = (0.16666666666666666-0.16666666666666666j)\n```\n\nNếu tử số là 0, kết quả của phép chia luôn là 0 ngoại trừ khi mẫu số là 0, trong trường hợp này, Python ném ra ZeroDivisionError với thông báo lỗi Phép Chia Cho Không.\n\n```python\na=0\nb=2.5\nprint (\"a=\",a,\"b=\",b,\"a/b=\",a/b)\nprint (\"a=\",a,\"b=\",b,\"b/a=\",b/a)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\na= 0 b= 2.5 a/b= 0.0\nTraceback (most recent call last):\n  File \"C:\\Users\\mlath\\examples\\example.py\", line 20, in <module>\n     print (\"a=\",a,\"b=\",b,\"b/a=\",b/a)\n                                 ~^~\nZeroDivisionError: float division by zero\n```\n\n### Toán Tử Lấy Dư (%)\n\nPython định nghĩa ký hiệu \"%\" được gọi là ký hiệu Phần Trăm, là toán tử Lấy Dư (hoặc phần dư). Nó trả về phần dư sau khi mẫu số chia tử số. Nó cũng có thể được gọi là toán tử dư dư. Kết quả của toán tử lấy dư là số còn lại sau khi chia tỷ lệ nguyên. Ví dụ, khi 10 chia 3, tỷ lệ là 3 và phần dư là 1. Do đó, 10%3 (thường được phát âm là 10 mod 3) kết quả là 1.\n\n#### Ví dụ: Phép Lấy Dư Với Giá Trị Số Nguyên\n\nNếu cả hai toán hạng đều là số nguyên, giá trị phần dư là một số nguyên. Nếu tử số có thể chia hết, phần dư là 0. Nếu tử số nhỏ hơn mẫu số, phần dư bằng tử số. Nếu mẫu số là 0, Python ném ra ZeroDivisionError.\n\n```python\na=10\nb=2\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\na=10\nb=4\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\nprint (\"a=\",a, \"b=\",b, \"b%a=\", b%a)\na=0\nb=10\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\nprint (\"a=\", a, \"b=\", b, \"b%a=\",b%a)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\na= 10 b= 2 a%b= 0\na= 10 b= 4 a%b= 2\na= 10 b= 4 b%a= 4\na= 0 b= 10 a%b= 0\nTraceback (most recent call last):\n  File \"C:\\Users\\mlath\\examples\\example.py\", line 13, in <module>\n    print (\"a=\", a, \"b=\", b, \"b%a=\",b%a)\n                                    ~^~\nZeroDivisionError: integer modulo by zero\n```\n\n#### Ví dụ: Phép Lấy Dư Với Giá Trị Số Thực\n\nNếu một trong các toán hạng là một số thực, giá trị mod luôn là số thực.\n\n```python\na=10\nb=2.5\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\na=10\nb=1.5\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\na=7.7\nb=2.5\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\na=12.4\nb=3\nprint (\"a=\",a, \"b=\",b, \"a%b=\", a%b)\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\na= 10 b= 2.5 a%b= 0.0\na= 10 b= 1.5 a%b= 1.0\na= 7.7 b= 2.5 a%b= 0.20000000000000018\na= 12.4 b= 3 a%b= 0.40000000000000036\n```\n",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 18,
        "fields": {
            "name": "Bài 17. Python - Toán tử So sánh",
            "content": "# Bài 17. Python - Toán tử So sánh\n\nToán tử so sánh trong Python rất quan trọng trong các câu lệnh điều kiện của Python (if, else và elif) và các câu lệnh lặp (while và for loops). Các toán tử so sánh cũng được gọi là các toán tử quan hệ. Một số toán tử được biết đến là \"<\" đại diện cho toán tử nhỏ hơn, và \">\" đại diện cho toán tử lớn hơn.\n\nPython sử dụng thêm hai toán tử nữa, kết hợp \"=\" với hai toán tử này. Toán tử \"<=\" đại diện cho toán tử nhỏ hơn hoặc bằng và toán tử \">=\" đại diện cho toán tử lớn hơn hoặc bằng.\n\n\nCác Toán tử So sánh Khác nhau trong Python\n\nPython có thêm hai toán tử so sánh dưới dạng \"==\" và \"!=\". Chúng được sử dụng cho các toán tử bằng và khác. Do đó, có sáu toán tử so sánh trong Python và chúng được liệt kê dưới đây trong bảng này:\n\n- <\tÍt hơn\ta<b\n- >\tLớn hơn\ta>b\n- <=\tNhỏ hơn hoặc bằng\ta<=b\n- >=\tLớn hơn hoặc bằng\ta>=b\n- ==\tBằng\ta==b\n- !=\tKhông bằng\ta!=b\n\nCác toán tử so sánh là nhị phân theo tính chất, yêu cầu hai toán hạng. Một biểu thức liên quan đến một toán tử so sánh được gọi là biểu thức Boolean, và luôn trả về True hoặc False.\n\n**Ví dụ**\n```python\na = 5\nb = 7\nprint(a > b)\nprint(a < b)\n```\nKết quả sẽ là:\n\n```\nFalse\nTrue\n```\n\nCả hai toán hạng có thể là các biến, biểu thức hoặc các biểu thức Python. Vì Python hỗ trợ toán hạng kết hợp, bạn có thể có bất kỳ loại số học nào.\n\n**Ví dụ**\n```python\n# Cả hai toán hạng đều là số nguyên\na = 5\nb = 7\nprint(\"Cả hai toán hạng đều là số nguyên\")\nprint(\"a =\", a, \"b =\", b, \"a > b là\", a > b)\nprint(\"a =\", a, \"b =\", b, \"a < b là\", a < b)\n```\n\n**Python - Các Toán tử So sánh**\n\n**Toán tử So sánh trong Python**\n\nToán tử so sánh trong Python rất quan trọng trong các câu lệnh điều kiện của Python (if, else và elif) và các câu lệnh lặp (vòng lặp while và for). Các toán tử so sánh còn được gọi là các toán tử quan hệ. Một số toán tử nổi tiếng là \"<\" đại diện cho toán tử nhỏ hơn, và \">\" đại diện cho toán tử lớn hơn.\n\nPython sử dụng thêm hai toán tử nữa, kết hợp với dấu \"=\" với hai toán tử này. Dấu \"<=\" đại diện cho toán tử nhỏ hơn hoặc bằng và dấu \">=\" đại diện cho toán tử lớn hơn hoặc bằng.\n\n**Các Toán tử So sánh Khác nhau trong Python**\n\nPython có thêm hai toán tử so sánh dưới dạng \"==\" và \"!=\". Chúng được sử dụng cho các toán tử bằng và không bằng. Do đó, có sáu toán tử so sánh trong Python và chúng được liệt kê dưới đây trong bảng:\n\n- < \tSo sánh nhỏ hơn \ta < b\n- > \tSo sánh lớn hơn \ta > b\n- <= \tNhỏ hơn hoặc bằng \ta <= b\n- >= \tLớn hơn hoặc bằng \ta >= b\n- == \tBằng \ta == b\n- != \tKhông bằng \ta != b\n\nCác toán tử so sánh là nhị phân, yêu cầu hai toán hạng. Một biểu thức liên quan đến một toán tử so sánh được gọi là một biểu thức Boolean và luôn trả về True hoặc False.\n\n**Ví dụ**\n\n```python\na = 5\nb = 7\nprint(a > b)\nprint(a < b)\n```\n\nKết quả sẽ là:\n\n```\nFalse\nTrue\n```\n\nCả hai toán hạng có thể là các hằng số Python, biến hoặc biểu thức. Vì Python hỗ trợ phép tính kết hợp, bạn có thể có bất kỳ kiểu số nào.\n\n**Ví dụ**\n\nDưới đây là mã minh họa về việc sử dụng các toán tử so sánh của Python với các số nguyên:\n\n```python\nprint(\"Cả hai toán hạng đều là số nguyên\")\na = 5\nb = 7\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nCả hai toán hạng đều là số nguyên\na= 5 b= 7 a > b là False\na= 5 b= 7 a < b là True\na= 5 b= 7 a == b là False\na= 5 b= 7 a != b là True\n```\n\n**So sánh của Số thực**\n\nTrong ví dụ dưới đây, một toán hạng số nguyên và một toán hạng số thực được so sánh.\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của số nguyên và số thực\")\na = 10\nb = 10.0\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của số nguyên và số thực\na= 10 b= 10.0 a > b là False\na= 10 b= 10.0 a < b là False\na= 10 b= 10.0 a == b là True\na= 10 b= 10.0 a != b là False\n```\n\n**So sánh của Số phức**\n\nMặc dù đối tượng phức là một loại dữ liệu số trong Python, hành vi của nó khác biệt so với các loại dữ liệu khác. Python không hỗ trợ các toán tử < và >, tuy nhiên, nó hỗ trợ các toán tử bằng (==) và toán tử không bằng (!=).\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của số phức\")\na = 10 + 1j\nb = 10 - 1j\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của số phức\na= (10+1j) b= (10-1j) a == b là False\na= (10+1j) b= (10-1j) a != b là True\n```\n\nBạn sẽ nhận được một TypeError khi sử dụng các toán tử nhỏ hơn hoặc lớn hơn.\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của số phức\")\na = 10 + 1j\nb = 10 - 1j\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của số phức\nTraceback (most recent call last):\n  File \"C:\\Users\\mlath\\examples\\example.py\", line 5, in <module>\n    print(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nTypeError: '<' not supported between instances of 'complex' and 'complex'\n```\n\n**So sánh của Kiểu Boolean**\n\nCác đối tượng Boolean trong Python thực sự là số nguyên: True là 1 và False là 0. Trong thực tế, Python coi bất kỳ số khác không nào là True. Trong Python, việc so sánh các đối tượng Boolean là có thể. \"False < True\" là True!\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của Kiểu Boolean\")\na = True\nb = False\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của Kiểu Boolean\na= True b= False a < b là False\na= True b= False a > b là True\na= True b= False a == b là False\na= True b= False a != b là True\n```\n\n**So sánh của Các loại Dãy**\n\nTrong Python, chỉ có thể thực hiện so sánh của các đối tượng dãy tương tự. Một đối tượng chuỗi có thể so sánh với một chuỗi khác chỉ. Một danh sách không thể được so sánh với một tuple, ngay cả khi cả hai đều có các phần tử giống nhau.\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của các loại dãy khác nhau\")\na = (1, 2, 3)\nb = [1, 2, 3]\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của các loại dãy khác nhau\nTraceback (most recent call last):\n  File \"C:\\Users\\mlath\\examples\\example.py\", line 5, in <module>\n    print(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nTypeError: '<' not supported between instances of 'tuple' and 'list'\n```\n\nCác đối tượng dãy được so sánh bằng cơ chế sắp xếp từ điển. So sánh bắt đầu từ mục tại chỉ mục 0. Nếu chúng bằng nhau, so sánh di chuyển đến chỉ mục tiếp theo cho đến khi các mục tại một chỉ mục nhất định không bằng nhau hoặc một trong hai dãy đã hết. Nếu một dãy là một phần dãy con ban đầu của dãy kia, dãy ngắn hơn sẽ là dãy nhỏ hơn.\n\nSự khác biệt giữa hai toán hạng phụ thuộc vào sự khác biệt giữa các giá trị của các mục tại chỉ mục mà chúng không bằng nhau. Ví dụ, 'BAT' > 'BAR' là True, vì T đến sau R trong thứ tự Unicode.\n\nNếu tất cả các mục của hai dãy so sánh bằng nhau, các dãy được coi là bằng nhau.\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của chuỗi\")\na = 'BAT'\nb = 'BALL'\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của chuỗi\na= BAT b= BALL a < b là False\na= BAT b= BALL a > b là True\na= BAT b= BALL a == b là False\na= BAT b= BALL a != b là True\n```\n\nTrong ví dụ dưới đây, hai đối tượng tuple được so sánh:\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của các tuples\")\na = (1, 2, 4)\nb = (1, 2, 3)\nprint(\"a=\", a, \"b=\", b, \"a < b là\", a < b)\nprint(\"a=\", a, \"b=\", b, \"a > b là\", a > b)\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\na= (1, 2, 4) b= (1, 2, 3) a < b là False\na= (1, 2, 4) b= (1, 2, 3) a > b là True\na= (1, 2, 4) b= (1, 2,à 3) a==b là False\na= (1, 2, 4) b= (1, 2, 3) a != b là True\n```\n\n**So sánh của Các Đối tượng Từ điển**\n\nViệc sử dụng các toán tử \"<\" và \">\" cho từ điển của Python không được định nghĩa. Trong trường hợp của các toán hạng này, TypeError: '<' not supported between instances of 'dict' and 'dict' được báo cáo.\n\nSo sánh bằng kiểm tra xem độ dài của cả hai mục từ điển có giống nhau không. Độ dài của từ điển là số cặp khóa-giá trị trong đó.\n\nCác từ điển Python đơn giản chỉ được so sánh bằng độ dài. Từ điển có ít phần tử hơn được coi là nhỏ hơn một từ điển có nhiều phần tử.\n\n**Ví dụ**\n\n```python\nprint(\"So sánh của các đối tượng từ điển\")\na = {1: 1, 2: 2}\nb = {2: 2, 1: 1, 3: 3}\nprint(\"a=\", a, \"b=\", b, \"a == b là\", a == b)\nprint(\"a=\", a, \"b=\", b, \"a != b là\", a != b)\n```\n\nKết quả sẽ là:\n\n```\nSo sánh của các đối tượng từ điển\na= {1: 1, 2: 2} b= {2: 2, 1: 1, 3: 3} a==b là False\na= {1: 1, 2: 2} b= {2: 2, 1: 1, 3: 3} a!=b là True\n```\n\n",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 19,
        "fields": {
            "name": "Bài 18. Hướng dẫn sử dụng Toán tử Gán trong Python",
            "content": "# Bài 18. Hướng dẫn sử dụng Toán tử Gán trong Python\n\nToán tử = (bằng) được định nghĩa là toán tử gán trong Python. Giá trị của biểu thức Python ở bên phải của nó được gán cho một biến duy nhất ở bên trái. Toán tử = như trong lập trình nói chung (và Python cụ thể) không nên bị nhầm lẫn với việc sử dụng trong Toán học, nơi nó chỉ ra rằng các biểu thức ở cả hai bên của ký hiệu bằng nhau.\n\n## Ví dụ về Toán tử Gán trong Python\n\nXem xét các câu lệnh Python sau −\n\n```python\na = 10\nb = 5\na = a + b\nprint(a)\n```\n\nỞ lần gọi đầu tiên, ít nhất đối với một người mới vào lập trình nhưng biết toán học, câu lệnh \"a=a+b\" trông lạ lùng. Làm sao a có thể bằng \"a+b\"? Tuy nhiên, cần nhấn mạnh rằng ký hiệu = là một toán tử gán ở đây và không được sử dụng để chỉ sự bằng nhau của LHS và RHS.\n\nBởi vì nó là một phép gán, biểu thức bên phải được tính toán thành 15, giá trị được gán cho a.\n\nTrong câu lệnh \"a += b\", hai toán tử \"+\" và \"=\" có thể được kết hợp trong một toán tử \"+=\". Nó được gọi là toán tử cộng và gán. Trong một câu lệnh đơn, nó thực hiện phép cộng của hai toán hạng \"a\" và \"b\", và kết quả được gán cho toán hạng bên trái, tức là \"a\".\n\n## Toán tử Gán Tăng cường trong Python\n\nNgoài toán tử gán đơn giản, Python cung cấp thêm một số toán tử gán khác cho việc sử dụng nâng cao. Chúng được gọi là toán tử tích lũy hoặc tăng cường. Trong chương này, chúng ta sẽ tìm hiểu cách sử dụng các toán tử gán tăng cường được định nghĩa trong Python.\n\nPython có các toán tử gán tăng cường cho tất cả các toán tử số học và so sánh.\n\nCác toán tử gán tăng cường của Python kết hợp phép cộng và gán trong một câu lệnh. Vì Python hỗ trợ phép tính hỗn hợp, hai toán tử hạng có thể thuộc các loại khác nhau. Tuy nhiên, loại của toán tử trái sẽ thay đổi thành toán tử bên phải, nếu nó rộng hơn.\n\n## Ví dụ\n\nToán tử += là một toán tử tăng cường. Nó cũng được gọi là toán tử cộng tích lũy, vì nó thêm \"b\" vào \"a\" và gán kết quả trở lại một biến.\n\nDưới đây là các toán tử gán tăng cường trong Python:\n\n- Toán tử Tăng cường Cộng\n- Toán tử Tăng cường Trừ\n- Toán tử Tăng cường Nhân\n- Toán tử Tăng cường Chia\n- Toán tử Tăng cường Phần dư\n- Toán tử Tăng cường Số mũ\n- Toán tử Tăng cường Chia lấy phần nguyên\n\n## Toán tử Tăng cường Cộng (+=)\n\nCác ví dụ sau sẽ giúp bạn hiểu cách hoạt động của toán tử \"+=\" −\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường cộng của số nguyên và số nguyên\")\na += b  # tương đương với a = a + b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường cộng của số nguyên và số thực\")\na += b  # tương đương với a = a + b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10.50\nb = 5 + 6j\nprint(\"Tăng cường cộng của số thực và số phức\")\na += b  # tương đương với a = a + b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTăng cường cộng của số nguyên và số nguyên\na= 15 type(a): <class 'int'>\nTăng cường cộng của số nguyên và số thực\na= 15.5 type(a): <class 'float'>\nTăng cường cộng của số thực và số phức\na= (15.5+6j) type(a): <class 'complex'>\n```\n\n## Toán tử Tăng cường Trừ (-=)\n\nSử dụng ký hiệu -= để thực hiện phép trừ và gán trong một câu lệnh. Câu lệnh \"a -= b\" thực hiện phép gán \"a = a - b\". Các toán hạng có thể là bất kỳ kiểu số nào. Python thực hiện chuyển đổi kiểu ngầm định trên đối tượng có kích thước nhỏ hơn.\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường trừ của số nguyên và số nguyên\")\na -= b  # tương đương với a = a - b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường trừ của số nguyên và số thực\")\na -= b  # tương đương với a = a - b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10.50\nb = 5 + 6j\nprint(\"Tăng cường trừ của số thực và số phức\")\na -= b  # tương đương với a = a - b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường trừ của số nguyên và số nguyên\na= 5 type(a): <class 'int'>\nTăng cường trừ của số nguyên và số thực\na= 4.5 type(a): <class 'float'>\nTăng cường trừ của số thực và số phức\na= (5.5-6j) type(a): <class 'complex'>\n```\n\n## Toán tử Tăng cường Nhân (*=)\n\nToán tử \"*=\" hoạt động theo cùng một nguyên tắc. \"a *= b\" thực hiện phép nhân và gán, và tương đương với \"a = a * b\". Trong trường hợp nhân tăng cường của hai số phức, quy tắc nhân như đã thảo luận trong chương trước được áp dụng.\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường nhân của số nguyên và số nguyên\")\na *= b  # tương đương với a = a * b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường nhân của số nguyên và số thực\")\na *= b  # tương đương với a = a * b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 6 + 4j\nb = 3 + 2j\nprint(\"Tăng cường nhân của số phức và số phức\")\na *= b  # tương đương với a = a * b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường nhân của số nguyên và số nguyên\na= 50 type(a): <class 'int'>\nTăng cường nhân của số nguyên và số thực\na= 55.0 type(a): <class 'float'>\nTăng cường nhân của số phức và số phức\na= (10+24j) type(a): <class 'complex'>\n```\n\n## Toán tử Tăng cường Chia (/=)\n\nKý hiệu kết hợp \"/=\" hoạt động như một toán tử chia và gán, vì vậy \"a /= b\" tương đương với \"a = a / b\". Phép chia của toán hạng int hoặc float là float. Chia hai số phức trả về một số phức.\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường chia của số nguyên và số nguyên\")\na /= b  # tương đương với a = a / b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường chia của số nguyên và số thực\")\na /= b  # tương đương với a = a / b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 6 + 4j\nb = 3 + 2j\nprint(\"Tăng cường chia của số phức và số phức\")\na /= b  # tương đương với a = a / b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường chia của số nguyên và số nguyên\na= 2.0 type(a): <class 'float'>\nTăng cường chia của số nguyên và số thực\na= 1.8181818181818181 type(a): <class 'float'>\nTăng cường chia của số phức và số phức\na= (2+0j) type(a): <class 'complex'>\n```\n\n## Toán tử Tăng cường Phần dư (%=)\n\nĐể thực hiện phép chia lấy phần dư và gán trong một câu lệnh, sử dụng toán tử \"%=\". Như toán tử phần dư, phiên bản tăng cường của nó cũng không được hỗ trợ cho số phức.\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường phần dư của số nguyên và số nguyên\")\na %= b  # tương đương với a = a % b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường phần dư của số nguyên và số thực\")\na %= b  # tương đương với a = a % b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường phần dư của số nguyên và số nguyên\na= 0 type(a): <class 'int'>\nTăng cường phần dư của số nguyên và số thực\na= 4.5 type(a): <class 'float'>\n```\n\n## Toán tử Tăng cường Số mũ (**=)\n\nToán tử \"**=\" dẫn đến việc tính toán \"a\" lũy thừa \"b\", và gán giá trị trở lại \"a\". Dưới đây là một số ví dụ −\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường số mũ với số nguyên và số nguyên\")\na **= b  # tương đương với a = a ** b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường số mũ với số nguyên và số thực\")\na **= b  # tương đương với a = a ** b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 6 + 4j\nb = 3 + 2j\nprint(\"Tăng cường số mũ với số phức và số phức\")\na **= b  # tương đương với a = a ** b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường số mũ với số nguyên và số nguyên\na= 100000 type(a): <class 'int'>\nTăng cường số mũ với số nguyên và số thực\na= 316227.7660168379 type(a): <class 'float'>\nTăng cường số mũ với số phức và số phức\na= (97.52306038414744-62.22529992036203j) type(a): <class 'complex'>\n```\n\n## Toán tử Tăng cường Chia lấy phần nguyên (//=)\n\nĐối với phép chia lấy phần nguyên và gán trong một câu lệnh, sử dụng toán tử \"//=\". \"a //= b\" tương đương với \"a = a // b\". Toán tử này không thể sử dụng với số phức.\n\n```python\na = 10\nb = 5\nprint(\"Tăng cường chia lấy phần nguyên với số nguyên và số nguyên\")\na //= b  # tương đương với a = a // b\nprint(\"a =\", a, \"type(a):\", type(a))\n\na = 10\nb = 5.5\nprint(\"Tăng cường chia lấy phần nguyên với số nguyên và số thực\")\na //= b  # tương đương với a = a // b\nprint(\"a =\", a, \"type(a):\", type(a))\n```\n\nKết quả sẽ là:\n\n```\nTăng cường chia lấy phần nguyên với số nguyên và số nguyên\na= 2 type(a): <class 'int'>\nTăng cường chia lấy phần nguyên với số nguyên và số thực\na= 1.0 type(a): <class 'float'>\n```\n\n## Tổng Kết Nè\n\nTrên đây là các toán tử gán trong Python cùng với các toán tử tăng cường. Chúng giúp rút ngắn và làm cho mã nguồn trở nên rõ ràng hơn trong các tình huống mà bạn cần thực hiện một phép tính và gán giá trị lại cho biến.\n\nKhi sử dụng các toán tử này, hãy nhớ rằng chúng có thể giúp làm cho mã nguồn của bạn trở nên dễ đọc hơn và giảm thiểu việc lặp lại mã. Tuy nhiên, cũng cần chú ý để không làm cho mã của bạn trở nên quá phức tạp hoặc khó hiểu bằng cách sử dụng quá nhiều toán tử trong một câu lệnh.\n\nHy vọng rằng bạn đã hiểu rõ về cách sử dụng và ứng dụng các toán tử gán trong Python sau khi đọc qua tài liệu này. Nếu có bất kỳ câu hỏi nào, đừng ngần ngại đặt ra. Chúc bạn thành công trong việc sử dụng Python!",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 20,
        "fields": {
            "name": "Bài 19. Toán Tử Logic trong Python",
            "content": "# Bài 19. Toán Tử Logic trong Python\n\nToán tử logic trong Python được sử dụng để tạo ra các biểu thức logic phức tạp. Mỗi toán hạng cho các toán tử logic này chính là một biểu thức logic. Ví dụ:\n\n### Ví dụ\n```python\nage > 16 and marks > 80\npercentage < 50 or attendance < 75\n```\n\nCùng với từ khóa `False`, Python hiểu `None`, số không của tất cả các loại, và các chuỗi rỗng (chuỗi, tuple, list), từ điển rỗng và tập hợp rỗng là `False`. Tất cả các giá trị khác được coi là `True`.\n\nTrong Python, có ba toán tử logic. Chúng là \"and\", \"or\" và \"not\". Chúng phải ở dạng viết thường.\n\n## Toán Tử Logic \"and\"\n\nĐối với biểu thức logic phức tạp, cả hai toán hạng phải đều là `True` để biểu thức trở thành `True`. Nếu bất kỳ hoặc cả hai toán hạng đều đánh giá thành `False`, biểu thức trả về `False`.\n\n#### Bảng Chân Trị của Toán Tử Logic \"and\"\nBảng dưới đây hiển thị các trường hợp:\n\n| a   | b   | a and b |\n| --- | --- | ------- |\n| F   | F   | F       |\n| F   | T   | F       |\n| T   | F   | F       |\n| T   | T   | T       |\n\n## Toán Tử Logic \"or\"\n\nNgược lại, toán tử or trả về `True` nếu bất kỳ một trong các toán hạng là `True`. Đối với biểu thức logic phức tạp, cả hai toán hạng phải đều là `False` để biểu thức trở thành `False`.\n\n#### Bảng Chân Trị của Toán Tử Logic \"or\"\nBảng dưới đây hiển thị kết quả của toán tử \"or\" với các điều kiện khác nhau:\n\n| a   | b   | a or b |\n| --- | --- | ------ |\n| F   | F   | F      |\n| F   | T   | T      |\n| T   | F   | T      |\n| T   | T   | T      |\n\n## Toán Tử Logic \"not\"\n\nĐây là một toán tử một ngôi. Trạng thái của toán hạng logic theo sau sẽ được đảo ngược. Kết quả là, not True trở thành False và not False trở thành True.\n\n#### Bảng Chân Trị của Toán Tử Logic \"not\"\n| a   | not (a) |\n| --- | ------- |\n| F   | T       |\n| T   | F       |\n\n## Cách Trình Diễn Python Đánh Giá Các Toán Tử Logic?\n\nBiểu thức \"x and y\" đầu tiên đánh giá \"x\". Nếu \"x\" là `False`, giá trị của nó được trả về; nếu không, \"y\" được đánh giá và giá trị kết quả được trả về.\n\nBiểu thức \"x or y\" đầu tiên đánh giá \"x\"; nếu \"x\" là `True`, giá trị của nó được trả về; nếu không, \"y\" được đánh giá và giá trị kết quả được trả về.\n\n## Ví dụ về Toán Tử Logic Python\n\nDưới đây là một số trường hợp sử dụng của các toán tử logic:\n\n### Ví dụ 1: Các Toán Tử Logic Với Điều Kiện Boolean\n```python\nx = 10\ny = 20\nprint(\"x > 0 and x < 10:\",x > 0 and x < 10)\nprint(\"x > 0 and y > 10:\",x > 0 and y > 10)\nprint(\"x > 10 or y > 10:\",x > 10 or y > 10)\nprint(\"x%2 == 0 and y%2 == 0:\",x%2 == 0 and y%2 == 0)\nprint (\"not (x+y>15):\", not (x+y)>15)\n```\nKết quả sẽ là:\n\n```\nx > 0 and x < 10: False\nx > 0 and y > 10: True\nx > 10 or y > 10: True\nx%2 == 0 and y%2 == 0: True\nnot (x+y>15): False\n```\n\n### Ví dụ 2: Các Toán Tử Logic Với Điều Kiện Không Phải Boolean\nChúng ta có thể sử dụng các toán hạng không phải boolean với các toán tử logic. Ở đây, chúng ta cần nhớ rằng bất kỳ số khác không và các chuỗi không rỗng sẽ được đánh giá thành `True`. Do đó, các bảng chân trị của các toán tử logic cũng áp dụng.\n\nTrong ví dụ dưới đây, các toán hạng số được sử dụng cho các toán tử logic. Các biến \"x\", \"y\" được đánh giá thành `True`, \"z\" là `False`.\n\n```python\nx = 10\ny = 20\nz = 0\nprint(\"x and y:\",x and y)\nprint(\"x or y:\",x or y)\nprint(\"z or x:\",z or x)\nprint(\"y or z:\", y or z)\n```\nKết quả sẽ là:\n\n```\nx and y: 20\nx or y: 10\nz or x: 10\ny or z: 20\n```\n\n### Ví dụ 3: Các Toán Tử Logic Với Chuỗi và Tuple\nBiến chuỗi được coi là `True` và tuple rỗng là `False` trong ví dụ dưới đây.\n\n```python\na=\"Hello\"\nb=tuple()\nprint(\"a and b:\",a and b)\nprint(\"b or a:\",b or a)\n```\nKết quả sẽ là:\n\n```\na and b: ()\nb or a: Hello\n```\n\n### Ví dụ 4: Các Toán Tử Logic Để So Sánh Các Chuỗi (Danh Sách)\nCuối cùng, hai đối tượng danh sách dưới đây là không rỗng. Do đó, x and y trả về phần sau cùng, và x or y trả về phần đầu tiên.\n\n```python\nx=[1,2,3]\ny=[10,20,30]\nprint(\"x and y:\",x and y)\nprint(\"x or y:\",x or y)\n```\nKết quả sẽ là:\n\n```\nx and y: [10, 20, 30]\nx or y: [1, 2, 3]\n```\n\nCác ví dụ trên giúp bạn hiểu rõ về cách sử dụng và hoạt động của các toán tử logic trong Python. Hãy áp dụng chúng vào mã của bạn và tận dụng tính linh hoạt mà chúng mang lại!",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 21,
        "fields": {
            "name": "Bài 20. Python - Toán Tử Bitwise",
            "content": "# Bài 20. Python - Toán Tử Bitwise\n\nToán tử bitwise trong Python thường được sử dụng để thực hiện các phép toán bitwise trên các đối tượng kiểu số nguyên. Tuy nhiên, thay vì xem xét đối tượng như một thể, nó được xem xét như một chuỗi các bit. Các phép toán khác nhau được thực hiện trên từng bit trong chuỗi.\n\nPython có sáu toán tử bitwise - &, |, ^, ~, << và >>. Tất cả các toán tử này (ngoại trừ ~) đều là nhị phân, có nghĩa là chúng hoạt động trên hai toán hạng. Mỗi toán hạng là một chữ số nhị phân (bit) 1 hoặc 0.\n\nDưới đây là các toán tử bitwise trong Python:\n\n- Toán tử AND bitwise\n- Toán tử OR bitwise\n- Toán tử XOR bitwise\n- Toán tử NOT bitwise\n- Toán tử Dịch Trái bitwise\n- Toán tử Dịch Phải bitwise\n\n## Python Toán Tử AND Bitwise (&)\n\nToán tử AND bitwise có một số tương đồng với toán tử and logic. Nó chỉ trả về True nếu cả hai toán hạng bit đều là 1 (tức là True). Tất cả các kết hợp là −\n\n- 0 & 0 là 0\n- 1 & 0 là 0\n- 0 & 1 là 0\n- 1 & 1 là 1\n\nVí dụ về Toán Tử AND Bitwise trong Python:\n\n```python\na = 60\nb = 13\nprint (\"a:\", a, \"b:\", b, \"a & b:\", a & b)\n```\n\nKết quả sẽ là:\n\n```\na: 60 b: 13 a & b: 12\n```\n\nĐể hiểu cách Python thực hiện phép toán, lấy giá trị nhị phân tương ứng của mỗi biến.\n\n```python\nprint (\"a:\", bin(a))\nprint (\"b:\", bin(b))\n```\n\nSẽ tạo ra đầu ra sau:\n\n```\na: 0b111100\nb: 0b1101\n```\n\n## Python Toán Tử OR Bitwise (|)\n\nKý hiệu \"|\" (gọi là dấu pipe) là toán tử OR bitwise. Nếu bất kỳ bit toán hạng nào là 1, kết quả là 1, nếu không, là 0.\n\n- 0 | 0 là 0\n- 0 | 1 là 1\n- 1 | 0 là 1\n- 1 | 1 là 1\n\nVí dụ về Toán Tử OR Bitwise trong Python:\n\n```python\na = 60\nb = 13\nprint (\"a:\", a, \"b:\", b, \"a | b:\", a | b)\n```\n\nKết quả sẽ là:\n\n```\na: 60 b: 13 a | b: 61\n```\n\n## Python Toán Tử XOR Bitwise (^)\n\nThuật ngữ XOR đại diện cho OR độc quyền. Nó có nghĩa là kết quả của phép toán OR trên hai bit sẽ là 1 nếu chỉ có một trong hai bit là 1.\n\n- 0 ^ 0 là 0\n- 0 ^ 1 là 1\n- 1 ^ 0 là 1\n- 1 ^ 1 là 0\n\nVí dụ về Toán Tử XOR Bitwise trong Python:\n\n```python\na = 60\nb = 13\nprint (\"a:\", a, \"b:\", b, \"a ^ b:\", a ^ b)\n```\n\nKết quả sẽ là:\n\n```\na: 60 b: 13 a ^ b: 49\n```\n\nChúng ta hiện thực phép XOR bitwise theo cách thủ công.\n\n```python\n0011 1100\n    ^\n0000 1101\n-------------\n0011 0001\n```\n\nHàm int() sẽ cho kết quả 00110001 là 49.\n\n```python\nint('00110001',2)\n```\n\n## Python Toán Tử NOT Bitwise (~)\n\nToán tử này là tương đương nhị phân của toán tử NOT logic. Nó đảo ngược từng bit để 1 được thay thế bằng 0 và ngược lại, và trả về bù của số ban đầu. Python sử dụng phương pháp của 2. Đối với số nguyên dương, nó được thu được đơn giản bằng cách đảo ngược các bit. Đối với số âm, -x, nó được viết bằng biểu diễn bit cho (x-1) với tất cả các bit đảo ngược (chuyển từ 1 thành 0 hoặc từ 0 thành 1).\n\nVí dụ về Toán Tử NOT Bitwise trong Python:\n\n```python\na = 60\nprint (\"a:\", a, \"~a:\", ~a)\n```\n\nKết quả sẽ là:\n\n```\na: 60 ~a: -61\n```\n\n## Python Toán Tử Dịch Trái Bitwise (<<)\n\nToán tử dịch trái dịch các bit có ý nghĩa nhất sang phải bởi số nằm bên phải của ký hiệu \"<<\" . Vì vậy, \"x << 2\" làm cho hai bit của biểu diễn nhị phân của x bị dịch sang phải.\n\nVí dụ về Toán Tử Dịch Trái Bitwise trong Python:\n\n```python\na = 60\nprint (\"a:\", a, \"a << 2:\", a << 2)\n```\n\nKết quả sẽ là:\n\n```\na: 60 a << 2: 240\n```\n\n## Python Toán Tử Dịch Phải Bitwise (>>)\n\nToán tử dịch phải dịch các bit có ý nghĩa nhỏ nhất sang trái bởi số nằm bên phải của ký hiể \">>\". Do đó, \"x >> 2\" làm cho hai bit của biểu diễn nhị phân của x bị dịch sang trái.\n\nVí dụ về Toán Tử Dịch Phải Bitwise trong Python:\n\n```python\na = 60\nprint (\"a:\", a, \"a >> 2:\", a >> 2)\n```\n\nKết quả sẽ là:\n\n```\na: 60 a >> 2: 15\n```\n\nHoạt động dịch phải thủ công trên 60 được thể hiện dưới đây:\n\n```plaintext\n   0011 1100\n   >>\n   2\n   -------------\n   0000 1111\n```\n\nSử dụng hàm int() để chuyển đổi số nhị phân trên thành số nguyên. Đó là 15.\n\n```python\nint('00001111',2)\n```\n\nĐây là hướng dẫn về các toán tử bitwise trong Python. Đây là một phần quan trọng của ngôn ngữ lập trình Python, đặc biệt hữu ích khi làm việc với các phép toán bitwise trên các số nguyên.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 22,
        "fields": {
            "name": "Bài 21. Toán tử thành viên trong Python",
            "content": "# Bài 21. Toán tử thành viên trong Python\n\nToán tử thành viên trong Python giúp chúng ta xác định xem một phần tử có xuất hiện trong một đối tượng kiểu container cho trước hay không, hoặc nói cách khác, xem một phần tử có là thành viên của đối tượng kiểu container cho trước không.\n\n## Loại Toán Tử Thành Viên Python\n\nPython có hai toán tử thành viên: in và not in. Cả hai đều trả về kết quả là Boolean. Kết quả của toán tử in là ngược lại với toán tử not in.\n\n### Toán tử 'in'\n\nToán tử \"in\" được sử dụng để kiểm tra xem một chuỗi con có hiện diện trong một chuỗi lớn hơn, bất kỳ phần tử nào có hiện diện trong một danh sách hoặc tuple, hoặc một danh sách con hoặc tuple con được bao gồm trong một danh sách hoặc tuple.\n\n#### Ví dụ về Toán Tử \"in\" trong Python\n\n```python\nvar = \"8 Sync Dev\"\na = \"P\"\nb = \"tor\"\nc = \"in\"\nd = \"To\"\nprint (a, \"in\", var, \":\", a in var)\nprint (b, \"in\", var, \":\", b in var)\nprint (c, \"in\", var, \":\", c in var)\nprint (d, \"in\", var, \":\", d in var)\n```\n\nKết quả sẽ là:\n\n```\nP in 8 Sync Dev : True\ntor in 8 Sync Dev : True\nin in 8 Sync Dev : True\nTo in 8 Sync Dev : False\n```\n\n### Toán tử 'not in'\n\nToán tử \"not in\" được sử dụng để kiểm tra xem một chuỗi với giá trị cho trước không hiện diện trong đối tượng như chuỗi, danh sách, tuple, v.v.\n\n#### Ví dụ về Toán Tử \"not in\" trong Python\n\n```python\nvar = \"8 Sync Dev\"\na = \"P\"\nb = \"tor\"\nc = \"in\"\nd = \"To\"\nprint (a, \"not in\", var, \":\", a not in var)\nprint (b, \"not in\", var, \":\", b not in var)\nprint (c, \"not in\", var, \":\", c not in var)\nprint (d, \"not in\", var, \":\", d not in var)\n```\n\nKết quả sẽ là:\n\n```\nP not in 8 Sync Dev : False\ntor not in 8 Sync Dev : False\nin not in 8 Sync Dev : False\nTo not in 8 Sync Dev : True\n```\n\n## Toán Tử Thành Viên với Danh sách và Tuple\n\nBạn có thể sử dụng toán tử \"in/not in\" để kiểm tra sự hiện diện của một phần tử trong danh sách hoặc tuple.\n\n```python\nvar = [10,20,30,40]\na = 20\nb = 10\nc = a-b\nd = a/2\nprint (a, \"in\", var, \":\", a in var)\nprint (b, \"not in\", var, \":\", b not in var)\nprint (c, \"in\", var, \":\", c in var)\nprint (d, \"not in\", var, \":\", d not in var)\n```\n\nKết quả sẽ là:\n\n```\n20 in [10, 20, 30, 40] : True\n10 not in [10, 20, 30, 40] : False\n10 in [10, 20, 30, 40] : True\n10.0 not in [10, 20, 30, 40] : False\n```\n\nTrong trường hợp cuối cùng, \"d\" là một số thực nhưng vẫn so sánh với True với 10 (một số nguyên) trong danh sách. Ngay cả khi một số được biểu diễn dưới các định dạng khác nhau như nhị phân, bát phân hoặc thập lục phân được cung cấp, các toán tử thành viên vẫn cho biết liệu nó có trong chuỗi hay không.\n\n## Ví dụ\n\nTuy nhiên, nếu bạn thử kiểm tra xem hai số kế tiếp có xuất hiện trong một danh sách hoặc tuple không, toán tử in sẽ trả về False. Nếu danh sách/tuple chứa các số kế tiếp như một chuỗi chính nó, thì nó sẽ trả về True.\n\n```python\nvar = (10,20,30,40)\na = 10\nb = 20\nprint ((a,b), \"in\", var, \":\", (a,b) in var)\nvar = ((10,20),30,40)\na = 10\nb = 20\nprint ((a,b), \"in\", var, \":\", (a,b) in var)\n```\n\nKết quả sẽ là:\n\n```\n(10, 20) in (10, 20, 30, 40) : False\n(10, 20) in ((10, 20), 30, 40) : True\n```\n\n## Toán Tử Thành Viên với Tập Hợp\n\nToán tử thành viên của Python cũng hoạt động tốt với các đối tượng tập hợp.\n\n```python\nvar = {10,20,30,40}\na = 10\nb = 20\nprint (b, \"in\", var, \":\", b in var)\nvar = {(10,20),30,40}\na = 10\nb = 20\nprint ((a,b), \"in\", var, \":\", (a,b) in var)\n```\n\nKết quả sẽ là:\n\n```\n20 in {40, 10, 20, 30} : True\n(10, 20) in {40, 30, (10, 20)} : True\n```\n\n## Toán Tử Thành Viên với Từ Điển\n\nSử dụng các toán tử in cũng như not in với đối tượng từ điển là được cho phép. Tuy nhiên, Python chỉ kiểm tra sự thành viên với tập hhợp của các khóa và không phải giá trị.\n\n```python\nvar = {1:10, 2:20, 3:30}\na = 2\nb = 20\nprint (a, \"in\", var, \":\", a in var)\nprint (b, \"in\", var, \":\", b in var)\n```\n\nKết quả sẽ là:\n\n```\n2 in {1: 10, 2: 20, 3: 30} : True\n20 in {1: 10, 2: 20, 3: 30} : False\n```\n\nĐó là một bản dịch chi tiết và rõ ràng về toán tử thành viên trong Python. Hy vọng nó giúp bạn hiểu rõ về cách sử dụng các toán tử này trong các tình huống khác nhau.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 23,
        "fields": {
            "name": "Bài 22. Python - Toán Tử Nhận Dạng",
            "content": "# Bài 22. Python - Toán Tử Nhận Dạng\n\nToán tử nhận dạng trong Python so sánh các đối tượng để xác định liệu chúng có chia sẻ cùng một bộ nhớ và tham chiếu đến cùng một loại đối tượng (kiểu dữ liệu) hay không.\n\n### Toán Tử 'is'\n\nToán tử 'is' trả về True nếu cả hai đối tượng của toán hạng chia sẻ cùng một vị trí bộ nhớ. Vị trí bộ nhớ của đối tượng có thể được lấy thông qua hàm \"id()\". Nếu \"id()\" của cả hai biến giống nhau, toán tử \"is\" trả về True.\n\n#### Ví dụ về Toán Tử 'is'\n\n```python\na = [1, 2, 3, 4, 5]\nb = [1, 2, 3, 4, 5]\nc = a\n\n# So sánh và in giá trị trả về\nprint(a is c)\nprint(a is b)\n\n# In các ID của a, b, và c\nprint(\"id(a) : \", id(a))\nprint(\"id(b) : \", id(b))\nprint(\"id(c) : \", id(c))\n```\n\nKết quả sẽ là:\n\n```\nTrue\nFalse\nid(a) :  140114091859456\nid(b) :  140114091906944\nid(c) :  140114091859456\n```\n\n### Toán Tử 'is not'\n\nToán tử 'is not' trả về True nếu cả hai đối tượng của toán hạng không chia sẻ cùng một vị trí bộ nhớ hoặc cả hai toán hạng không phải là cùng một đối tượng.\n\n#### Ví dụ về Toán Tử 'is not'\n\n```python\na = [1, 2, 3, 4, 5]\nb = [1, 2, 3, 4, 5]\nc = a\n\n# So sánh và in giá trị trả về\nprint(a is not c)\nprint(a is not b)\n\n# In các ID của a, b, và c\nprint(\"id(a) : \", id(a))\nprint(\"id(b) : \", id(b))\nprint(\"id(c) : \", id(c))\n```\n\nKết quả sẽ là:\n\n```\nFalse\nTrue\nid(a) :  140559927442176\nid(b) :  140559925598080\nid(c) :  140559927442176\n```\n\n### Ví dụ với Giải Thích\n\n#### Ví dụ 1\n\n```python\na=\"8 Sync Dev\"\nb=a\nprint (\"id(a), id(b):\", id(a), id(b))\nprint (\"a is b:\", a is b)\nprint (\"b is not a:\", b is not a)\n```\n\nKết quả sẽ là:\n\n```\nid(a), id(b): 2739311598832 2739311598832\na is b: True\nb is not a: False\n```\n\nTrong trường hợp các đối tượng là các danh sách và bộ dữ liệu, chúng có cách hoạt động khác nhau, điều này có thể nhìn lạ trong trường hợp đầu tiên. Trong ví dụ dưới đây, hai danh sách \"a\" và \"b\" chứa các mục giống nhau. Nhưng id() của chúng khác nhau.\n\n#### Ví dụ 2\n\n```python\na=[1,2,3]\nb=[1,2,3]\nprint (\"id(a), id(b):\", id(a), id(b))\nprint (\"a is b:\", a is b)\nprint (\"b is not a:\", b is not a)\n```\n\nKết quả sẽ là:\n\n```\nid(a), id(b): 1552612704640 1552567805568\na is b: False\nb is not a: True\n```\n\nCác đối tượng danh sách hoặc bộ dữ liệu chỉ chứa các vị trí bộ nhớ của các mục riêng lẻ và không phải là các mục đó. Do đó, \"a\" chứa các địa chỉ của các đối tượng số nguyên 10, 20 và 30 ở một vị trí nhất định có thể khác nhau so với \"b\".\n\n#### Ví dụ 3\n\n```python\nprint (id(a[0]), id(a[1]), id(a[2]))\nprint (id(b[0]), id(b[1]), id(b[2]))\n```\n\nKết quả sẽ là:\n\n```\n140734682034984 140734682035016 140734682035048\n140734682034984 140734682035016 140734682035048\n```\n\nVì vị trí khác biệt của \"a\" và \"b\", toán tử \"is\" trả về False ngay cả khi hai danh sách chứa cùng các số giống nhau.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 24,
        "fields": {
            "name": "Bài 23. Python - Ưu Tiên Toán Tử",
            "content": "# Bài 23. Python - Ưu Tiên Toán Tử\n\nTrong Python, một biểu thức bao gồm một hoặc nhiều biến, hằng số và toán tử (toán tử số học, logic, bitwise, v.v.). Trình thông dịch Python đánh giá biểu thức và kết quả được gán cho một biến hoặc được sử dụng trong một câu lệnh khác. Trình thông dịch thực hiện các hoạt động khác nhau tùy thuộc vào ưu tiên của các toán tử.\n\n## Ưu Tiên Toán Tử Python\n\nMột biểu thức có thể chứa nhiều toán tử được đánh giá. Ưu tiên toán tử xác định thứ tự mà các toán tử được đánh giá. Nói cách khác, thứ tự đánh giá toán tử được xác định bởi ưu tiên toán tử.\n\nNếu một biểu thức cụ thể chứa nhiều toán tử, thứ tự đánh giá của chúng được xác định bởi thứ tự ưu tiên. Ví dụ, xem xét biểu thức sau:\n\n```\n>>> a = 2+3*5\n```\n\nỞ đây, giá trị của a sẽ là gì? - có thể là 17 (nhân 3 với 5 trước và sau đó cộng 2) hoặc 25 (cộng 2 và 3 và sau đó nhân với 5)? Nguyên tắc ưu tiên toán tử của Python xuất hiện ở đây.\n\nNếu chúng ta chỉ xem xét các toán tử số học trong Python, nguyên tắc BODMAS truyền thống cũng được sử dụng bởi trình thông dịch Python, trong đó dấu ngoặc được đánh giá trước, các toán tử chia và nhân tiếp theo, tiếp theo là cộng và trừ. Do đó, a sẽ trở thành 17 trong biểu thức trên.\n\nNgoài ưu tiên toán tử, tính kết hợp của các toán tử cũng quan trọng. Nếu một biểu thức bao gồm các toán tử có cùng mức ưu tiên, tính kết hợp xác định thứ tự. Hầu hết các toán tử có tính kết hợp từ trái sang phải. Điều đó có nghĩa là toán tử ở bên trái được đánh giá trước toán tử ở bên phải.\n\nHãy xem xét một biểu thức khác:\n\n```\n>>> b = 10/5*4\n```\n\nTrong trường hợp này, cả * (nhân) và / (chia) đều có cùng mức ưu tiên. Tuy nhiên, nguyên tắc tính kết hợp từ trái sang phải thực hiện phép chia trước (10/5 = 2) và sau đó phép nhân (2*4 = 8).\n\n## Bảng Ưu Tiên Toán Tử Python\n\nBảng sau liệt kê tất cả các toán tử trong Python theo thứ tự giảm dần của ưu tiên. Các toán tử trong cùng một ô dưới cột Toán Tử có cùng ưu tiên.\n\n| Sr.No. | Toán Tử & Mô Tả                              |\n| ------ | -------------------------------------------- |\n| 1      | (),[], {}                                    |\n| 2      | [index], [index:index]                       |\n| 3      | await x                                      |\n| 4      | **                                           |\n| 5      | +x, -x, ~x                                   |\n| 6      | *, @, /, //, %                               |\n| 7      | +, -                                         |\n| 8      | <<, >>                                       |\n| 9      | &                                            |\n| 10     | ^                                            |\n| 11     | \\|                                           |\n| 12     | in, not in, is, is not, <, <=, >, >=, !=, == |\n| 13     | not x                                        |\n| 14     | and                                          |\n| 15     | or                                           |\n| 16     | if – else                                    |\n| 17     | lambda                                       |\n| 18     | :=                                           |\n\n## Ví dụ về Ưu Tiên Toán Tử Python\n\n```python\na = 20\nb = 10\nc = 15\nd = 5\ne = 0\n\ne = (a + b) * c / d       #( 30 * 15 ) / 5\nprint (\"Giá trị của (a + b) * c / d là \",  e)\n\ne = ((a + b) * c) / d     # (30 * 15 ) / 5\nprint (\"Giá trị của ((a + b) * c) / d là \",  e)\n\ne = (a + b) * (c / d);    # (30) * (15/5)\nprint (\"Giá trị của (a + b) * (c / d) là \",  e)\n\ne = a + (b * c) / d;      #  20 + (150/5)\nprint (\"Giá trị của a + (b * c) / d là \",  e)\n```\n\nKhi bạn thực thi chương trình trên, nó sẽ cho ra kết quả sau:\n\n```\nGiá trị của (a + b) * c / d là  90.0\nGiá trị của ((a + b) * c) / d là  90.0\nGiá trị của (a + b) * (c / d) là  90.0\nGiá trị của a + (b * c) / d là  50.0\n```\n\nTrong các ví dụ này:\n\n- Biểu thức thứ nhất `e = (a + b) * c / d` tính toán phép nhân trước `(a + b)` và sau đó chia cho `d`.\n- Biểu thức thứ hai `e = ((a + b) * c) / d` sử dụng ngoặc để chỉ định thứ tự đánh giá, cũng cho ra kết quả như biểu thức đầu tiên.\n- Biểu thức thứ ba `e = (a + b) * (c / d)` sử dụng ngoặc để chỉ định thứ tự đánh giá, và kết quả cũng giống như hai biểu thức trước đó.\n- Biểu thức cuối cùng `e = a + (b * c) / d` thực hiện phép nhân trước `(b * c)` và sau đó chia cho `d`.\n\nNhư bạn có thể thấy, việc hiểu và sử dụng đúng ưu tiên toán tử là rất quan trọng để đảm bảo tính chính xác của các biểu thức trong Python.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 25,
        "fields": {
            "name": "Bài 24. Python - Chú thích",
            "content": "# Bài 24. Python - Chú thích\n\n## Giới thiệu về Chú thích trong Python\n\nChú thích trong một chương trình máy tính là một phần văn bản được đặt ra để giải thích hoặc mô tả trong mã nguồn và không được xem xét bởi trình biên dịch/trình thông dịch khi tạo mã ngôn ngữ máy. Việc sử dụng chú thích một cách phong phú trong chương trình nguồn giúp mọi người hiểu rõ hơn về cú pháp, cách sử dụng và logic của thuật toán vv., miễn là nó được chú thích một cách đẹp mắt.\n\n## Chú thích trong Python\n\nChú thích trong Python giúp mã nguồn trở nên dễ hiểu hơn và chúng hoàn toàn bị bỏ qua bởi trình thông dịch, điều này có nghĩa là bạn có thể cung cấp bất kỳ số lượng chú thích nào bạn muốn trong chương trình của mình để làm cho nó trở nên dễ đọc và giải thích hơn.\n\nPython hỗ trợ hai loại chú thích:\n\n### Chú thích trên một dòng\n\nTrong một kịch bản Python, ký hiệu # đánh dấu sự bắt đầu của dòng chú thích. Nó có hiệu quả cho đến cuối dòng trong trình soạn thảo. Nếu # là ký tự đầu tiên của dòng, toàn bộ dòng sẽ được coi là một chú thích và trình thông dịch sẽ bỏ qua nó.\n\n**Ví dụ về Chú thích trên Một Dòng trong Python:**\n\n```python\n# Đây là một chú thích\nprint(\"Xin chào thế giới\")\n\n# Nếu # được sử dụng ở giữa một dòng, văn bản trước nó là một biểu thức Python hợp lệ, trong khi văn bản sau nó được coi là chú thích.\n\nprint(\"Bạn khỏe không?\")  # Đây cũng là một chú thích nhưng sau một câu lệnh.\n```\n\n### Chú thích trên Nhiều Dòng\n\nTrong Python, không có quy định để viết chú thích trên nhiều dòng, hoặc một chú thích dạng khối. (Như trong C/C++, nơi nhiều dòng bên trong /* .. */ được xem là chú thích trên nhiều dòng).\n\nMỗi dòng nên có ký tự # ở đầu để được đánh dấu là chú thích trong Python và đó là cách bạn có thể tạo chú thích trên nhiều dòng trong Python.\n\n**Ví dụ về Chú thích trên Nhiều Dòng trong Python:**\n\n```python\n#\n# Đây là một chú thích trên nhiều dòng\n# có thể trải dài qua nhiều dòng.\n#\nprint(\"Xin chào thế giới\")\n\n\"\"\"\nĐây là một chú thích trên nhiều dòng\ncó thể trải dài qua nhiều dòng.\n\"\"\"\nprint(\"Xin chào thế giới\")\n```\n\n### Chú thích với Docstring\n\nDocstring Python cung cấp một cách thuận tiện để cung cấp tài liệu trợ giúp với các module Python, hàm, lớp và phương thức. Docstring sau đó sẽ được truy cập thông qua thuộc tính __doc__.\n\n**Ví dụ về Chú thích với Docstring trong Python:**\n\n```python\ndef add(a, b):\n    \"\"\"Hàm để cộng giá trị của a và b\"\"\"\n    return a + b\n\nprint(add.__doc__)\n```\n\nKết quả sẽ là:\n\n```\nHàm để cộng giá trị của a và b\n```\n\nViệc sử dụng chú thích trong Python giúp mã nguồn trở nên dễ hiểu hơn và chúng hoàn toàn được bỏ qua bởi trình thông dịch. Điều này có nghĩa là bạn có thể cung cấp bất kỳ số lượng chú thích nào bạn muốn trong chương trình của mình để làm cho nó dễ đọc và rõ ràng hơn.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 26,
        "fields": {
            "name": "Bài 25. Python - Nhập Dữ liệu từ Người Dùng",
            "content": "# Bài 25. Python - Nhập Dữ liệu từ Người Dùng\n\n## Giới thiệu về Nhập Dữ liệu từ Người Dùng trong Python\n\nTrong chương này, chúng ta sẽ tìm hiểu cách Python nhận dữ liệu đầu vào từ người dùng từ bảng điều khiển và hiển thị kết quả trên cùng một bảng điều khiển.\n\nMọi ứng dụng máy tính đều nên có một cơ chế để nhận đầu vào từ người dùng khi nó đang chạy. Điều này làm cho ứng dụng trở nên tương tác. Tùy thuộc vào cách phát triển, một ứng dụng có thể chấp nhận đầu vào từ người dùng dưới dạng văn bản nhập vào từ bảng điều khiển (sys.stdin), một giao diện đồ họa hoặc một giao diện dựa trên web.\n\n## Hàm Nhập Dữ liệu từ Người Dùng trong Python\n\nPython cung cấp cho chúng ta hai hàm tích hợp sẵn để đọc đầu vào từ bàn phím.\n\n1. Hàm input()\n2. Hàm raw_input() (trong Python 2.7)\n\n## Hàm input() trong Python\n\nKhi bộ thông dịch gặp phải hàm input(), nó sẽ chờ đợi người dùng nhập dữ liệu từ luồng đầu vào tiêu chuẩn (bàn phím) cho đến khi phím Enter được nhấn. Các ký tự nhập có thể được lưu trữ trong một biến chuỗi để sử dụng sau này.\n\n## Cú pháp của hàm input() trong Python:\n\n```python\nvar = input()\n```\n\n## Ví dụ về Hàm input() trong Python:\n\n```python\nname = input()\ncity = input()\n\nprint(\"Xin chào, Tên tôi là\", name)\nprint(\"Tôi đến từ\", city)\n```\n\nTrong ví dụ này, các biến `name` và `city` sẽ chứa dữ liệu mà người dùng nhập vào từ bàn phím.\n\n## Hàm raw_input() trong Python\n\nHàm raw_input() hoạt động tương tự như hàm input(), nhưng nó chỉ có sẵn trong Python 2.7 và đã được đổi tên thành input() trong Python 3.6.\n\n## Cú pháp của hàm raw_input() trong Python:\n\n```python\nvar = raw_input([prompt text])\n```\n\n## Ví dụ về Hàm raw_input() trong Python:\n\n```python\nname = raw_input(\"Nhập tên của bạn: \")\ncity = raw_input(\"Nhập tên thành phố: \")\n\nprint(\"Xin chào, Tên tôi là\", name)\nprint(\"Tôi đến từ\", city)\n```\n\nTrong ví dụ này, hàm `raw_input()` sẽ hiển thị thông điệp nhắc người dùng trước khi nhập dữ liệu.\n\n## Nhận Dữ liệu Số Trong Python\n\nChúng ta cũng có thể nhận dữ liệu số từ người dùng trong Python bằng cách sử dụng hàm `input()` và sau đó chuyển đổi đầu vào thành số nguyên hoặc số thực.\n\n## Ví dụ:\n\n```python\nwidth = int(input(\"Nhập chiều rộng: \"))\nheight = int(input(\"Nhập chiều cao: \"))\n\narea = width * height\nprint(\"Diện tích hình chữ nhật = \", area)\n```\n\nTrong ví dụ này, chúng ta nhập chiều rộng và chiều cao từ người dùng và tính diện tích của hình chữ nhật. Để chuyển đổi đầu vào từ dạng chuỗi thành số nguyên, chúng ta sử dụng hàm `int()`.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 27,
        "fields": {
            "name": "Bài 26. Python - Số",
            "content": "# Bài 26. Python - Số\n\nPython có sẵn hỗ trợ để lưu trữ và xử lý dữ liệu số (Python Numbers). Hầu hết thời gian bạn làm việc với số trong hầu hết các ứng dụng Python. Rõ ràng, bất kỳ ứng dụng máy tính nào cũng đều xử lý số. Hướng dẫn này sẽ thảo luận về các loại số Python khác nhau và các thuộc tính của chúng.\n\n## Python - Các Loại Số\n\nCó ba loại số được tích hợp sẵn trong Python:\n\n1. Số nguyên (int)\n2. Số dấu chấm động (float)\n3. Số phức\n\nPython cũng có một loại dữ liệu Boolean được tích hợp sẵn gọi là bool. Nó có thể được coi như một loại con của kiểu int, vì hai giá trị có thể có của nó là True và False biểu diễn cho các số nguyên 1 và 0 tương ứng.\n\n## Python − Số Nguyên\n\nTrong Python, bất kỳ số nào mà không có khả năng lưu trữ phần thập phân là số nguyên. (Lưu ý rằng nếu phần thập phân trong một số là 0, điều đó không có nghĩa là nó là một số nguyên. Ví dụ, một số 10.0 không phải là một số nguyên, nó là một số dấu chấm động với phần thập phân là 0 có giá trị số là 10.) Một số nguyên có thể là số 0, số nguyên dương hoặc số nguyên âm. Ví dụ, 1234, 0, -55 đều đại diện cho các số nguyên trong Python.\n\nCó ba cách để tạo một đối tượng số nguyên. Bằng cách (a) biểu diễn literal, (b) bất kỳ biểu thức nào đánh giá thành một số nguyên, và (c) sử dụng hàm int().\n\nLiteral là một ký hiệu được sử dụng để biểu diễn một hằng số trực tiếp trong mã nguồn. Ví dụ −\n\n```python\na = 10\n```\n\nTuy nhiên, xem xét việc gán biến số nguyên c như sau.\n\n```python\na = 10\nb = 20\nc = a + b\n\nprint (\"a:\", a, \"type:\", type(a))\nprint (\"c:\", c, \"type:\", type(c))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\na: 10 type: <class 'int'>\nc: 30 type: <class 'int'>\n```\n\nỞ đây, c thực sự là một biến số nguyên, nhưng biểu thức a + b được đánh giá trước và giá trị của nó được gán gián tiếp cho c.\n\nPhương pháp thứ ba để tạo một đối tượng số nguyên là với giá trị trả về của hàm int(). Nó chuyển đổi một số dấu chấm động hoặc một chuỗi thành một số nguyên.\n\n```python\na = int(10.5)\nb = int(\"100\")\n```\n\nBạn có thể biểu diễn một số nguyên dưới dạng số nhị phân, bát phân hoặc số thập lục phân. Tuy nhiên, bên trong, đối tượng được lưu trữ là một số nguyên.\n\n### Số Nhị Phân trong Python\n\nMột số gồm chỉ các chữ số nhị phân (1 và 0) và tiền tố bằng \"0b\" là một số nhị phân. Nếu bạn gán một số nhị phân cho một biến, nó vẫn là một biến số nguyên.\n\nĐể biểu diễn một số nguyên dưới dạng nhị phân, lưu trữ trực tiếp dưới dạng literal, hoặc sử dụng hàm int(), trong đó cơ sở được đặt thành 2.\n\n```python\na = 0b101\nprint (\"a:\", a, \"type:\", type(a))\n\nb = int(\"0b101011\", 2)\nprint (\"b:\", b, \"type:\", type(b))\n```\n\nNó sẽ tạo ra đầu ra sau −\n\n```\na: 5 type: <class 'int'>\nb: 43 type: <class 'int'>\n```\n\nCũng có một hàm bin() trong Python. Nó trả về một chuỗi nhị phân tương đương của một số nguyên.\n\n```python\na = 43\nb = bin(a)\nprint (\"Số Nguyên:\", a, \"Tương đương nhị phân:\", b)\n```\n\nNó sẽ tạo ra đầu ra sau −\n\n```\nSố Nguyên: 43 Tương đương nhị phân: 0b101011\n```\n\n### Số Bát Phân trong Python\n\nMột số bát phân được tạo thành từ các chữ số từ 0 đến 7. Để chỉ ra rằng số nguyên sử dụng chú thích bát phân, cần được tiền tố bằng \"0o\" (viết thường o) hoặc \"0O\" (viết hoa o). Biểu diễn literal của số bát phân như sau −\n\n```python\na = 0O107\nprint (a, type(a))\n```\n\nNó sẽ tạo ra đầu ra sau −\n\n```\n71 <class 'int'>\n```\n\nLưu ý rằng đối tượng được lưu trữ bên trong là số nguyên\n\n**Số phức trong Python:**\n\nTrong Python, số phức được biểu diễn bằng một phần thực và một phần ảo, trong đó phần ảo được ký hiệu bằng chữ \"j\". Một số phức có thể được tạo bằng cách sử dụng hàm complex() hoặc bằng cách cung cấp một số thực và một số ảo cho hàm này.\n\nVí dụ:\n\n```python\n# Sử dụng hàm complex()\nz1 = complex(2, 3)\nprint(z1)  # Kết quả: (2+3j)\n\n# Sử dụng phần thực và phần ảo\nz2 = 4 + 5j\nprint(z2)  # Kết quả: (4+5j)\n```\n\nKhi làm việc với số phức, bạn có thể truy cập phần thực và phần ảo của số phức bằng cách sử dụng các thuộc tính `real` và `imag`, tương ứng.\n\n```python\nz = 2 + 3j\nprint(\"Phần thực:\", z.real)  # Kết quả: 2.0\nprint(\"Phần ảo:\", z.imag)    # Kết quả: 3.0\n```\n\nCác phép toán cơ bản như cộng, trừ, nhân và chia cũng được hỗ trợ cho số phức trong Python. Ví dụ:\n\n```python\nz1 = 2 + 3j\nz2 = 4 + 5j\n\n# Cộng hai số phức\nsum_z = z1 + z2\nprint(\"Tổng:\", sum_z)  # Kết quả: (6+8j)\n\n# Nhân hai số phức\nproduct_z = z1 * z2\nprint(\"Tích:\", product_z)  # Kết quả: (-7+22j)\n```\n\nĐể tính số phức liên conjuate (nghịch đảo của số phức), bạn có thể sử dụng phương thức `conjugate()`.\n\n```python\nz = 2 + 3j\nconjugate_z = z.conjugate()\nprint(\"Liên conjuguate của z:\", conjugate_z)  # Kết quả: (2-3j)\n```\n\nNgoài ra, Python cũng cung cấp một số hàm toán học cho số phức như `abs()`, `phase()`, và `polar()` để tính giá trị tuyệt đối, góc và biểu diễn dạng cực của số phức.\n\n```python\nz = 3 + 4j\n\n# Tính giá trị tuyệt đối\nabs_z = abs(z)\nprint(\"Giá trị tuyệt đối:\", abs_z)  # Kết quả: 5.0\n\n# Tính góc (phase) của số phức\nphase_z = phase(z)\nprint(\"Góc của số phức:\", phase_z)  # Kết quả: 0.9272952180016122 (đơn vị radian)\n\n# Biểu diễn số phức dưới dạng cực (r, phi)\npolar_z = polar(z)\nprint(\"Biểu diễn cực:\", polar_z)  # Kết quả: (5.0, 0.9272952180016122)\n```\n\nĐó là cách bạn có thể làm việc với số phức trong Python, bao gồm cách tạo, thực hiện các phép toán và truy cập các thuộc tính và phương thức của chúng.",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 28,
        "fields": {
            "name": "Bài 27. Python - Booleans",
            "content": "# Bài 27. Python - Booleans\n\nTrong Python, bool là một loại con của kiểu int. Một đối tượng bool có hai giá trị có thể là True hoặc False, và nó được khởi tạo bằng các từ khóa True và False của Python.\n\n## Ví dụ\n\n```python\na = True\nb = False\nprint(type(a), type(b))\n```\n\nOutput:\n\n```\n<class 'bool'> <class 'bool'>\n```\n\nMột đối tượng bool được chấp nhận làm đối số cho các hàm chuyển đổi kiểu. Với True là đối số, hàm int() trả về 1, float() trả về 1.0; trong khi đối với False, chúng trả về 0 và 0.0 tương ứng. Chúng ta có một phiên bản một đối số của hàm complex().\n\nNếu đối số là một đối tượng phức tạp, nó được xem như phần thực, thiết lập hệ số ảo thành 0.\n\n## Ví dụ\n\n```python\na = int(True)\nprint(\"bool to int:\", a)\na = float(False)\nprint(\"bool to float:\", a)\na = complex(True)\nprint(\"bool to complex:\", a)\n```\n\nKết quả khi chạy mã này sẽ như sau:\n\n```\nbool to int: 1\nbool to float: 0.0\nbool to complex: (1+0j)\n```\n\n# Biểu thức Boolean trong Python\n\nBiểu thức boolean trong Python là một biểu thức mà đánh giá thành một giá trị Boolean. Nó gần như luôn luôn liên quan đến một toán tử so sánh. Trong ví dụ dưới đây, chúng ta sẽ thấy làm thế nào các toán tử so sánh có thể cho chúng ta các giá trị Boolean. Phương thức bool() được sử dụng để trả về giá trị đúng hoặc sai của một biểu thức.\n\nCú pháp: bool([x])\n\nTrả về True nếu X đánh giá thành True, ngược lại trả về False.\n\nNếu không có tham số, nó trả về False.\n\nDưới đây là các ví dụ sử dụng các chuỗi số và các giá trị Boolean làm tham số cho hàm bool. Kết quả được trả về là true hoặc false tùy thuộc vào tham số.\n\n## Ví dụ\n\n```python\n# Kiểm tra True\na = True\nprint(bool(a))\n\n# Kiểm tra False\na = False\nprint(bool(a))\n\n# Kiểm tra 0\na = 0.0\nprint(bool(a))\n\n# Kiểm tra 1\na = 1.0\nprint(bool(a))\n\n# Kiểm tra sự bằng nhau\na = 5\nb = 10\nprint(bool(a == b))\n\n# Kiểm tra None\na = None\nprint(bool(a))\n\n# Kiểm tra một chuỗi rỗng\na = ()\nprint(bool(a))\n\n# Kiểm tra một mapping rỗng\na = {}\nprint(bool(a))\n\n# Kiểm tra một chuỗi không rỗng\na = '8 Sync Dev'\nprint(bool(a))\n```\n",
            "lesson": 1,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 29,
        "fields": {
            "name": "Bài 0. Python - Luồng điều khiển",
            "content": "# Bài 0. Python - Luồng điều khiển\n\nTrong Python, luồng điều khiển của chương trình được điều chỉnh bằng các loại câu lệnh điều kiện, vòng lặp và cuộc gọi hàm khác nhau. Mặc định, các chỉ thị trong một chương trình máy tính được thực thi theo cách tuần tự, từ trên xuống dưới hoặc từ đầu đến cuối. Tuy nhiên, các chương trình thực thi theo cách tuần tự như vậy chỉ có thể thực hiện các nhiệm vụ đơn giản. Chúng ta muốn chương trình có khả năng ra quyết định, để nó thực hiện các bước khác nhau tùy thuộc vào các điều kiện khác nhau.\n\nHầu hết các ngôn ngữ lập trình bao gồm cả Python đều cung cấp chức năng để kiểm soát luồng thực thi của các chỉ thị. Thông thường, có hai loại câu lệnh kiểm soát luồng trong bất kỳ ngôn ngữ lập trình nào và Python cũng hỗ trợ chúng.\n\n## Câu lệnh Ra quyết định\n\nCâu lệnh ra quyết định được sử dụng trong các chương trình Python để làm cho chúng có khả năng quyết định xem nhóm các chỉ thị thay thế nào sẽ được thực thi, tùy thuộc vào giá trị của một biểu thức Boolean nhất định.\n\nSơ đồ dưới đây minh họa cách các câu lệnh ra quyết định hoạt động -\n\n![Câu lệnh ra quyết định](decision_making_statements.png)\n\n### Câu lệnh if\n\nPython cung cấp các câu lệnh điều khiển if..elif..else như một phần của quyết định. Dưới đây là một ví dụ đơn giản sử dụng if..elif..else. Bạn có thể thử chạy chương trình này với các điểm khác nhau và xác minh kết quả.\n\n```python\nmarks = 80 \nresult = \"\"\nif marks < 30:\n   result = \"Failed\"\nelif marks > 75:\n   result = \"Passed with distinction\"\nelse:\n   result = \"Passed\"\n\nprint(result)\n```\n\nKết quả sẽ là:\n\n```\nPassed with distinction\n```\n\n### Câu lệnh match\n\nPython hỗ trợ câu lệnh Match-Case, cũng có thể được sử dụng như một phần của quyết định. Dưới đây là một ví dụ đơn giản sử dụng câu lệnh match.\n\n```python\ndef checkVowel(n):\n   match n:\n      case 'a': return \"Vowel alphabet\"\n      case 'e': return \"Vowel alphabet\"\n      case 'i': return \"Vowel alphabet\"\n      case 'o': return \"Vowel alphabet\"\n      case 'u': return \"Vowel alphabet\"\n      case _: return \"Simple alphabet\"\n\nprint (checkVowel('a'))\nprint (checkVowel('m'))\nprint (checkVowel('o'))\n```\n\nKết quả sẽ là:\n\n```\nVowel alphabet\nSimple alphabet\nVowel alphabet\n```\n\n## Câu lệnh Lặp hoặc Lặp điều khiển\n\nHầu hết các quy trình đòi hỏi một nhóm các chỉ thị được lặp đi lặp lại. Trong thuật ngữ lập trình, điều này được gọi là vòng lặp. Thay vì bước tiếp theo, nếu luồng được chuyển hướng về bất kỳ bước trước đó nào, nó tạo thành một vòng lặp.\n\nSơ đồ dưới đây minh họa cách vòng lặp hoạt động -\n\n![Vòng lặp](looping_works.png)\n\nNếu điều khiển quay lại mà không có điều kiện, nó tạo thành một vòng lặp vô hạn không mong muốn vì phần còn lại của mã sẽ không bao giờ được thực thi.\n\nTrong một vòng lặp có điều kiện, việc lặp lại lặp đi lặp lại của một nhóm các chỉ thị tiếp tục cho đến khi một điều kiện nhất định được đáp ứng. Python hỗ trợ một số vòng lặp như vòng lặp for, vòng lặp while mà chúng ta sẽ nghiên cứu trong các chương tiếp theo.\n\n### Vòng lặp for\n\nVòng lặp for lặp lại qua các mục của bất kỳ chuỗi nào, chẳng hạn như một danh sách, tuple hoặc một chuỗi.\n\nDưới đây là một ví dụ sử dụng Vòng lặp For để lặp qua một mảng trong Python:\n\n```python\nwords = [\"one\", \"two\", \"three\"]\nfor x in words:\n  print(x)\n```\n\nKết quả sẽ là:\n\n```\none\ntwo\nthree\n```\n\n### Vòng lặp while\n\nVòng lặp while lặp lại một câu lệnh mục tiêu liên tục miễn là một biểu thức boolean cụ thể được đánh giá là đúng.\n\nDưới đây là một ví dụ sử dụng Vòng lặp While để in ra 5 số đầu tiên trong Python:\n\n```python\ni = 1\nwhile i < 6:\n  print(i)\n  i += 1\n```\n\nKết quả sẽ là:\n\n```\n1\n2\n3\n4\n5\n```\n\n## Câu lệnh nhảy\n\nnhảy\n\nCác câu lệnh nhảy được sử dụng để nhảy đến một câu lệnh cụ thể bằng cách phá vỡ luồng thực thi hiện tại của chương trình. Trong Python, có hai câu lệnh nhảy là break và continue.\n\n### Câu lệnh break\n\nNó chấm dứt vòng lặp hiện tại và tiếp tục thực thi tại câu lệnh tiếp theo.\n\nVí dụ dưới đây minh họa việc sử dụng câu lệnh break -\n\n```python\nx = 0\n\nwhile x < 10:\n    print(\"x:\", x)\n    if x == 5:\n        print(\"Breaking...\")\n        break\n    x += 1\n\nprint(\"End\")\n```\n\nKết quả sẽ là:\n\n```\nx: 0\nx: 1\nx: 2\nx: 3\nx: 4\nx: 5\nBreaking...\nEnd\n```\n\n### Câu lệnh continue\n\nNó bỏ qua việc thực thi của khối chương trình và trả lại điều khiển về đầu vòng lặp hiện tại để bắt đầu vòng lặp kế tiếp.\n\nVí dụ dưới đây minh họa việc sử dụng câu lệnh continue -\n\n```python\nfor letter in \"Python\":\n    # Bỏ qua khi chữ cái là 'h'\n    if letter == \"h\":\n        continue\n    print(\"Current Letter :\", letter)\n```\n\nKết quả sẽ là:\n\n```\nCurrent Letter : P\nCurrent Letter : y\nCurrent Letter : t\nCurrent Letter : o\nCurrent Letter : n\n```\n\nNhư vậy, các câu lệnh điều khiển và vòng lặp là các công cụ quan trọng giúp kiểm soát luồng thực thi của chương trình Python và tạo điều kiện cho quyết định và lặp lại các phần mã cần thiết.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 30,
        "fields": {
            "name": "Bài 1. Python - Ra Quyết Định",
            "content": "# Bài 1. Python - Ra Quyết Định\n\nTrong Python, khả năng ra quyết định được thực hiện thông qua các từ khóa if..elif...else. Từ khóa if yêu cầu một biểu thức boolean, theo sau bởi dấu hai chấm (:) để bắt đầu một khối được thụt vào. Các câu lệnh có cùng mức thụt vào sẽ được thực thi nếu biểu thức boolean trong câu lệnh if là Đúng. Nếu biểu thức không Đúng (False), trình thông dịch sẽ bỏ qua khối được thụt vào và tiếp tục thực thi các câu lệnh ở mức thụt vào trước đó.\n\nCấu trúc quyết định đánh giá nhiều biểu thức, tạo ra Kết quả TRUE hoặc FALSE. Bạn cần xác định hành động nào cần thực hiện và các câu lệnh nào sẽ được thực thi nếu Kết quả là TRUE hoặc FALSE.\n\n\nNgôn ngữ lập trình Python giả định bất kỳ giá trị không bằng không và không rỗng như TRUE, và nếu nó là không hoặc null, thì nó được giả định là giá trị FALSE.\n\nNgôn ngữ lập trình Python cung cấp các loại câu lệnh ra quyết định sau đây. Nhấp vào các liên kết sau đây để kiểm tra chi tiết của chúng.\n\n**1.** Câu lệnh if\n\n   Một câu lệnh if bao gồm một biểu thức boolean theo sau là một hoặc nhiều câu lệnh.\n\n**2.** Câu lệnh if...else\n\n   Một câu lệnh if có thể được theo sau bởi một câu lệnh else tùy chọn, thực thi khi biểu thức boolean là FALSE.\n\n**3.** Câu lệnh if lồng nhau\n\n   Bạn có thể sử dụng một câu lệnh if hoặc else if bên trong một câu lệnh if hoặc else if(s).\n\nHãy đi qua từng câu lệnh ra quyết định một cách ngắn gọn −\n\n### Các Khối Mã Đơn\n\nNếu khối mã của một mệnh đề if chỉ bao gồm một dòng duy nhất, nó có thể được viết trên cùng một dòng với câu lệnh tiêu đề.\n\nDưới đây là một ví dụ về mệnh đề if trên một dòng −\n\n```python\n#!/usr/bin/python\n\nvar = 100\nif ( var == 100 ) : print (\"Value of expression is 100\")\nprint (\"Good bye!\")\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra kết quả sau:\n\n```\nValue of expression is 100\nGood bye!\n```\n\nĐây là cách Python thực hiện ra quyết định trong các chương trình của mình. Các câu lệnh ra quyết định giúp chương trình lựa chọn hành động dựa trên các điều kiện cụ thể và là một phần quan trọng của việc kiểm soát luồng của chương trình.\n\nDưới đây là một ví dụ minh họa về cách sử dụng câu lệnh if để quyết định hành động dựa trên một biểu thức boolean:\n\n```python\n# Kiểm tra điểm số và in ra kết quả dựa trên điều kiện\nmarks = 80\n\nif marks < 30:\n    result = \"Failed\"\nelif marks > 75:\n    result = \"Passed with distinction\"\nelse:\n    result = \"Passed\"\n\nprint(\"Result:\", result)\n```\n\nKết quả sẽ là:\n\n```\nResult: Passed with distinction\n```\n\nDưới đây là một ví dụ sử dụng câu lệnh if...else để xác định xem một ký tự là nguyên âm hay không:\n\n```python\n# Kiểm tra xem ký tự có phải là nguyên âm không\ndef checkVowel(character):\n    if character in ['a', 'e', 'i', 'o', 'u']:\n        return \"Vowel alphabet\"\n    else:\n        return \"Not a vowel alphabet\"\n\nprint(checkVowel('a'))  # Kết quả: Vowel alphabet\nprint(checkVowel('b'))  # Kết quả: Not a vowel alphabet\n```\n\nDưới đây là một ví dụ sử dụng câu lệnh if lồng nhau để kiểm tra số lớn nhất trong ba số:\n\n```python\n# Tìm số lớn nhất trong ba số\nnum1 = 10\nnum2 = 20\nnum3 = 15\n\nif num1 >= num2:\n    if num1 >= num3:\n        largest = num1\n    else:\n        largest = num3\nelse:\n    if num2 >= num3:\n        largest = num2\n    else:\n        largest = num3\n\nprint(\"Largest number is:\", largest)\n```\n\nKết quả sẽ là:\n\n```\nLargest number is: 20\n```\n\nNhư vậy, đây là một số ví dụ về cách sử dụng câu lệnh ra quyết định trong Python để thực hiện các hành động dựa trên điều kiện cụ thể.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 31,
        "fields": {
            "name": "Bài 2. Python - Mệnh đề if",
            "content": "# Bài 2. Python - Mệnh đề if\n\nTrong Python, mệnh đề if thực hiện việc thực thi có điều kiện. Nó chứa một biểu thức logic để so sánh dữ liệu và quyết định được đưa ra dựa trên kết quả của sự so sánh đó.\n\n## Cú pháp của Mệnh đề if\n\n```python\nif biểu_thức:\n   câu_lệnh(s)\n```\n\nNếu biểu thức logic đánh giá thành TRUE, thì khối câu lệnh bên trong mệnh đề if sẽ được thực thi. Nếu biểu thức logic đánh giá thành FALSE, thì tập hợp câu lệnh đầu tiên sau khi kết thúc của mệnh đề if sẽ được thực thi.\n\n## Sơ đồ luồng của Mệnh đề if (Flowchart)\n\n![Sơ đồ luồng của Mệnh đề if trong Python](../../../assets/if-else/OIG1.jpg)\n\n## Ví dụ về Mệnh đề if trong Python\n\nHãy xem xét một ví dụ về một khách hàng có được giảm giá 10% nếu số tiền mua hàng của anh ấy là > 1000; nếu không, thì không có giảm giá nào được áp dụng. Sơ đồ luồng dưới đây cho thấy toàn bộ quá trình ra quyết định.\n\n![Sơ đồ luồng của Mệnh đề if](../../../assets/if-else/OIG1.hwWs.jpg)\n\nTrong Python, trước tiên chúng ta thiết lập một biến giảm giá thành 0 và chấp nhận số tiền làm đầu vào từ người dùng.\n\nSau đó đến mệnh đề có điều kiện nếu số tiền > 1000. Đặt dấu : bắt đầu khối có điều kiện trong đó giảm giá được tính toán. Rõ ràng, giảm giá hoặc không, câu lệnh tiếp theo mặc định sẽ in số tiền - giảm giá. Nếu áp dụng, nó sẽ được trừ, nếu không, nó là 0.\n\n```python\ndiscount = 0\namount = 1200\n\n# Kiểm tra giá trị số tiền\nif amount > 1000:\n   discount = amount * 10 / 100\n\nprint(\"amount =\", amount - discount)\n```\n\nỞ đây số tiền là 1200, do đó giảm giá 120 được trừ. Khi thực thi mã, bạn sẽ nhận được đầu ra sau đây:\n\n```\namount = 1080.0\n```\n\nThay đổi biến amount thành 800 và chạy lại mã. Lần này, không có giảm giá nào được áp dụng. Và, bạn sẽ nhận được đầu ra sau đây −\n\n```\namount = 800\n```\n\nĐây là một số ví dụ về cách sử dụng mệnh đề if trong Python để thực hiện các hành động dựa trên điều kiện cụ thể.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 32,
        "fields": {
            "name": "Bài 3. Hướng dẫn Sử dụng Câu lệnh if-else trong Python",
            "content": "# Bài 3. Hướng dẫn Sử dụng Câu lệnh if-else trong Python\n\n## Mục đích\n\nTài liệu này cung cấp hướng dẫn chi tiết về cách sử dụng câu lệnh if-else trong Python. Nó mô tả cách sử dụng if-else để kiểm tra điều kiện và thực thi các khối mã tương ứng dựa trên kết quả của điều kiện đó.\n\n## Câu lệnh if-else trong Python\n\n### Cú pháp\n\nCâu lệnh if-else trong Python có cú pháp như sau:\n\n```python\nif điều_kiện:\n    # Khối mã được thực thi\n    # khi điều_kiện là True\nelse:\n    # Khối mã được thực thi\n    # khi điều_kiện là False\n```\n\n\n### Ví dụ về Câu lệnh if-else\n\nĐể minh họa, xem ví dụ sau:\n\n```python\nage = 25\nprint(\"Tuổi: \", age)\nif age >= 18:\n    print(\"Bạn đủ điều kiện để bỏ phiếu\")\nelse:\n    print(\"Bạn không đủ điều kiện để bỏ phiếu\")\n```\n\nĐầu tiên, thiết lập biến nguyên \"age\" thành 25.\n\nSau đó, sử dụng câu lệnh if với biểu thức \"age>18\" theo sau là \":\" bắt đầu một khối mã; điều này sẽ được thực hiện nếu \"age>=18\" là True.\n\nĐể cung cấp khối else, sử dụng else: khối mã được thụt vào tiếp theo chứa thông báo \"Không đủ điều kiện để bỏ phiếu\" sẽ được thực hiện khi \"age>=18\" là False.\n\nKhi thực thi mã này, bạn sẽ nhận được kết quả sau:\n\n```\nTuổi: 25\nBạn đủ điều kiện để bỏ phiếu\n```\n\nĐể kiểm tra khối else, hãy thay đổi tuổi thành 12 và chạy lại mã.\n\n```\nTuổi: 12\nBạn không đủ điều kiện để bỏ phiếu\n```\n\n## Câu lệnh if elif else trong Python\n\nCâu lệnh if elif else cho phép bạn kiểm tra nhiều biểu thức và thực thi một khối mã ngay khi một trong các điều kiện đánh giá là True.\n\nTương tự như câu lệnh else, câu lệnh elif là tùy chọn. Tuy nhiên, khác với else, chỉ có thể có tối đa một câu lệnh elif; có thể có một số câu lệnh elif sau một câu lệnh if.\n\n### Cú pháp của câu lệnh if elif else trong Python\n\n```python\nif biểu_thức1:\n    khối mã\nelif biểu_thức2:\n    khối mã\nelif biểu_thức3:\n    khối mã\nelse:\n    khối mã\n```\n\n### Cách hoạt động của câu lệnh if elif else\n\nHãy hiểu cách câu lệnh if elif else hoạt động, với ví dụ sau.\n\nCấu trúc giảm giá được sử dụng trong ví dụ trước đã được sửa đổi thành các mức giảm giá khác nhau:\n\n- 20% trên số tiền vượt quá 10000,\n- 10% cho số tiền giữa 5-10000,\n- 5% nếu nó nằm giữa 1 đến 5000,\n- không giảm giá nếu số tiền <1000.\n\n\n\n### Ví dụ\n\nChúng ta có thể viết mã Python cho logic trên với câu lệnh if-else:\n\n```python\namount = 2500\nprint('Số tiền = ', amount)\nif amount > 10000:\n    discount = amount * 20 / 100\nelse:\n    if amount > 5000:\n        discount = amount * 10 / 100\n    else:\n        if amount > 1000:\n            discount = amount * 5 / 100\n        else:\n            discount = 0\n\nprint('Số tiền phải trả = ', amount - discount)\n```\n\nĐặt số tiền để kiểm tra tất cả các điều kiện có thể: 800, 2500, 7500 và 15000. Kết quả sẽ thay đổi tương ứng.\n\n```\nSố tiền: 800\nSố tiền phải trả = 800\nSố tiền: 2500\nSố tiền phải trả = 2375.0\nSố tiền: 7500\nSố tiền phải trả = 6750.0\nSố tiền: 15000\nSố tiền phải trả = 12000.0\n```\n\nMặc dù mã sẽ hoạt động hoàn hảo, nhưng nếu bạn nhìn vào việc thụt vào cấp độ tăng dần ở mỗi câu lệnh if và else, sẽ trở nên khó quản lý nếu còn nhiều điều kiện hơn.\n\nCâu lệnh elif giúp mã dễ đọc và hiểu hơn.\n\n### Ví dụ về Câu lệnh if elif else trong Python\n\n```python\namount = 2500\nprint('Số tiền = ', amount)\nif amount > 10000:\n    discount = amount * 20 / 100\nelif amount > 5000:\n    discount = amount * 10 / 100\nelif amount > 1000:\n    discount = amount * 5 / 100\nelse:\n    discount = 0\n\nprint('Số tiền phải trả = ', amount - discount)\n```\n\nĐặt số tiền để kiểm tra tất cả các điều kiện có thể: 800, 2500, 7500 và 15000. Kết quả sẽ thay đổi tương ứng.\n\n```\nSố tiền: 800\nSố tiền phải trả = 800\nSố tiền: 2500\nSố tiền phải trả = 2375.0\nSố tiền: 7500\nSố tiền phải trả = 6750.0\nSố tiền: 15000\nSố tiền phải trả = 12000.0\n```\n\nViệc sử dụng câu lệnh elif giúp mã trở nên ngắn gọn và dễ đọc hơn, vì không cần thiết phải thụt vào mỗi lần có một điều kiện mới. Câu lệnh elif cũng giúp mã trở nên linh hoạt hơn khi cần thêm điều kiện kiểm tra.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 33,
        "fields": {
            "name": "Bài 4. Hướng dẫn Sử dụng Câu lệnh if Lồng nhau trong Python",
            "content": "# Bài 4. Hướng dẫn Sử dụng Câu lệnh if Lồng nhau trong Python\n\n## Mục đích\n\nTài liệu này mô tả cách sử dụng câu lệnh if lồng nhau trong Python. Câu lệnh if lồng nhau cho phép chúng ta kiểm tra các điều kiện nằm trong các điều kiện khác.\n\n## Cú pháp\n\nCú pháp của câu lệnh if lồng nhau sẽ như sau:\n\n```python\nif biểu_thức1:\n    # Khối mã\n    if biểu_thức2:\n        # Khối mã\n    elif biểu_thức3:\n        # Khối mã\n    else:\n        # Khối mã\nelif biểu_thức4:\n    # Khối mã\nelse:\n    # Khối mã\n```\n\n## Ví dụ\n\nHãy xem một ví dụ để hiểu cách hoạt động của câu lệnh if lồng nhau.\n\n```python\nnum = 8\nprint(\"num = \", num)\nif num % 2 == 0:\n    if num % 3 == 0:\n        print(\"Chia hết cho 3 và 2\")\n    else:\n        print(\"Chia hết cho 2 nhưng không chia hết cho 3\")\nelse:\n    if num % 3 == 0:\n        print(\"Chia hết cho 3 nhưng không chia hết cho 2\")\n    else:\n        print(\"Không chia hết cho cả 2 và 3\")\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra kết quả sau:\n\n```\nnum = 8\nChia hết cho 2 nhưng không chia hết cho 3\nnum = 15\nChia hết cho 3 nhưng không chia hết cho 2\nnum = 12\nChia hết cho 3 và 2\nnum = 5\nKhông chia hết cho cả 2 và 3\n```\n\nTrong ví dụ này, chúng ta kiểm tra xem số `num` có chia hết cho 2 hay không. Nếu có, chúng ta tiếp tục kiểm tra xem `num` có chia hết cho 3 không. Tùy thuộc vào kết quả của các điều kiện, chúng ta in ra thông điệp tương ứng.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 34,
        "fields": {
            "name": "Bài 5. Python - Câu lệnh Match-Case",
            "content": "# Bài 5. Python - Câu lệnh Match-Case\n\n## Giới thiệu\n\nTrước phiên bản 3.10 của Python, Python thiếu một tính năng tương tự như switch-case trong C hoặc C++. Trong Python 3.10, một kỹ thuật phù hợp gọi là match-case đã được giới thiệu, tương tự như cấu trúc switch-case có sẵn trong C/C++/Java v.v.\n\n## Câu lệnh Match-Case trong Python\n\nMột câu lệnh match-case trong Python nhận một biểu thức và so sánh giá trị của nó với các mẫu liên tiếp được đưa ra dưới dạng một hoặc nhiều khối case. Việc sử dụng tương tự hơn với phù hợp mẫu trong các ngôn ngữ như Rust hoặc Haskell hơn là một câu lệnh switch trong C hoặc C++. Chỉ có mẫu đầu tiên phù hợp được thực thi. Cũng có thể trích xuất các thành phần (phần tử chuỗi hoặc thuộc tính đối tượng) từ giá trị vào các biến.\n\nViệc sử dụng cơ bản của match-case là so sánh một biến với một hoặc nhiều giá trị.\n\n## Cú pháp\n\nDưới đây là cú pháp của câu lệnh match-case trong Python:\n\n```python\nmatch biến:\n   case 'mẫu 1': câu lệnh 1\n   case 'mẫu 2': câu lệnh 2\n   ...\n   case 'mẫu n': câu lệnh n\n```\n\n## Ví dụ\n\nDưới đây là một ví dụ về cách sử dụng câu lệnh match-case:\n\n```python\ndef ngay_trong_tuan(n):\n   match n:\n      case 0: return \"Thứ Hai\"\n      case 1: return \"Thứ Ba\"\n      case 2: return \"Thứ Tư\"\n      case 3: return \"Thứ Năm\"\n      case 4: return \"Thứ Sáu\"\n      case 5: return \"Thứ Bảy\"\n      case 6: return \"Chủ Nhật\"\n      case _: return \"Số ngày không hợp lệ\"\nprint(ngay_trong_tuan(3))\nprint(ngay_trong_tuan(6))\nprint(ngay_trong_tuan(7))\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra kết quả sau:\n\n```\nThứ Năm\nChủ Nhật\nSố ngày không hợp lệ\n```\n\n## Kết luận\n\nCâu lệnh match-case trong Python là một công cụ mạnh mẽ để kiểm tra nhiều trường hợp và thực thi các hành động phù hợp dựa trên giá trị của biến. Nó cung cấp một cú pháp rõ ràng và dễ hiểu để xử lý các tình huống phù hợp.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 35,
        "fields": {
            "name": "Bài 6. Python - Vòng lặp",
            "content": "# Bài 6. Python - Vòng lặp\n\n## Giới thiệu\n\nTrong chương trình, các câu lệnh được thực thi theo thứ tự tuần tự: Câu lệnh đầu tiên trong một hàm được thực thi trước, tiếp theo là câu lệnh thứ hai, và cứ tiếp tục như vậy. Tuy nhiên, có những tình huống khi bạn cần thực thi một khối mã nhiều lần.\n\nNgôn ngữ lập trình cung cấp các cấu trúc điều khiển khác nhau cho phép quản lý các lệnh theo cách phức tạp hơn.\n\n## Vòng lặp trong Python\n\nCác vòng lặp trong Python cho phép chúng ta thực thi một câu lệnh hoặc nhóm câu lệnh nhiều lần.\n\n\n## Các Loại Vòng lặp trong Python\n\nNgôn ngữ lập trình Python cung cấp các loại vòng lặp sau để xử lý yêu cầu lặp lại:\n\n1. **Vòng lặp while**: Lặp lại một câu lệnh hoặc nhóm câu lệnh trong khi một điều kiện nhất định là ĐÚNG. Nó kiểm tra điều kiện trước khi thực thi thân vòng lặp.\n\n2. **Vòng lặp for**: Thực thi một chuỗi các câu lệnh nhiều lần và viết tắt mã quản lý biến vòng lặp.\n\n3. **Vòng lặp lồng nhau**: Bạn có thể sử dụng một hoặc nhiều vòng lặp bên trong bất kỳ vòng lặp while, for hoặc do..while nào khác.\n\n## Các Lệnh Điều khiển Vòng lặp trong Python\n\nCác lệnh điều khiển vòng lặp thay đổi thứ tự thực thi từ thứ tự thông thường của nó. Khi thực thi rời khỏi một phạm vi, tất cả các đối tượng tự động được tạo ra trong phạm vi đó sẽ bị hủy.\n\nPython hỗ trợ các lệnh điều khiển vòng lặp sau đây:\n\n1. **Lệnh break**: Kết thúc câu lệnh vòng lặp và chuyển dẫn thực thi sang câu lệnh ngay sau vòng lặp.\n\n2. **Lệnh continue**: Làm cho vòng lặp bỏ qua phần còn lại của thân vòng lặp và ngay lập tức kiểm tra lại điều kiện của nó trước khi lặp lại.\n\n3. **Lệnh pass**: Lệnh pass trong Python được sử dụng khi một câu lệnh được yêu cầu cú pháp nhưng bạn không muốn thực hiện bất kỳ lệnh hoặc mã nào.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 36,
        "fields": {
            "name": "Bài 7. Python - Vòng lặp For",
            "content": "# Bài 7. Python - Vòng lặp For\n\n## Giới thiệu\n\nVòng lặp for trong Python có khả năng lặp qua các phần tử của bất kỳ chuỗi nào, chẳng hạn như một list, tuple hoặc một chuỗi.\n\n## Cú pháp\n\n```python\nfor biến_lặp in chuỗi:\n    câu_lệnh(s)\n```\n\nNếu một chuỗi chứa một danh sách biểu thức, nó sẽ được đánh giá trước. Sau đó, phần tử đầu tiên (tại chỉ mục 0) trong chuỗi được gán cho biến lặp.\n\nTiếp theo, khối câu lệnh được thực thi. Mỗi phần tử trong danh sách được gán cho biến lặp, và khối câu lệnh được thực thi cho đến khi toàn bộ chuỗi được tiêu thụ.\n\n\n## Loại Vòng lặp trong Python\n\nNgôn ngữ lập trình Python cung cấp các loại vòng lặp sau để xử lý yêu cầu lặp lại:\n\n1. **Vòng lặp while**: Lặp lại một câu lệnh hoặc nhóm câu lệnh trong khi một điều kiện nhất định là ĐÚNG. Nó kiểm tra điều kiện trước khi thực thi thân vòng lặp.\n\n2. **Vòng lặp for**: Thực thi một chuỗi các câu lệnh nhiều lần và viết tắt mã quản lý biến vòng lặp.\n\n3. **Vòng lặp lồng nhau**: Bạn có thể sử dụng một hoặc nhiều vòng lặp bên trong bất kỳ vòng lặp while, for hoặc do..while nào khác.\n\n## Ví dụ\n\n### 1. Vòng lặp for với chuỗi\n\n```python\nzen = '''\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\n'''\nfor char in zen:\n    if char not in 'aeiou':\n        print(char, end='')\n```\n\n### 2. Vòng lặp for với tuples\n\n```python\nnumbers = (34, 54, 67, 21, 78, 97, 45, 44, 80, 19)\ntotal = 0\nfor num in numbers:\n    total += num\nprint(\"Tổng =\", total)\n```\n\n### 3. Vòng lặp for với list\n\n```python\nnumbers = [34, 54, 67, 21, 78, 97, 45, 44, 80, 19]\nfor num in numbers:\n    if num % 2 == 0:\n        print(num)\n```\n\n### 4. Vòng lặp for với đối tượng range\n\n```python\nfor num in range(5):\n    print(num, end=' ')\nprint()\n\nfor num in range(10, 20):\n    print(num, end=' ')\nprint()\n\nfor num in range(1, 10, 2):\n    print(num, end=' ')\n```\n\n### 5. Vòng lặp for với các chỉ số của chuỗi\n\n```python\nnumbers = [34, 54, 67, 21, 78]\nindices = range(len(numbers))\nfor index in indices:\n    print(\"index:\", index, \"number:\", numbers[index])\n```\n\n### 6. Vòng lặp for với từ điển\n\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nfor x in numbers:\n    print(x)\n\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nfor x in numbers:\n    print(x, \":\", numbers[x])\n\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nfor x in numbers.items():\n    print(x)\n\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nfor x, y in numbers.items():\n    print(x, \":\", y)\n```\n\n## Kết luận\n\nVới vòng lặp for trong Python, bạn có thể dễ dàng lặp qua các phần tử của một chuỗi, danh sách, tuple hoặc từ điển và thực thi các câu lệnh cho mỗi phần tử. Điều này gi\n\núp làm cho mã của bạn trở nên gọn gàng và dễ hiểu.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 37,
        "fields": {
            "name": "Bài 8. Python - Vòng lặp For Else",
            "content": "# Bài 8. Python - Vòng lặp For Else\n\nPython hỗ trợ việc sử dụng câu lệnh \"else\" kết hợp với câu lệnh \"for\". Nếu câu lệnh \"else\" được sử dụng với một vòng lặp \"for\", câu lệnh \"else\" sẽ được thực thi khi chuỗi đã được duyệt qua trước khi điều khiển chuyển sang dòng lệnh chính.\n\n\n## Cú pháp của Vòng lặp For Else\n\nCú pháp sau đây của vòng lặp for với mệnh đề else tùy chọn:\n\n```python\nfor biến in iterable:\n    # các câu lệnh trong vòng lặp\n    ...\nelse:\n    # các câu lệnh trong mệnh đề else\n    ...\n```\n\n## Ví dụ về Vòng lặp For Else\n\nDưới đây là một ví dụ minh họa sự kết hợp của câu lệnh else với câu lệnh for trong Python. Cho đến khi đếm nhỏ hơn 5, số lần lặp lại được in ra. Khi nó trở thành 5, câu lệnh in trong khối else được thực thi, trước khi điều khiển chuyển sang câu lệnh tiếp theo trong chương trình chính.\n\n```python\nfor count in range(6):\n    print(\"Lần lặp {}\".format(count))\nelse:\n    print(\"Vòng lặp for đã kết thúc. Bây giờ là trong khối else\")\nprint(\"Kết thúc vòng lặp for\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nLần lặp 0\nLần lặp 1\nLần lặp 2\nLần lặp 3\nLần lặp 4\nLần lặp 5\nVòng lặp for đã kết thúc. Bây giờ là trong khối else\nKết thúc vòng lặp for\n```\n\n## Kết luận\n\nVới câu lệnh \"else\" kết hợp với vòng lặp \"for\" trong Python, bạn có thể thực hiện các hành động bổ sung sau khi vòng lặp kết thúc mà không cần kiểm tra điều kiện. Điều này giúp làm cho mã của bạn trở nên sạch sẽ và dễ hiểu.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 38,
        "fields": {
            "name": "Bài 9. Python - Vòng lặp While",
            "content": "# Bài 9. Python - Vòng lặp While\n\nThông thường, luồng thực thi các bước trong một chương trình máy tính diễn ra từ đầu đến cuối. Tuy nhiên, thay vì chuyển sang bước tiếp theo, nếu luồng được chuyển hướng lại đến bất kỳ bước nào trước đó, đó là một vòng lặp.\n\n## Vòng lặp While trong Python\n\nMột câu lệnh vòng lặp while trong ngôn ngữ lập trình Python thực hiện một câu lệnh mục tiêu lặp đi lặp lại miễn là một biểu thức boolean cụ thể là đúng.\n\n### Cú pháp của Vòng lặp While\n\nCú pháp của vòng lặp while trong ngôn ngữ lập trình Python là −\n\n```python\nwhile biểu_thức:\n   các câu lệnh\n```\n\nTừ khóa while được theo sau bởi một biểu thức boolean, và sau đó là dấu hai chấm, để bắt đầu một khối câu lệnh đã được lùi vào bên trong. Ở đây, các câu lệnh có thể là một câu lệnh duy nhất hoặc một khối câu lệnh với định dạng thụt đồng nhất. Điều kiện có thể là bất kỳ biểu thức nào, và true là bất kỳ giá trị không-zero nào. Vòng lặp lặp lại trong khi biểu thức boolean là true.\n\nNgay khi biểu thức trở thành false, điều khiển chương trình chuyển đến dòng lệnh ngay sau vòng lặp.\n\nNếu nó không thể trở thành false, vòng lặp tiếp tục chạy và không dừng lại trừ khi bị dừng một cách buộc bằng cách sử dụng dừng buộc. Một vòng lặp như vậy được gọi là vòng lặp vô hạn, mà là không mong muốn trong một chương trình máy tính.\n\n### Ví dụ\n\n#### Ví dụ 1:\n\n```python\ncount = 0\nwhile count < 5:\n    count += 1\n    print(\"Lần lặp số {}\".format(count))\n\nprint(\"Kết thúc vòng lặp while\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nLần lặp số 1\nLần lặp số 2\nLần lặp số 3\nLần lặp số 4\nLần lặp số 5\nKết thúc vòng lặp while\n```\n\n#### Ví dụ 2:\n\n```python\nvar = '0'\nwhile var.isnumeric() == True:\n    var = input('Nhập một số...')\n    if var.isnumeric() == True:\n        print(\"Đầu vào của bạn\", var)\n\nprint(\"Kết thúc vòng lặp while\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nNhập một số...10\nĐầu vào của bạn 10\nNhập một số...100\nĐầu vào của bạn 100\nNhập một số...543\nĐầu vào của bạn 543\nNhập một số...qwer\nKết thúc vòng lặp while\n```\n\n## Vòng lặp Vô Hạn trong Python\n\nMột vòng lặp trở thành vòng lặp vô hạn nếu một điều kiện không bao giờ trở thành FALSE. Bạn phải cẩn thận khi sử dụng các vòng lặp while vì có khả năng rằng điều kiện này không bao giờ trở thành giá trị FALSE. Điều này dẫn đến một vòng lặp không bao giờ kết thúc. Một vòng lặp như vậy được gọi là một vòng lặp vô hạn.\n\n\n\nMột vòng lặp vô hạn có thể hữu ích trong lập trình máy chủ/máy khách nơi máy chủ cần chạy liên tục để các chương trình máy khách có thể giao tiếp với nó khi cần thiết.\n\n### Ví dụ\n\n```python\nvar = 1\nwhile var == 1: # Đây tạo ra một vòng lặp vô hạn\n    num = int(input(\"Nhập một số:\"))\n    print(\"Bạn đã nhập: \", num)\n\nprint(\"Tạm biệt!\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nĐầu vào số: 20\nBạn đã nhập: 20\nĐầu vào số: 29\nBạn đã nhập: 29\nĐầu vào số: 3\nBạn đã nhập: 3\nĐầu vào số: 11\nBạn đã nhập: 11\nĐầu vào số: 22\nBạn đã nhập: 22\nĐầu vào số: Nhập vào số nguyên...\n```\n\n## Vòng lặp While-Else trong Python\n\nPython hỗ trợ việc sử dụng câu lệnh \"else\" kết hợp với câu lệnh vòng lặp while.\n\nNếu câu lệnh \"else\" được sử dụng với một vòng lặp while, câu lệnh \"else\" được thực thi khi điều kiện trở thành false trước khi điều khiển chuyển sang dòng lệnh chính của chương trình.\n\n### Ví dụ\n\n```python\ncount = 0\nwhile count < 5:\n    count += 1\n    print(\"Lần lặp số {}\".format(count))\nelse:\n    print(\"Vòng lặp while đã kết thúc. Bây giờ đang trong khối else\")\n\nprint(\"Kết thúc vòng lặp while\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nLần lặp số 1\nLần lặp số 2\nLần lặp số 3\nLần lặp số 4\nLần lặp số 5\nVòng lặp while đã kết thúc. Bây giờ đang trong khối else\nKết thúc vòng lặp while\n```\n\nỞ đây, khi điều kiện của vòng lặp trở thành false, câu lệnh trong khối else được thực thi trước khi điều khiển chuyển sang dòng lệnh chính của chương trình.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 39,
        "fields": {
            "name": "Bài 10.1. Python break Statement",
            "content": "# Bài 10.1. Python break Statement\n\nCâu lệnh break trong Python được sử dụng để kết thúc vòng lặp hiện tại và tiếp tục thực thi tại câu lệnh tiếp theo, tương tự như câu lệnh break truyền thống trong C.\n\nCách sử dụng phổ biến nhất cho câu lệnh break trong Python là khi một điều kiện bên ngoài được kích hoạt yêu cầu một thoát nhanh chóng từ một vòng lặp. Câu lệnh break có thể được sử dụng trong cả các vòng lặp while và for trong Python.\n\nNếu bạn đang sử dụng các vòng lặp lồng nhau trong Python, câu lệnh break sẽ dừng việc thực thi của vòng lặp nằm bên trong nhất và bắt đầu thực thi dòng lệnh tiếp theo sau khối mã.\n\n### Cú pháp của câu lệnh break\n\nCú pháp cho câu lệnh break trong Python là như sau −\n\n```python\nbreak\n```\n\n### Ví dụ về câu lệnh break\n\n#### Ví dụ 1: Thể hiện việc sử dụng câu lệnh break trong Python\n\n```python\nfor letter in 'Python':     # Ví dụ 1\n   if letter == 'h':\n      break\n   print ('Chữ hiện tại :', letter)\n  \nvar = 10                    # Ví dụ 2\nwhile var > 0:              \n   print ('Giá trị biến hiện tại :', var)\n   var = var -1\n   if var == 5:\n      break\n\nprint (\"Tạm biệt!\")\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nChữ hiện tại : P\nChữ hiện tại : y\nChữ hiện tại : t\nChữ hiện tại : o\nChữ hiện tại : n\nGiá trị biến hiện tại : 10\nGiá trị biến hiện tại : 9\nGiá trị biến hiện tại : 8\nGiá trị biến hiện tại : 7\nGiá trị biến hiện tại : 6\nTạm biệt!\n```\n\n#### Ví dụ 2: Kiểm tra một số trong danh sách\n\n```python\nno = int(input('Nhập một số: '))\nnumbers = [11, 33, 55, 39, 55, 75, 37, 21, 23, 41, 13]\nfor num in numbers:\n   if num == no:\n      print('Số được tìm thấy trong danh sách')\n      break\nelse:\n   print('Số không được tìm thấy trong danh sách')\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nNhập một số: 33\nSố được tìm thấy trong danh sách\nNhập một số: 5\nSố không được tìm thấy trong danh sách\n```\n\n#### Ví dụ 3: Kiểm tra số nguyên tố\n\n```python\nnum = 37\nprint(\"Số: \", num)\nfor x in range(2, num):\n   if num % x == 0:\n      print(\"{} không phải là số nguyên tố\".format(num))\n      break\nelse:\n   print(\"{} là số nguyên tố\".format(num))\n```\n\nKết quả khi chạy mã trên sẽ là:\n\n```\nSố: 37\n37 là số nguyên tố\n```\n\nGán các giá trị khác cho num để kiểm tra xem nó có phải là số nguyên tố hay không.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 40,
        "fields": {
            "name": "Bài 10.2. Python continue Statement",
            "content": "# Bài 10.2. Python continue Statement\n\nCâu lệnh `continue` trong Python được sử dụng để bỏ qua việc thực thi của khối mã và trả lại quyền điều khiển cho đầu vòng lặp hiện tại để bắt đầu vòng lặp tiếp theo. Khi gặp phải, vòng lặp bắt đầu vòng lặp tiếp theo mà không thực thi các câu lệnh còn lại trong vòng lặp hiện tại.\n\nCâu lệnh `continue` có thể được sử dụng cả trong vòng lặp while và for.\n\n### Cú pháp của câu lệnh continue\n\n```python\ncontinue\n```\n\n### Ví dụ về câu lệnh continue\n\nBây giờ chúng ta hãy xem một ví dụ để hiểu cách câu lệnh continue hoạt động trong Python −\n\n```python\nfor letter in 'Python': # Ví dụ 1\n   if letter == 'h':\n      continue\n   print ('Chữ hiện tại :', letter)\n\nvar = 10 # Ví dụ 2\nwhile var > 0:\n   var = var -1\n   if var == 5:\n      continue\n   print ('Giá trị biến hiện tại :', var)\nprint (\"Tạm biệt!\")\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra kết quả như sau:\n\n```\nChữ hiện tại : P\nChữ hiện tại : y\nChữ hiện tại : t\nChữ hiện tại : o\nChữ hiện tại : n\nGiá trị biến hiện tại : 9\nGiá trị biến hiện tại : 8\nGiá trị biến hiện tại : 7\nGiá trị biến hiện tại : 6\nGiá trị biến hiện tại : 4\nGiá trị biến hiện tại : 3\nGiá trị biến hiện tại : 2\nGiá trị biến hiện tại : 1\nGiá trị biến hiện tại : 0\nTạm biệt!\n```\n\n### Sử dụng câu lệnh continue trong vòng lặp while trong Python\n\nCâu lệnh `continue` trong Python được sử dụng cả trong vòng lặp `for` cũng như vòng lặp `while` để bỏ qua việc thực thi của vòng lặp hiện tại và chuyển quyền điều khiển của chương trình sang vòng lặp tiếp theo.\n\n#### Ví dụ: Kiểm tra các ước số nguyên tố\n\nĐoạn mã sau sử dụng `continue` để tìm các ước số nguyên tố của một số được cung cấp. Để tìm các ước số nguyên tố, chúng ta cần lặp lại việc chia số đã cho bắt đầu từ 2, tăng giá trị của ước số và tiếp tục quá trình tương tự cho đến khi đầu vào giảm xuống còn 1.\n\nThuật toán để tìm các ước số nguyên tố như sau:\n\n- Chấp nhận đầu vào từ người dùng (n)\n- Đặt ước số (d) thành 2\n- Thực hiện các bước sau cho đến khi n>1:\n  - Kiểm tra xem số đã cho (n) có chia hết cho ước số (d) hay không.\n  - Nếu n%d==0:\n    - In dưới dạng một ước số\n    - Đặt giá trị mới của n là n/d\n    - Tiếp tục từ bước 4\n  - Nếu không:\n    - Tăng giá trị của d lên 1\n    - Tiếp tục từ bước 3\n\nDưới đây là đoạn mã Python cho mục đích đó:\n\n```python\nnum = 60\nprint (\"Các ước số nguyên tố cho: \", num)\nd = 2\nwhile num > 1:\n   if num % d == 0:\n      print (d)\n      num = num / d\n      continue\n   d = d + 1\n```\n\nKhi thực thi, mã này sẽ tạo ra kết quả sau:\n\n```\nCác ước số nguyên tố cho: 60\n2\n2\n3\n5\n```\n\nGán các giá trị khác (ví dụ: 75) cho num trong chương trình trên và kiểm tra kết quả cho các ước số nguyên tố của nó.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 41,
        "fields": {
            "name": "Bài 11. Python pass Statement",
            "content": "# Bài 11. Python pass Statement\n\nCâu lệnh `pass` trong Python được sử dụng khi một câu lệnh được yêu cầu cú pháp nhưng bạn không muốn bất kỳ lệnh hoặc mã nào được thực thi.\n\nĐây là một phép thực thi trống; không có gì xảy ra khi nó được thực thi. Câu lệnh `pass` trong Python cũng hữu ích ở những nơi mà mã của bạn sẽ cuối cùng đi, nhưng chưa được viết, tức là, trong các phần còn thiếu).\n\n### Cú pháp của câu lệnh pass\n\n```python\npass\n```\n\n### Ví dụ về câu lệnh pass\n\nĐoạn mã dưới đây cho thấy cách bạn có thể sử dụng câu lệnh pass trong Python:\n\n```python\nfor letter in 'Python':\n   if letter == 'h':\n      pass\n      print ('Đây là khối pass')\n   print ('Chữ hiện tại :', letter)\nprint (\"Tạm biệt!\")\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra kết quả sau:\n\n```\nChữ hiện tại : P\nChữ hiện tại : y\nChữ hiện tại : t\nĐây là khối pass\nChữ hiện tại : h\nChữ hiện tại : o\nChữ hiện tại : n\nTạm biệt!\n```\n\n### Vòng lặp vô hạn đơn giản với câu lệnh pass\n\nĐiều này đơn giản đủ để tạo ra một vòng lặp vô hạn bằng câu lệnh pass. Ví dụ, nếu bạn muốn viết một vòng lặp vô hạn mà không làm gì cả, hãy làm điều đó bằng một pass.\n\n#### Ví dụ\n\n```python\nwhile True: pass                  # Nhấn Ctrl-C để dừng\n```\n\nVì thân của vòng lặp chỉ là một câu lệnh trống, Python bị kẹt trong vòng lặp này. Như đã giải thích trước đó, pass là gần như với các câu lệnh như None là với các đối tượng — một điều rõ ràng không làm gì cả.\n\n### Sử dụng dấu ba chấm ... làm lựa chọn thay thế cho câu lệnh pass\n\nPython 3.X cho phép sử dụng dấu ba chấm được mã hóa dưới dạng ba dấu chấm liên tiếp `...` để thay thế cho câu lệnh pass. Dấu ba chấm này có thể phục vụ như một lựa chọn cho câu lệnh pass.\n\n#### Ví dụ\n\nVí dụ, nếu chúng ta tạo một hàm không làm gì đặc biệt để mã sau này điền vào, thì chúng ta có thể sử dụng `...`:\n\n```python\ndef func1():\n    ...                   # Thay thế cho pass\n\ndef func2(): ...          # Hoạt động trên cùng một dòng\n\nfunc1()                   # Không làm gì nếu được gọi\nfunc2()                   # Không làm gì nếu được gọi\n```\n\nCâu lệnh trên khi được gọi không làm gì cả.",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 42,
        "fields": {
            "name": "Bài 12. Python Nested Loops",
            "content": "# Bài 12. Python Nested Loops\n\nTrong Python, khi bạn viết một hoặc nhiều vòng lặp trong một câu lệnh vòng lặp đó được gọi là vòng lặp lồng nhau. Vòng lặp chính được coi là vòng lặp bên ngoài và các vòng lặp bên trong vòng lặp bên ngoài được gọi là các vòng lặp bên trong.\n\nNgôn ngữ lập trình Python cho phép sử dụng một vòng lặp bên trong một vòng lặp khác. Phần sau sẽ mô tả một số ví dụ để minh họa khái niệm vòng lặp lồng nhau với vòng lặp for và vòng lặp while.\n\n## Python Nested for Loop\n\nVòng lặp for có một hoặc nhiều vòng lặp for bên trong được gọi là vòng lặp for lồng nhau.\n\n### Cú pháp vòng lặp for lồng nhau trong Python\n\nCú pháp cho câu lệnh vòng lặp for lồng nhau trong ngôn ngữ lập trình Python như sau −\n\n```python\nfor biến_lặp_ngoài in chuỗi:\n   for biến_lặp_trong in chuỗi:\n      câu_lệnh(s)\n   câu_lệnh(s)\n```\n\n### Ví dụ về vòng lặp for lồng nhau trong Python\n\nChương trình sau sử dụng một vòng lặp for lồng nhau để tìm các số nguyên tố từ 2 đến 100 −\n\n```python\nmonths = [\"jan\", \"feb\", \"mar\"]\ndays = [\"sun\", \"mon\", \"tue\"]\n\nfor x in months:\n  for y in days:\n    print(x, y)\n\nprint(\"Good bye!\")\n```\n\nKhi mã trên được thực thi, nó tạo ra kết quả như sau:\n\n```\n('jan', 'sun')\n('jan', 'mon')\n('jan', 'tue')\n('feb', 'sun')\n('feb', 'mon')\n('feb', 'tue')\n('mar', 'sun')\n('mar', 'mon')\n('mar', 'tue')\nGood bye!\n```\n\n## Python Nested while Loop\n\nVòng lặp while có một hoặc nhiều vòng lặp while bên trong được gọi là vòng lặp while lồng nhau.\n\n### Cú pháp vòng lặp while lồng nhau trong Python\n\nCú pháp cho câu lệnh vòng lặp while lồng nhau trong ngôn ngữ lập trình Python như sau −\n\n```python\nwhile biểu_thức:\n   while biểu_thức:\n      câu_lệnh(s)\n   câu_lệnh(s)\n```\n\nMột lưu ý cuối cùng về việc lồng nhau các vòng lặp là bạn có thể đặt bất kỳ loại vòng lặp nào bên trong bất kỳ loại vòng lặp nào khác. Ví dụ, một vòng lặp for có thể nằm trong một vòng lặp while hoặc ngược lại.\n\n### Ví dụ về vòng lặp while lồng nhau trong Python\n\nChương trình sau sử dụng một vòng lặp while lồng nhau để tìm các số nguyên tố từ 2 đến 100 −\n\n```python\ni = 2\nwhile(i < 100):\n   j = 2\n   while(j <= (i/j)):\n      if not(i%j): break\n      j = j + 1\n   if (j > i/j):\n      print(i, \" is prime\")\n   i = i + 1\n\nprint(\"Good bye!\")\n```\n\nKhi mã trên được thực thi, nó tạo ra kết quả như sau:\n\n```\n2 is prime\n3 is prime\n5 is prime\n7 is prime\n11 is prime\n13 is prime\n17 is prime\n19 is prime\n23 is prime\n29 is prime\n31 is prime\n37 is prime\n41 is prime\n43 is prime\n47 is prime\n53 is prime\n59 is prime\n61 is prime\n67 is prime\n71 is prime\n73 is prime\n79 is prime\n83 is prime\n89 is prime\n97 is prime\nGood bye!\n```\n\nĐó là một bài toán phổ biến khi học về vòng lặp lồng nhau trong Python. Chúc bạn thành công!",
            "lesson": 2,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 43,
        "fields": {
            "name": "Bài 0. Hàm trong Python",
            "content": "# Bài 0. Hàm trong Python\n\nTrong Python, một hàm là một khối mã có tổ chức, có thể tái sử dụng được, được sử dụng để thực hiện một hành động duy nhất, liên quan. Các hàm cung cấp tính tách biệt tốt hơn cho ứng dụng của bạn và một mức độ cao của việc tái sử dụng mã.\n\nMột phương pháp từ trên xuống để xây dựng logic xử lý liên quan đến việc định nghĩa các khối hàm tái sử dụng độc lập. Một hàm Python có thể được gọi từ bất kỳ hàm nào khác bằng cách chuyển dữ liệu cần thiết (gọi là tham số hoặc đối số). Hàm gọi trả về kết quả của nó lại cho môi trường gọi.\n\n![image](../../../assets/function/OIG4.jpg)\n\n## Loại hàm trong Python\n\nPython cung cấp các loại hàm sau:\n\n1. Hàm được tích hợp sẵn.\n2. Hàm được định nghĩa trong các mô-đun được tích hợp sẵn.\n3. Hàm do người dùng tự định nghĩa.\n\nThư viện tiêu chuẩn của Python bao gồm một số hàm được tích hợp sẵn. Một số hàm được tích hợp sẵn trong Python là print(), int(), len(), sum(), v.v. Những hàm này luôn có sẵn, vì chúng được tải vào bộ nhớ máy tính ngay khi bạn bắt đầu trình thông dịch Python.\n\nThư viện tiêu chuẩn cũng đóng gói một số mô-đun. Mỗi mô-đun xác định một nhóm các hàm. Những hàm này không sẵn có ngay lập tức. Bạn cần phải nhập chúng vào bộ nhớ từ các mô-đun tương ứng của họ.\n\nNgoài các hàm được tích hợp sẵn và các hàm trong các mô-đun được tích hợp sẵn, bạn cũng có thể tạo ra các hàm của riêng bạn. Những hàm này được gọi là hàm do người dùng tự định nghĩa.\n\n## Định nghĩa một hàm Python\n\nBạn có thể định nghĩa các hàm tùy chỉnh để cung cấp chức năng cần thiết. Dưới đây là các quy tắc đơn giản để định nghĩa một hàm trong Python:\n\n- Khối hàm bắt đầu với từ khóa def tiếp theo là tên hàm và dấu ngoặc đơn ().\n- Bất kỳ tham số đầu vào hoặc đối số nào cũng phải được đặt trong các dấu ngoặc đơn này. Bạn cũng có thể định nghĩa các tham số bên trong các dấu ngoặc đơn này.\n- Câu lệnh đầu tiên của một hàm có thể là một câu lệnh tùy chọn; chuỗi tài liệu của hàm hoặc docstring.\n- Khối mã bên trong mỗi hàm bắt đầu bằng một dấu hai chấm (:) và được thụt lề.\n- Câu lệnh return [biểu thức] kết thúc một hàm, tùy chọn truyền lại một biểu thức cho người gọi. Một câu lệnh return không có đối số tương đương với return None.\n\n### Cú pháp để Định nghĩa một Hàm Python\n\n```python\ndef tên_hàm(tham_số):\n   \"chuỗi_tài_liệu_hàm\"\n   khối_mã_hàm\n   return [biểu_thức]\n```\n\nMặc định, các tham số có hành vi vị trí và bạn cần thông báo cho chúng theo cùng một thứ tự mà chúng đã được định nghĩa.\n\nSau khi hàm được định nghĩa, bạn có thể thực thi nó bằng cách gọi nó từ một hàm khác hoặc trực tiếp từ dấu nhắc Python.\n\n### Ví dụ về Định nghĩa một Hàm Python\n\nDưới đây là một ví dụ về cách định nghĩa một hàm greetings(). Dấu ngoặc đơn là trống nên không có tham số nào.\n\nDòng đầu tiên là chuỗi tài liệu. Khối hàm kết thúc bằng câu lệnh return. khi hàm này được gọi, thông báo Hello World sẽ được in ra.\n\n```python\ndef greetings():\n   \"Đây là chuỗi tài liệu của hàm greetings\"\n   print(\"Hello World\")\n   return\n\ngreetings()\n```\n\n## Gọi một Hàm Python\n\nĐịnh nghĩa một hàm chỉ đưa ra tên cho nó, xác định các tham số cần được bao gồm trong hàm và cấu trúc các khối mã.\n\nKhi cấu trúc cơ bản của một hàm được hoàn thành, bạn có thể thực thi nó bằng cách gọi nó từ một hàm khác hoặc trực tiếp từ dấu nhắc Python.\n\n### Ví dụ về Gọi một Hà\n\nm Python\n\nDưới đây là ví dụ về cách gọi hàm printme():\n\n```python\n# Định nghĩa hàm ở đây\ndef printme(str):\n   \"Hàm này in chuỗi đã được truyền vào\"\n   print(str)\n   return;\n\n# Bây giờ bạn có thể gọi hàm printme\nprintme(\"Đây là cuộc gọi đầu tiên đến hàm được xác định bởi người dùng!\")\nprintme(\"Lần gọi thứ hai đến cùng một hàm\")\n```\n\nKhi mã trên được thực thi, nó sẽ tạo ra đầu ra sau:\n\n```\nĐây là cuộc gọi đầu tiên đến hàm được xác định bởi người dùng!\nLần gọi thứ hai đến cùng một hàm\n```\n\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 44,
        "fields": {
            "name": "Bài 1. Python - Tham số Mặc định",
            "content": "# Bài 1. Python - Tham số Mặc định\n\nTrong Python, bạn có thể định nghĩa một hàm với giá trị mặc định được gán cho một hoặc nhiều đối số hình thức. Python sử dụng giá trị mặc định cho đối số đó nếu không có giá trị nào được truyền vào. Nếu có bất kỳ giá trị nào được truyền, giá trị mặc định sẽ bị ghi đè bằng giá trị thực tế được truyền vào.\n\nTham số mặc định trong Python là các đối số hàm sẽ được sử dụng nếu không có đối số nào được truyền vào cuộc gọi hàm.\nVí dụ về Tham số Mặc định\n```python\n# Định nghĩa hàm ở đây\ndef printinfo(name, age=35):\n   \"In ra thông tin đã được truyền vào hàm này\"\n   print(\"Name: \", name)\n   print(\"Age \", age)\n   return\n\n# Bây giờ bạn có thể gọi hàm printinfo\nprintinfo(age=50, name=\"miki\")\nprintinfo(name=\"miki\")\n```\nKết quả sẽ là:\n\n```\nName: miki\nAge 50\nName: miki\nAge 35\n```\nTrong ví dụ trên, cuộc gọi thứ hai đến hàm không truyền giá trị cho đối số tuổi (age), do đó giá trị mặc định của nó là 35.\n\nHãy xem một ví dụ khác trong đó gán giá trị mặc định cho một đối số hàm. Hàm percent() được định nghĩa như sau:\n\n```python\ndef percent(phy, maths, maxmarks=200):\n   val = (phy+maths)*100/maxmarks\n   return val\n```\nGiả sử điểm cho mỗi môn là trên 100, đối số maxmarks được thiết lập là 200. Do đó, chúng ta có thể bỏ qua giá trị của đối số thứ ba khi gọi hàm percent().\n\n```python\nphy = 60\nmaths = 70\nresult = percent(phy, maths)\n```\n\nTuy nhiên, nếu số điểm tối đa cho mỗi môn không phải là 100, chúng ta cần đưa ra đối số thứ ba khi gọi hàm percent().\n\n```python\nphy = 40\nmaths = 46\nresult = percent(phy, maths, 100)\n```\n\n### Ví dụ: Gọi Hàm Không Sử Dụng Tham số Từ Khóa\n\nDưới đây là ví dụ hoàn chỉnh:\n\n```python\ndef percent(phy, maths, maxmarks=200):\n   val = (phy+maths)*100/maxmarks\n   return val\n\nphy = 60\nmaths = 70\nresult = percent(phy, maths)\nprint(\"Phần trăm:\", result)\n\nphy = 40\nmaths = 46\nresult = percent(phy, maths, 100)\nprint(\"Phần trăm:\", result)\n```\n\nKết quả sẽ là:\n\n```\nPhần trăm: 65.0\nPhần trăm: 86.0\n```\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 45,
        "fields": {
            "name": "Bài 2. Python - Tham số từ khóa",
            "content": "# Bài 2. Python - Tham số từ khóa\n\nTrong Python, bạn có thể truyền các đối số hàm dưới dạng từ khóa còn được gọi là đối số được đặt tên. Các biến trong định nghĩa hàm được sử dụng như từ khóa. Khi gọi hàm, bạn có thể rõ ràng đề cập đến tên và giá trị của nó.\n\n### Ví dụ về Tham số từ khóa\n\n```python\n# Định nghĩa hàm ở đây\ndef printinfo(name, age):\n   \"In ra thông tin đã được truyền vào hàm này\"\n   print(\"Name: \", name)\n   print(\"Age \", age)\n   return\n\n# Bây giờ bạn có thể gọi hàm printinfo\n# bằng các đối số vị trí\nprintinfo(\"Naveen\", 29)\n\n# bằng các đối số từ khóa\nprintinfo(name=\"miki\", age=30)\n```\n\nKết quả sẽ là:\n\n```\nName: Naveen\nAge 29\nName: miki\nAge 30\n```\n\nTheo mặc định, hàm gán các giá trị cho các đối số theo thứ tự xuất hiện. Trong cuộc gọi hàm thứ hai, chúng ta đã gán giá trị cho một đối số cụ thể.\n\n### Gọi Hàm với Tham số từ khóa\n\nThay vì truyền các giá trị với các đối số vị trí, hãy gọi hàm với các đối số từ khóa.\n\n### Ví dụ\n\n```python\ndivision(num=10, den=5)\ndivision(den=5, num=10)\n```\n\nKết quả sẽ là:\n\n```\nnum:10 den:5 quotient:2.0\nnum:10 den:5 quotient:2.0\n```\n\n### Thứ tự của Tham số từ khóa\n\nKhi sử dụng các tham số từ khóa, không cần thiết phải tuân theo thứ tự của các đối số hình thức trong định nghĩa hàm.\n\nViệc sử dụng các tham số từ khóa là tùy chọn. Bạn có thể sử dụng cách gọi kết hợp. Bạn có thể truyền giá trị cho một số đối số mà không cần từ khóa và cho những đối số khác với từ khóa.\n\nTuy nhiên, các đối số vị trí phải đứng trước các đối số từ khóa khi sử dụng cách gọi kết hợp.\n\n### Thử gọi hàm division() với câu lệnh sau:\n\n```python\ndef division(num, den):\n   quotient = num/den\n   print(\"num:{} den:{} quotient:{}\".format(num, den, quotient))\n\ndivision(num=5, 10)\n```\n\nVì đối số vị trí không thể xuất hiện sau các đối số từ khóa, Python sẽ tạo ra thông báo lỗi như sau:\n\n```\n    division(num=5, 10)\n                      ^\nSyntaxError: non-keyword arg after keyword arg\n```\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 46,
        "fields": {
            "name": "Bài 3. Python - Tham số chỉ từ khóa",
            "content": "# Bài 3. Python - Tham số chỉ từ khóa\n\nBạn có thể sử dụng các biến trong danh sách đối số hình thức như các từ khóa để truyền giá trị. Việc sử dụng các đối số từ khóa là tùy chọn. Nhưng, bạn có thể buộc hàm chỉ nhận các đối số dưới dạng từ khóa. Bạn nên đặt một dấu * trước danh sách các đối số chỉ từ khóa.\n\nGiả sử chúng ta có một hàm với ba đối số, trong đó chúng ta muốn đối số thứ hai và thứ ba chỉ được chấp nhận dưới dạng từ khóa. Để làm điều đó, đặt * sau đối số đầu tiên.\n\n### Ví dụ về Tham số chỉ từ khóa\n\nHàm print() được tích hợp sẵn là một ví dụ về các đối số chỉ từ khóa. Bạn có thể đưa ra danh sách các biểu thức cần in trong dấu ngoặc đơn. Các giá trị được in sẽ được phân tách bằng một khoảng trắng theo mặc định. Bạn cũng có thể chỉ định bất kỳ ký tự phân tách nào khác thay thế bằng đối số sep.\n\n```python\nprint(\"Hello\", \"World\", sep=\"-\")\n```\n\nNó sẽ in ra:\n\n```\nHello-World\n```\n\n### Ví dụ: Sử dụng Đối số sep trong phương thức print()\n\nĐối số sep là đối số chỉ từ khóa. Hãy thử sử dụng nó như một đối số không phải từ khóa.\n\n```python\nprint(\"Hello\", \"World\", \"-\")\n```\n\nBạn sẽ nhận được đầu ra khác - không như mong muốn.\n\n```\nHello World -\n```\n\n### Ví dụ: Sử dụng Tham số chỉ từ khóa với Phương thức Tự định nghĩa\n\nTrong hàm người dùng đã xác định intr() với hai đối số, amt và rate. Để làm cho đối số rate chỉ dưới dạng từ khóa, đặt \"*\" trước nó.\n\n```python\ndef intr(amt, *, rate):\n   val = amt * rate / 100\n   return val\n```\n\nĐể gọi hàm này, giá trị cho rate phải được truyền theo từ khóa.\n\n```python\ninterest = intr(1000, rate=10)\n```\n\nTuy nhiên, nếu bạn cố gắng sử dụng cách gọi hàm mặc định theo vị trí, bạn sẽ nhận được một lỗi.\n\n```python\ninterest = intr(1000, 10)\n# TypeError: intr() takes 1 positional argument but 2 were given\n```\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 47,
        "fields": {
            "name": "Bài 4. Python - Đối số theo Vị trí",
            "content": "# Bài 4. Python - Đối số theo Vị trí\n\nDanh sách các biến được khai báo trong dấu ngoặc đơn tại thời điểm định nghĩa một hàm là các đối số hình thức. Một hàm có thể được định nghĩa với bất kỳ số lượng đối số hình thức nào.\n\nKhi gọi một hàm:\n\n- Tất cả các đối số là bắt buộc\n- Số lượng đối số thực phải bằng số lượng đối số hình thức.\n- Các đối số hình thức là vị trí. Chúng nhận các giá trị theo thứ tự được định nghĩa.\n- Kiểu của các đối số phải khớp nhau.\n- Tên của các đối số hình thức và thực tế không cần phải giống nhau.\n\n### Ví dụ về Đối số theo Vị trí\n\n```python\ndef add(x, y):\n   z = x + y\n   print(\"x={} y={} x+y={}\".format(x, y, z))\n\na = 10\nb = 20\nadd(a, b)\n```\n\nKết quả sẽ là:\n\n```\nx=10 y=20 x+y=30\n```\n\nỞ đây, hàm add() có hai đối số hình thức, cả hai đều là số. Khi các số nguyên 10 và 20 được truyền vào. Biến a lấy giá trị 10 và b lấy giá trị 20, theo thứ tự được khai báo. Hàm add() hiển thị tổng.\n\nPython cũng sẽ tạo ra lỗi khi số lượng đối số không khớp. Hãy chỉ đưa ra một đối số và kiểm tra kết quả.\n\n```\nadd(b)\nTypeError: add() missing 1 required positional argument: 'y'\n```\n\nHãy truyền nhiều hơn số lượng đối số hình thức và kiểm tra kết quả −\n\n```\nadd(10, 20, 30)\nTypeError: add() takes 2 positional arguments but 3 were given\n```\n\nKiểu dữ liệu của các đối số thực và hình thức tương ứng phải khớp nhau. Thay đổi a thành một giá trị chuỗi và kiểm tra kết quả.\n\n```python\na = \"Hello\"\nb = 20\nadd(a, b)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```\nz = x + y\n    ~^~\nTypeError: can only concatenate str (not \"int\") to str\n```\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 48,
        "fields": {
            "name": "Bài 5. Python - Đối số Tùy ý",
            "content": "# Bài 5. Python - Đối số Tùy ý\n\nCó thể bạn muốn định nghĩa một hàm có thể chấp nhận số lượng đối số tùy ý hoặc biến. Hơn nữa, số lượng đối số tùy ý có thể là đối số theo vị trí hoặc từ khóa.\n\nMột đối số được tiền tố bằng một dấu sao (*) cho các đối số theo vị trí tùy ý.\n\nMột đối số được tiền tố bằng hai dấu sao (**) cho các đối số từ khóa tùy ý.\n\n### Ví dụ về Đối số Tùy ý\n\nDưới đây là một ví dụ về đối số tùy ý hoặc biến chiều dài theo vị trí −\n\n```python\n# Tổng các số\ndef add(*args):\n   s = 0\n   for x in args:\n      s += x\n   return s\n\nresult = add(10, 20, 30, 40)\nprint(result)\n\nresult = add(1, 2, 3)\nprint(result)\n```\n\nBiến args được tiền tố bằng \"*\" lưu trữ tất cả các giá trị được truyền cho nó. Ở đây, args trở thành một tuple. Chúng ta có thể chạy một vòng lặp qua các mục của nó để cộng các số.\n\nKết quả sẽ là:\n\n```\n100\n6\n```\n\n### Đối số Bắt Buộc Với Đối số Tùy ý\n\nCũng có thể có một hàm với một số đối số bắt buộc trước dãy số lượng biến giá trị.\n\n### Ví dụ\n\n```python\n# Trung bình của bài kiểm tra đầu tiên và tốt nhất của các bài kiểm tra tiếp theo\ndef avg(first, *rest):\n   second = max(rest)\n   return (first + second) / 2\n\nresult = avg(40, 30, 50, 25)\nprint(result)\n```\n\nCuộc gọi sau đến hàm avg() truyền giá trị đầu tiên cho đối số bắt buộc đầu tiên, và các giá trị còn lại cho một tuple có tên là rest. Sau đó, chúng ta tìm giá trị tối đa và sử dụng nó để tính trung bình.\n\nKết quả sẽ là:\n\n```\n45.0\n```\n\n### Đối số Tùy ý Từ Khóa (**kwargs)\n\nNếu một biến trong danh sách đối số có hai dấu sao (*) được tiền tố cho nó, hàm có thể chấp nhận số lượng đối số từ khóa tùy ý. Biến trở thành một từ điển các cặp từ khóa: giá trị.\n\n### Ví dụ\n\nDưới đây là một ví dụ về một hàm với các đối số từ khóa tùy ý. Hàm addr() có một đối số **kwargs có thể chấp nhận bất kỳ số lượng phần tử địa chỉ nào như tên, thành phố, số điện thoại, mã pin, v.v. Bên trong hàm, từ điển kwargs của các cặp khóa từ khóa: giá trị được duyệt qua sử dụng phương thức items().\n\n```python\ndef addr(**kwargs):\n   for k, v in kwargs.items():\n      print(\"{}:{}\".format(k, v))\n\nprint(\"pass two keyword args\")\naddr(Name=\"John\", City=\"Mumbai\")\nprint(\"pass four keyword args\")\n\n# pass four keyword args\naddr(Name=\"Raam\", City=\"Mumbai\", ph_no=\"9123134567\", PIN=\"400001\")\n```\n\nKết quả sẽ là:\n\n```\npass two keyword args\nName:John\nCity:Mumbai\npass four keyword args\nName:Raam\nCity:Mumbai\nph_no:9123134567\nPIN:400001\n```\n\n### Nhiều Đối số Với Đối số Tùy ý Từ Khóa\n\nNếu hàm sử dụng các loại đối số kết hợp, các đối số từ khóa tùy ý phải đứng sau các đối số theo vị trí, theo từ khóa và các đối số theo vị trí tùy ý trong danh sách đối số.\n\n### Ví dụ\n\nHãy tưởng tượng một trường hợp trong đó môn khoa học và toán học là bắt buộc, ngoài ra học sinh có thể chọn bất kỳ số lượng môn học tự chọn nào.\n\nDưới đây là định nghĩa của một hàm percent() trong đó điểm số trong khoa học và điểm số được lưu trữ trong các đối số tùy ý **optional.\n\n```python\ndef percent(math, sci, **optional):\n   print(\"maths:\", math)\n   print(\"sci:\", sci)\n   s = math + sci\n   for k, v in optional.items():\n      print(\"{}:{}\".format(k, v))\n      s += v\n   return s / (len(optional) + 2)\n\nresult = percent(math=80, sci=75, Eng=70, Hist=65, Geo=72)\nprint(\"percentage:\", result)\n```\n\nKết quả sẽ là:\n\n```\nmaths: 80\nsci: 75\nEng:70\nHist:65\nGeo:72\npercentage: 72.4\n```\n",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 49,
        "fields": {
            "name": "Bài 6. Python - Phạm vi Biến",
            "content": "# Bài 6. Python - Phạm vi Biến\n\nMột biến trong Python là tên biểu tượng cho đối tượng trong bộ nhớ máy tính. Python hoạt động dựa trên khái niệm về không gian tên để xác định ngữ cảnh cho các định danh khác nhau như các hàm, biến, v.v. Một không gian tên là một tập hợp các tên biểu tượng được xác định trong ngữ cảnh hiện tại.\n\nPython cung cấp các loại không gian tên sau:\n\n- **Không gian tên tích hợp** chứa các hàm tích hợp và các ngoại lệ tích hợp. Chúng được tải vào bộ nhớ ngay khi trình thông dịch Python được tải và tồn tại cho đến khi trình thông dịch đang chạy.\n  \n- **Không gian tên toàn cục** chứa bất kỳ tên nào được xác định trong chương trình chính. Những tên này tồn tại trong bộ nhớ cho đến khi chương trình đang chạy.\n  \n- **Không gian tên cục bộ** chứa các tên được xác định bên trong một hàm. Chúng có sẵn cho đến khi hàm đang chạy.\n\nCác không gian tên này được lồng vào nhau. Đồ thị sau đây cho thấy mối quan hệ giữa các không gian tên:\n\n```\nGlobals Namespace\n   |\n   |___ Local Namespace\n          |\n          |___ Inner Local Namespace\n```\n\n### Loại của Không gian Tên\n\nTuổi thọ của một biến nhất định được hạn chế trong không gian tên mà nó được xác định. Do đó, không thể truy cập vào một biến có trong không gian tên bên trong từ bất kỳ không gian tên bên ngoài nào.\n\n### Hàm globals() của Python\n\nThư viện chuẩn của Python bao gồm một hàm tích hợp là globals(). Nó trả về một từ điển các biểu tượng hiện có trong không gian tên toàn cục.\n\nChạy hàm globals() trực tiếp từ dấu nhắc Python.\n\n```python\n>>> globals()\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}\n```\n\nCó thể thấy rằng mô-đun builtins chứa các định nghĩa của tất cả các hàm tích hợp và ngoại lệ tích hợp được tải.\n\nLưu mã sau chứa một số biến và một hàm với một số biến nữa bên trong nó.\n\n```python\nname = '8SyncDev'\nmarks = 50\nresult = True\ndef myfunction():\n   a = 10\n   b = 20\n   return a + b\n\nprint(globals())\n```\n\nGọi globals() từ bên trong tập lệnh này sẽ trả về đối tượng từ điển sau:\n\n```python\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x00000169AE265250>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'C:\\\\Users\\\\mlath\\\\examples\\\\main.py', '__cached__': None, 'name': '8SyncDev', 'marks': 50, 'result': True, 'myfunction': <function myfunction at 0x00000169AE2104A0>}\n```\n\nKhông gian tên toàn cục bây giờ chứa các biến trong chương trình và giá trị của chúng cũng như đối tượng hàm trong đó (và không phải là các biến trong hàm).\n\nBất kỳ biến nào được tạo bên ngoài một hàm có thể truy cập trong bất kỳ hàm nào và vì vậy chúng có phạm vi toàn cục. Dưới đây là một ví dụ để hiển thị việc sử dụng biến toàn cục trong Python:\n\n```python\nx = 5\ny = 10\n\ndef sum():\n   total = x + y\n   return total\n\nprint(sum())\n```\n\nĐiều này sẽ tạo ra kết quả sau:\n\n```\n15\n```\n\n### Hàm locals() của Python\n\nThư viện chuẩn của Python cũng bao gồm một hàm tích hợp là locals(). Nó trả về một từ điển các biểu tượng hiện có trong không gian tên cục bộ của hàm.\n\nSửa đổi mã trên để in ra từ điển của không gian tên toàn cục và cục bộ từ bên trong hàm.\n\n```python\nname = '8SyncDev'\nmarks = 50\nresult = True\n\ndef myfunction():\n   a = 10\n   b = 20\n   c = a + b\n   print(\"globals():\", globals())\n   print(\"locals():\", locals())\n   return c\n\nmyfunction()\n```\n\nKết quả sẽ cho thấy locals() trả về một từ điển các biến và giá trị của chúng hiện có trong hàm.\n\n```\nglobals(): {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x00000169AE265250>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'C:\\\\Users\\\\mlath\\\\examples\\\\main.py', '__cached__': None, '\n\nname': '8SyncDev', 'marks': 50, 'result': True, 'myfunction': <function myfunction at 0x00000169AE2104A0>}\nlocals(): {'a': 10, 'b': 20, 'c': 30}\n```\n\nVì cả hai hàm globals() và locals() đều trả về từ điển, bạn có thể truy cập vào giá trị của một biến từ không gian tên tương ứng với phương pháp get() của từ điển hoặc toán tử chỉ mục.\n\n```python\nprint(globals()['name']) # hiển thị 8SyncDev\nprint(locals().get('a')) # hiển thị 10\n```\n\nDưới đây là một ví dụ đơn giản để hiển thị việc sử dụng biến cục bộ trong Python:\n\n```python\ndef sum(x, y):\n   total = x + y\n   return total\n\nprint(sum(5, 10))\n```\n\n```\n15\n```\n\n### Xung đột Phạm vi trong Python\n\nNếu một biến có cùng tên xuất hiện trong phạm vi toàn cục cũng như phạm vi cục bộ, trình thông dịch Python ưu tiên biến trong không gian tên cục bộ.\n\n```python\nmarks = 50 # đây là biến toàn cục\ndef myfunction():\n   marks = 70 # đây là biến cục bộ\n   print(marks)\n   \nmyfunction()\nprint(marks) # in giá trị toàn cục\n```\n\nSẽ tạo ra kết quả sau:\n\n```\n70\n50\n```\n\nNếu bạn cố gắng thay đổi giá trị của một biến toàn cục từ bên trong một hàm, Python sẽ ném ra UnboundLocalError.\n\n```python\nmarks = 50 # đây là biến toàn cục\ndef myfunction():\n   marks = marks + 20\n   print(marks)\n\nmyfunction()\nprint(marks) # in giá trị toàn cục\n```\n\nSẽ tạo ra kết quả sau:\n\n```\n   marks = marks + 20\n           ^^^^^\nUnboundLocalError: cannot access local variable 'marks' where it is not associated with a value\n```\n\nĐể sửa đổi một biến toàn cục, bạn có thể cập nhật nó bằng cú pháp từ điển, hoặc sử dụng từ khóa global để tham chiếu đến nó trước khi sửa đổi.\n\n```python\nvar1 = 50 # đây là biến toàn cục\nvar2 = 60 # đây là biến toàn cục\ndef myfunction():\n   \"Thay đổi giá trị của các biến toàn cục\"\n   globals()['var1'] = globals()['var1'] + 10\n   global var2\n   var2 = var2 + 20\n\nmyfunction()\nprint(\"var1:\", var1, \"var2:\", var2) # hiển thị các biến toàn cục với giá trị đã thay đổi\n```\n\nSẽ tạo ra kết quả sau:\n\n```\nvar1: 60 var2: 80\n```\n\nCuối cùng, nếu bạn cố gắng truy cập vào một biến cục bộ trong phạm vi toàn cục, Python sẽ ném ra NameError vì biến trong phạm vi cục bộ không thể truy cập ở bên ngoài phạm vi đó.\n\n```python\nvar1 = 50 # đây là biến toàn cục\nvar2 = 60 # đây là biến toàn cục\ndef myfunction(x, y):\n   total = x + y\n   print(\"Total là biến cục bộ: \", total)\n\nmyfunction(var1, var2)\nprint(total) # Điều này sẽ tạo ra NameError\n```\n\nSẽ tạo ra kết quả sau:\n\n```\nTotal là biến cục bộ: 110\nTraceback (most recent call last):\n   File \"C:\\Users\\user\\examples\\main.py\", line 9, in <module>\n   print(total) # Điều này sẽ tạo ra NameError\n          ^^^^^\nNameError: name 'total' is not defined\n```",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 50,
        "fields": {
            "name": "Bài 7. Python - Chú thích Hàm",
            "content": "# Bài 7. Python - Chú thích Hàm\n\nTính năng chú thích hàm của Python cho phép bạn thêm các siêu dữ liệu bổ sung về các đối số được khai báo trong định nghĩa hàm và cũng kiểu dữ liệu trả về.\n\nMặc dù bạn có thể sử dụng tính năng docstring của Python để tài liệu hóa một hàm, nhưng nó có thể trở nên lỗi thời nếu có các thay đổi trong nguyên mẫu của hàm. Do đó, tính năng chú thích đã được giới thiệu trong Python là kết quả của PEP 3107.\n\nCác chú thích không được Python thông dịch viên xem xét khi thực thi hàm. Chúng chủ yếu dành cho các IDE Python để cung cấp tài liệu chi tiết cho người lập trình.\n\nChú thích là bất kỳ biểu thức Python hợp lệ nào được thêm vào các đối số hoặc kiểu dữ liệu trả về. Ví dụ đơn giản nhất của chú thích là quy định kiểu dữ liệu của các đối số. Chú thích được đề cập như là một biểu thức sau khi đặt dấu hai chấm trước đối số.\n\n```python\ndef myfunction(a: int, b: int):\n   c = a + b\n   return c\n```\n\nHãy nhớ rằng Python là một ngôn ngữ được gán động, và không thực hiện bất kỳ kiểm tra kiểu nào tại thời gian chạy. Do đó, việc chú thích các đối số với các kiểu dữ liệu không có bất kỳ hiệu ứng nào khi gọi hàm. Ngay cả khi có các đối số không phải là số nguyên được cung cấp, Python cũng không phát hiện ra lỗi nào.\n\n```python\ndef myfunction(a: int, b: int):\n   c = a + b\n   return c\n\nprint(myfunction(10, 20))\nprint(myfunction(\"Hello \", \"Python\"))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n30\nHello Python\n```\n\n### Chú thích Hàm với Kiểu Trả về\n\nChú thích được bỏ qua vào thời điểm chạy, nhưng hữu ích cho các IDE và các thư viện kiểm tra kiểu tĩnh như mypy.\n\nBạn cũng có thể đưa ra chú thích cho kiểu dữ liệu trả về. Sau dấu ngoặc đơn và trước dấu hai chấm, đặt một mũi tên (->) theo sau là chú thích. Ví dụ:\n\n```python\ndef myfunction(a: int, b: int) -> int:\n   c = a + b\n   return c\n```\n\n### Chú thích Hàm với Biểu thức\n\nVì việc sử dụng kiểu dữ liệu làm chú thích bị bỏ qua vào thời điểm chạy, bạn có thể đặt bất kỳ biểu thức nào làm chú thích để làm siêu dữ liệu cho các đối số. Do đó, hàm có thể có bất kỳ biểu thức tùy ý nào làm chú thích như trong ví dụ sau:\n\n```python\ndef total(x: 'marks in Physics', y: 'marks in Chemistry'):\n   return x + y\n```\n\n### Chú thích Hàm với Đối số Mặc định\n\nNếu bạn muốn chỉ định một đối số mặc định cùng với chú thích, bạn cần đặt nó sau biểu thức chú thích. Đối số mặc định phải đặt sau các đối số bắt buộc trong danh sách đối số.\n\n```python\ndef myfunction(a: \"Physics\", b: \"Maths\" = 20) -> int:\n   c = a + b\n   return c\n\nprint(myfunction(10))\n```\n\n### Thuộc tính __annotations__ của Hàm\n\nHàm trong Python cũng là một đối tượng, và một trong những thuộc tính của nó là __annotations__. Bạn có thể kiểm tra bằng hàm dir().\n\n```python\nprint(dir(myfunction))\n```\n\nĐiều này sẽ in ra danh sách đối tượng myfunction chứa __annotations__ như một trong những thuộc tính.\n\n```python\n['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']\n```\n\nThuộc tính __annotations__ chính là một từ điển trong đó các đối số là các khóa và các chú thích là các giá trị\n\n của chúng.\n\n```python\ndef myfunction(a: \"Physics\", b: \"Maths\" = 20) -> int:\n   c = a + b\n   return c\n\nprint(myfunction.__annotations__)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```python\n{'a': 'Physics', 'b': 'Maths', 'return': <class 'int'>}\n```\n\nBạn có thể có các đối số vị trí tùy ý và/hoặc các đối số từ khóa tùy ý cho một hàm. Chú thích cũng có thể được đưa ra cho chúng.\n\n```python\ndef myfunction(*args: \"arbitrary args\", **kwargs: \"arbitrary keyword args\") -> int:\n   pass\n\nprint(myfunction.__annotations__)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```python\n{'args': 'arbitrary args', 'kwargs': 'arbitrary keyword args', 'return': <class 'int'>}\n```\n\nTrong trường hợp bạn cần cung cấp nhiều hơn một biểu thức chú thích cho một đối số hàm, đặt nó dưới dạng một đối tượng từ điển phía trước đối số đó.\n\n```python\ndef division(num: dict(type=float, msg='numerator'), den: dict(type=float, msg='denominator')) -> float:\n   return num / den\n\nprint(division.__annotations__)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```python\n{'num': {'type': <class 'float'>, 'msg': 'numerator'}, 'den': {'type': <class 'float'>, 'msg': 'denominator'}, 'return': <class 'float'>}\n```",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 51,
        "fields": {
            "name": "Bài 8. Python - Module (Module Python)",
            "content": "# Bài 8. Python - Module (Module Python)\n\n## Giới thiệu về Module Python\n\nTrong Python, module là một tập tin chứa các định nghĩa của các hàm, lớp, biến, hằng số hoặc bất kỳ đối tượng Python nào khác. Nội dung của tập tin này có thể được sử dụng trong bất kỳ chương trình nào khác. Python cung cấp từ khóa `import` để thực hiện điều này.\n\n### Ví dụ về Module Python\n\n```python\nimport math\nprint(\"Căn bậc hai của 100:\", math.sqrt(100))\n```\n\nKết quả:\n\n```\nCăn bậc hai của 100: 10.0\n```\n\n### Các Module Sẵn Có trong Python\n\nThư viện chuẩn của Python đi kèm với một số lượng lớn các module, được gọi là các module sẵn có. Các module này cung cấp các chức năng hữu ích như quản lý hệ điều hành cụ thể, đọc ghi tệp, mạng lưới, v.v.\n\nDưới đây là một số module sẵn có quan trọng:\n\n1. **os**: Cung cấp một giao diện thống nhất cho một số chức năng hệ điều hành.\n2. **string**: Chứa một số hàm để xử lý chuỗi.\n3. **re**: Cung cấp một tập hợp các tính năng biểu thức chính quy mạnh mẽ.\n4. **math**: Thực hiện các phép toán số học cho các số dấu chấm động.\n5. **cmath**: Chứa các phép toán số học cho các số phức.\n6. **datetime**: Cung cấp các hàm để làm việc với ngày tháng và thời gian trong một ngày.\n7. **gc**: Cung cấp một giao diện cho bộ thu gom rác tích hợp.\n8. **asyncio**: Xác định các chức năng cần thiết cho xử lý bất đồng bộ.\n9. **collections**: Cung cấp các loại dữ liệu Container tiên tiến.\n10. **functools**: Có các chức năng bổ sung và các hoạt động trên các đối tượng có thể gọi. Hữu ích trong lập trình hàm.\n\n## Tạo Module Python\n\nTạo một module không gì khác ngoài việc lưu một đoạn mã Python bằng bất kỳ trình soạn thảo nào. Hãy lưu đoạn mã sau dưới dạng `mymodule.py`:\n\n```python\ndef SayHello(name):\n   print (\"Xin chào {}! Bạn có khỏe không?\".format(name))\n   return\n```\n\nBạn có thể nhập `mymodule` trong phiên Python hiện tại:\n\n```python\n>>> import mymodule\n>>> mymodule.SayHello(\"Harish\")\nXin chào Harish! Bạn có khỏe không?\n```\n\nBạn cũng có thể nhập một module trong một tập lệnh Python khác:\n\n```python\nimport mymodule\nmymodule.SayHello(\"Harish\")\n```\n\nChạy tập lệnh này từ dòng lệnh:\n\n```\nC:\\Users\\user\\examples> python example.py\nXin chào Harish! Bạn có khỏe không?\n```\n\n## Câu Lệnh `import`\n\nTrong Python, câu lệnh `import` được cung cấp để tải một đối tượng Python từ một module. Đối tượng có thể là một hàm, lớp, một biến, v.v. Nếu một module chứa nhiều định nghĩa, tất cả đều sẽ được tải vào không gian tên hiện tại.\n\nHãy lưu đoạn mã sau có ba hàm trong `mymodule.py`:\n\n```python\ndef sum(x,y):\n   return x+y\n\ndef average(x,y):\n   return (x+y)/2\n\ndef power(x,y):\n   return x**y\n```\n\nCâu lệnh `import mymodule` tải tất cả các hàm trong module này vào không gian tên hiện tại. Mỗi hàm trong module được nhập là một thuộc tính của đối tượng module này.\n\n```python\nimport mymodule\nprint (\"Tổng:\",mymodule.sum(10,20))\nprint (\"Trung bình:\",mymodule.average(10,20))\nprint\n\n (\"Lũy thừa:\",mymodule.power(10, 2))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTổng: 30\nTrung bình: 15.0\nLũy thừa: 100\n```\n\n## Câu Lệnh `from ... import`\n\nCâu lệnh `import` sẽ tải tất cả các tài nguyên của module vào không gian tên hiện tại. Bạn cũng có thể nhập các đối tượng cụ thể từ một module bằng cú pháp này.\n\nVí dụ, nếu có ba hàm trong `mymodule` và bạn chỉ muốn nhập hai trong số chúng vào `example.py`:\n\n```python\nfrom mymodule import sum, average\nprint (\"Tổng:\",sum(10,20))\nprint (\"Trung bình:\",average(10,20))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nTổng: 30\nTrung bình: 15.0\n```\n\nLưu ý rằng hàm không cần phải được gọi bằng cách thêm tên của module vào trước.\n\n## Câu Lệnh `from...import *`\n\nCũng có thể nhập tất cả các tên từ một module vào không gian tên hiện tại bằng cách sử dụng câu lệnh `from...import *`. Tuy nhiên, cụm từ này nên được sử dụng cẩn thận.\n\n## Câu Lệnh `import ... as`\n\nBạn có thể gán một tên alias cho module được nhập.\n\n```python\nimport mymodule as x\nprint (\"Tổng:\",x.sum(10,20))\nprint (\"Trung bình:\", x.average(10,20))\nprint (\"Lũy thừa:\", x.power(10, 2))\n```\n\n## Thuộc Tính của Module\n\nTrong Python, một module là một đối tượng của lớp module, và do đó nó được đặc trưng bởi các thuộc tính.\n\nDưới đây là các thuộc tính của module:\n\n- `__file__`: Trả về tên vật lý của module.\n- `__package__`: Trả về gói mà module thuộc về.\n- `__doc__`: Trả về chuỗi tài liệu ở đầu module nếu có.\n- `__dict__`: Trả về phạm vi toàn bộ của module.\n- `__name__`: Trả về tên của module.\n\n### Ví dụ\n\nGiả sử đoạn mã sau được lưu dưới dạng `mymodule.py`:\n\n```python\n\"\"\"Chuỗi tài liệu của mymodule\"\"\"\ndef sum(x,y):\n   return x+y\n\ndef average(x,y):\n   return (x+y)/2\n```\n\nHãy kiểm tra các thuộc tính của `mymodule` bằng cách nhập nó vào đoạn mã sau:\n\n```python\nimport mymodule\n\nprint (\"Thuộc tính __file__:\", mymodule.__file__)\nprint (\"Thuộc tính __doc__:\", mymodule.__doc__)\nprint (\"Thuộc tính __name__:\", mymodule.__name__)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nThuộc tính __file__: C:\\Users\\mlath\\examples\\mymodule.py\nThuộc tính __doc__: Chuỗi tài liệu của mymodule\nThuộc tính __name__: mymodule\n```\n\n## Thuộc Tính `__name__`\n\nThuộc tính `__name__` của một module Python có ý nghĩa quan trọng. Hãy khám phá nó chi tiết hơn.\n\nTrong một shell tương tác, thuộc tính `__name__` trả về `'__main__'`:\n\n```python\n>>> __name__\n'__main__'\n```\n\nNếu bạn nhập bất kỳ module nào trong phiên dịch viên, nó sẽ trả về tên của module là thuộc tính `__name__` của module đó.\n\n```python\n>>> import math\n>>> math.__name__\n'math'\n```\n\nTừ bên trong một script Python, thuộc tính `__name__` trả về `'__main__'`:\n\n```python\n#example.py\nprint (\"Thuộc tính __name__ bên trong một script:\", __name__)\n```\n\nChạy điều này trong dòng lệnh:\n\n```\nThuộc tính __name__ bên trong một script: __main__\n```\n\nThuộc tính này cho phép một script Python được sử dụng như là một chương trình thực thi hoặc như một module. Không giống như C++, Java, C# vv, trong Python, không có khái niệm về hàm `main()`. Đoạn mã Python với phần mở rộng `.py` có thể chứa cả định nghĩa hàm cũng như các câu lệnh có thể thực thi.\n\nLưu `mymodule.py` và với đoạn mã sau:\n\n```python\n\"\"\"Chuỗi tài liệu của mymodule\"\"\"\ndef sum(x,y):\n   return x+y\n   \nprint (\"Tổng:\",sum(10,20))\n```\n\nBạn có thể thấy rằng hàm `sum()` được gọi bên trong cùng một script mà nó được định nghĩa.\n\n```\nC:\\Users\\user\\examples> python mymodule.py\nTổng: 30\n```\n\nBây giờ hãy nhập hàm này vào một script khác `example.py`.\n\n```python\nimport mymodule\nprint (\"Tổng:\",mymodule.sum(10,20))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nC:\\Users\\user\\examples> python example.py\nTổng: 30\n```\n\nĐầu ra \"Tổng:30\" xuất hiện hai lần. Một lần khi module `mymodule` được nhập. Các câu lệnh thực thi trong module nhập cũng được chạy. Đầu ra thứ hai là từ script gọ\n\ni, tức là chương trình `example.py`.\n\nĐiều chúng ta muốn xảy ra là khi một module được nhập, chỉ các hàm nên được nhập, các câu lệnh thực thi của nó không được chạy. Điều này có thể được thực hiện bằng cách kiểm tra giá trị của `__name__`. Nếu nó là `__main__`, có nghĩa là nó đang chạy và không phải là import. Bao gồm các câu lệnh thực thi như cuộc gọi hàm một cách điều kiện.\n\nThêm câu lệnh if vào `mymodule.py` như dưới đây:\n\n```python\n\"\"\"Chuỗi tài liệu của mymodule\"\"\"\ndef sum(x,y):\n   return x+y\n\nif __name__ == \"__main__\":\n   print (\"Tổng:\",sum(10,20))\n```\n\nBây giờ nếu bạn chạy chương trình `example.py`, bạn sẽ thấy rằng đầu ra \"Tổng:30\" chỉ xuất hiện một lần.\n\n```\nC:\\Users\\user\\examples> python example.py\nTổng: 30\n```\n\n## Hàm `reload()`\n\nĐôi khi bạn có thể cần tải lại một module, đặc biệt là khi làm việc với phiên dịch viên tương tác của Python.\n\nGiả sử chúng ta có một module test (test.py) với hàm sau:\n\n```python\ndef SayHello(name):\n   print (\"Xin chào {}! Bạn có khỏe không?\".format(name))\n   return\n```\n\nChúng ta có thể nhập module và gọi hàm của nó từ dòng lệnh Python như sau:\n\n```python\n>>> import test\n>>> test.SayHello(\"Deepak\")\nXin chào Deepak! Bạn có khỏe không?\n```\n\nTuy nhiên, giả sử bạn cần sửa đổi hàm SayHello() như sau:\n\n```python\ndef SayHello(name, course):\n   print (\"Xin chào {}! Bạn có khỏe không?\".format(name))\n   print (\"Chào mừng bạn đến với {} Tutorial by 8SyncDev\".format(course))\n   return\n```\n\nNgay cả khi bạn chỉnh sửa tệp test.py và lưu nó, hàm được tải vào bộ nhớ sẽ không cập nhật. Bạn cần phải tải lại nó, sử dụng hàm `reload()` trong module `imp`.\n\n```python\n>>> import imp\n>>> imp.reload(test)\n>>> test.SayHello(\"Deepak\", \"Python\")\nXin chào Deepak! Bạn có khỏe không?\nChào mừng bạn đến với Python Tutorial by 8SyncDev\n```",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 52,
        "fields": {
            "name": "Bài 9. Hàm Built-in Python",
            "content": "# Bài 9. Hàm Built-in Python\n\nTrong phiên bản Python 3.12.2, có tổng cộng 71 hàm Built-in. Dưới đây là danh sách các hàm Built-in cùng với mô tả:\n\n### Hàm Tiêu Biểu:\n\n1. `abs()`: Trả về giá trị tuyệt đối của một số.\n2. `all()`: Trả về True khi tất cả các phần tử trong iterable là True.\n3. `any()`: Kiểm tra xem có bất kỳ phần tử nào trong iterable nào đó là True không.\n4. `bin()`: Chuyển đổi số nguyên thành chuỗi nhị phân.\n5. `bool()`: Chuyển đổi một giá trị thành Boolean.\n6. `bytes()`: Trả về đối tượng bytes không thay đổi.\n7. `callable()`: Kiểm tra xem đối tượng có thể gọi được không.\n8. `chr()`: Trả về ký tự từ một số nguyên.\n9. `classmethod()`: Trả về phương thức lớp cho hàm đã cho.\n10. `compile()`: Trả về một đối tượng mã.\n11. `complex()`: Tạo một số phức.\n12. `delattr()`: Xóa thuộc tính khỏi đối tượng.\n13. `dict()`: Tạo một từ điển.\n14. `dir()`: Cố gắng trả về các thuộc tính của đối tượng.\n15. `divmod()`: Trả về một bộ chia lấy dư.\n16. `enumerate()`: Trả về một đối tượng liệt kê.\n17. `eval()`: Chạy mã trong chương trình.\n18. `exec()`: Thực thi chương trình được tạo ra động.\n19. `filter()`: Xây dựng bộ lặp từ các phần tử đúng.\n20. `float()`: Trả về số dấu phẩy động từ số hoặc chuỗi.\n21. `format()`: Trả về biểu diễn đã định dạng của một giá trị.\n22. `frozenset()`: Trả về đối tượng frozenset không thay đổi.\n23. `getattr()`: Trả về giá trị của thuộc tính được đặt tên của một đối tượng.\n24. `globals()`: Trả về từ điển của bảng ký hiệu toàn cục hiện tại.\n25. `hasattr()`: Trả về xem đối tượng có thuộc tính được đặt tên hay không.\n26. `hash()`: Trả về giá trị hash của một đối tượng.\n27. `help()`: Kích hoạt Hệ thống Trợ giúp tích hợp.\n28. `hex()`: Chuyển đổi số nguyên thành chuỗi thập lục phân.\n29. `id()`: Trả về định danh của một đối tượng.\n30. `input()`: Đọc và trả về một dòng chuỗi.\n31. `int()`: Trả về số nguyên từ một số hoặc chuỗi.\n32. `isinstance()`: Kiểm tra xem một đối tượng có phải là một thể hiện của lớp không.\n33. `issubclass()`: Kiểm tra xem một lớp có phải là một lớp con của một lớp khác không.\n34. `iter()`: Trả về một bộ lặp.\n35. `len()`: Trả về độ dài của một đối tượng.\n36. `list()`: Tạo một danh sách trong Python.\n37. `locals()`: Trả về từ điển của bảng ký hiệu cục bộ hiện tại.\n38. `map()`: Áp dụng hàm và trả về một danh sách.\n39. `max()`: Trả về phần tử lớn nhất.\n40. `memoryview()`: Trả về chế độ xem bộ nhớ của một đối số.\n41. `min()`: Trả về giá trị nhỏ nhất.\n42. `next()`: Lấy phần tử tiếp theo từ bộ lặp.\n43. `object()`: Tạo một đối tượng không đặc điểm.\n44. `oct()`: Trả về biểu diễn bát phân của một số nguyên.\n45. `open()`: Trả về một đối tượng tệp.\n46. `ord()`: Trả về một số nguyên của ký tự Unicode.\n47. `pow()`: Trả về lũy thừa của một số.\n48. `print()`: In đối tượng đã cho.\n49. `property()`: Trả về thuộc tính tài sản.\n50. `range()`: Trả về một chuỗi số nguyên.\n51. `repr()`: Trả về một biểu diễn in được của đối tượng.\n52. `reversed()`: Trả về bộ lặp đảo ngược của một chuỗi.\n53. `round()`: Làm tròn một số đến số chữ số thập phân đã chỉ định.\n54. `set()`: Xây dựng và trả về một tập hợp.\n55. `setattr()`: Đặt giá trị của một thuộc tính của một đối tượng.\n56. `slice()`: Trả về một đối tượng lát cắt.\n57. `sorted()`: Trả về một danh sách được s\n\nắp xếp từ iterable đã cho.\n58. `staticmethod()`: Biến đổi một phương thức thành một phương thức tĩnh.\n59. `str()`: Trả về phiên bản chuỗi của đối tượng.\n60. `sum()`: Cộng các mục của một iterable.\n61. `super()`: Trả về một đối tượng proxy của lớp cơ sở.\n62. `tuple()`: Trả về một tuple.\n63. `type()`: Trả về loại của đối tượng.\n64. `vars()`: Trả về thuộc tính `__dict__`.\n65. `zip()`: Trả về một bộ lặp các tuple.\n66. `__import__()`: Hàm được gọi bởi câu lệnh import.\n\n### Các Hàm Toán Học:\n\nCác hàm toán học sau được tích hợp vào trình thông dịch Python, do đó bạn không cần phải nhập chúng từ bất kỳ module nào.\n\n1. `abs()`: Trả về giá trị tuyệt đối của x.\n2. `max()`: Trả về phần tử lớn nhất.\n3. `min()`: Trả về phần tử nhỏ nhất.\n4. `pow()`: Trả về x mũ y, tương đương với x**y, với đối số thứ ba là mod tùy chọn. Nếu được cung cấp, nó trả về giá trị (x**y) % mod.\n5. `round()`: Làm tròn x đến n chữ số sau dấu thập phân.\n6. `sum()`: Trả về tổng của tất cả các mục số trong bất kỳ iterable nào (list hoặc tuple). Đối số khởi đầu tùy chọn mặc định là 0. Nếu được cung cấp, các số trong danh sách được cộng vào giá trị khởi đầu.",
            "lesson": 3,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 53,
        "fields": {
            "name": "Bài 0. Python - Danh Sách (Lists)",
            "content": "# Bài 0. Python - Danh Sách (Lists)\n\n## Giới Thiệu về Danh Sách\n\nDanh sách là một trong những kiểu dữ liệu được tích hợp sẵn trong Python. Một danh sách Python là một chuỗi các mục được phân tách bằng dấu phẩy, được bao bọc bởi dấu ngoặc vuông [ ]. Các mục trong một danh sách Python không cần phải cùng loại dữ liệu.\n\nDưới đây là một số ví dụ về danh sách Python:\n\n```python\nlist1 = [\"Rohan\", \"Physics\", 21, 69.75]\nlist2 = [1, 2, 3, 4, 5]\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\nlist4 = [25.50, True, -55, 1+2j]\n```\n\nTrong Python, một danh sách là một kiểu dữ liệu chuỗi. Nó là một bộ sưu tập được sắp xếp các mục. Mỗi mục trong một danh sách có một chỉ mục vị trí duy nhất, bắt đầu từ 0.\n\nMột danh sách trong Python tương tự như một mảng trong C, C++ hoặc Java. Tuy nhiên, sự khác biệt chính là trong C/C++/Java, các phần tử của mảng phải cùng kiểu dữ liệu. Trong khi đó, các danh sách Python có thể chứa các đối tượng của các loại dữ liệu khác nhau.\n\nMột danh sách Python là có thể thay đổi được. Bất kỳ mục nào từ danh sách cũng có thể được truy cập bằng chỉ mục của nó và có thể được sửa đổi. Một hoặc nhiều đối tượng từ danh sách có thể được loại bỏ hoặc thêm vào. Một danh sách có thể có cùng một mục tại nhiều vị trí chỉ mục.\n\n## Các Phép Toán với Danh Sách Python\n\nTrong Python, Danh sách là một chuỗi. Do đó, chúng ta có thể nối hai danh sách với toán tử \"+\" và nối nhiều bản sao của một danh sách với toán tử \"*\". Các toán tử thành viên \"in\" và \"not in\" hoạt động với đối tượng danh sách.\n\n| Biểu thức Python      | Kết quả                      | Mô tả       |\n| --------------------- | ---------------------------- | ----------- |\n| [1, 2, 3] + [4, 5, 6] | [1, 2, 3, 4, 5, 6]           | Nối         |\n| ['Hi!'] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | Lặp lại     |\n| 3 in [1, 2, 3]        | True                         | Sự thuộc về |\n\nCác phép toán này giúp thao tác và xử lý danh sách một cách linh hoạt trong Python.",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 54,
        "fields": {
            "name": "Bài 1. Python - Truy Cập Các Phần Tử trong Danh Sách",
            "content": "# Bài 1. Python - Truy Cập Các Phần Tử trong Danh Sách\n\n## Truy Cập Các Phần Tử trong Danh Sách\n\nTrong Python, một danh sách là một chuỗi. Mỗi đối tượng trong danh sách có thể truy cập bằng chỉ mục của nó. Chỉ mục bắt đầu từ 0. Chỉ mục cuối cùng trong danh sách là \"length-1\". Để truy cập các giá trị trong một danh sách, sử dụng dấu ngoặc vuông để cắt cùng với chỉ mục hoặc các chỉ mục để nhận giá trị có sẵn tại chỉ mục đó.\n\n### Truy Cập Các Phần Tử trong Danh Sách Bằng Toán Tử Cắt\n\nToán tử cắt lấy một hoặc nhiều phần tử từ danh sách. Đặt chỉ mục vào dấu ngoặc vuông để lấy mục tại vị trí của nó.\n\n```python\nobj = list1[i]\n```\n\n#### Ví dụ\n\nXem ví dụ sau −\n\n```python\nlist1 = [\"Rohan\", \"Physics\", 21, 69.75]\nlist2 = [1, 2, 3, 4, 5]\n\nprint (\"Phần tử ở chỉ mục 0 trong list1: \", list1[0])\nprint (\"Phần tử ở chỉ mục 2 trong list2: \", list2[2])\n```\n\nKết quả sẽ là:\n\n```\nPhần tử ở chỉ mục 0 trong list1: Rohan\nPhần tử ở chỉ mục 2 trong list2: 3\n```\n\n### Truy Cập Các Phần Tử trong Danh Sách Bằng Chỉ Mục Âm\n\nPython cho phép sử dụng chỉ mục âm với bất kỳ kiểu chuỗi nào. Chỉ mục \"-1\" tham chiếu đến phần tử cuối cùng trong danh sách.\n\n#### Ví dụ\n\nHãy xem ví dụ khác −\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nlist2 = [25.50, True, -55, 1+2j]\n\nprint (\"Phần tử ở chỉ mục 0 trong list1: \", list1[-1])\nprint (\"Phần tử ở chỉ mục 2 trong list2: \", list2[-3])\n```\n\nKết quả sẽ là:\n\n```\nPhần tử ở chỉ mục 0 trong list1: d\nPhần tử ở chỉ mục 2 trong list2: True\n```\n\n### Truy Cập Danh Sách Con từ Một Danh Sách\n\nToán tử cắt trích xuất một danh sách con từ danh sách ban đầu.\n\n```\nSublist = list1[i:j]\n```\n\n#### Tham số\n\n- i: chỉ mục của phần tử đầu tiên trong danh sách con.\n- j: chỉ mục của phần tử tiếp theo sau phần tử cuối cùng trong danh sách con.\n\nĐiều này sẽ trả về một phần từ i đến (j-1) trong danh sách.\n\n#### Ví dụ\n\nKhi cắt, cả hai toán hạng \"i\" và \"j\" đều là tùy chọn. Nếu không sử dụng, \"i\" là 0 và \"j\" là phần tử cuối cùng trong danh sách. Chỉ mục âm có thể được sử dụng trong cắt. Hãy xem ví dụ sau −\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nlist2 = [25.50, True, -55, 1+2j]\n\nprint (\"Các phần tử từ chỉ mục 1 đến 2 trong list1: \", list1[1:3])\nprint (\"Các phần tử từ chỉ mục 0 đến 1 trong list2: \", list2[0:2])\n```\n\nKết quả sẽ là:\n\n```\nCác phần tử từ chỉ mục 1 đến 2 trong list1: ['b', 'c']\nCác phần tử từ chỉ mục 0 đến 1 trong list2: [25.5, True]\n```\n\n#### Ví dụ\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nlist2 = [25.50, True, -55, 1+2j]\nlist4 = [\"Rohan\", \"Physics\", 21, 69.75]\nlist3 = [1, 2, 3, 4, 5]\n\nprint (\"Các phần tử từ chỉ mục 1 đến cuối trong list1: \", list1[1:])\nprint (\"Các phần tử từ chỉ mục 0 đến 1 trong list2: \", list2[:2])\nprint (\"Các phần tử từ chỉ mục 2 đến cuối trong list3\", list3[2:-1])\nprint (\"Các phần tử từ chỉ mục 0 đến chỉ mục cuối cùng trong list4\", list4[:])\n```\n\nKết quả sẽ là:\n\n```\nCác phần tử từ chỉ mục 1 đến cuối trong list1: ['b', 'c', 'd']\nCác phần tử từ chỉ mục 0 đến 1 trong list2: [25.5, True]\nCác phần tử từ chỉ mục 2 đến cuối trong list3 [3, 4]\nCác phần tử từ chỉ mục 0 đến chỉ mục cuối cùng trong list4 ['Rohan', 'Physics', 21, 69.75]\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 55,
        "fields": {
            "name": "Bài 2. Python - Thay Đổi Các Phần Tử trong Danh Sách",
            "content": "# Bài 2. Python - Thay Đổi Các Phần Tử trong Danh Sách\n\n## Thay Đổi Các Phần Tử trong Danh Sách\n\nDanh sách là một loại dữ liệu có thể thay đổi được (mutable) trong Python. Điều này có nghĩa là, nội dung của danh sách có thể được thay đổi tại chỗ, sau khi đối tượng được lưu trong bộ nhớ. Bạn có thể gán một giá trị mới tại một chỉ mục nhất định trong danh sách.\n\n### Cú Pháp\n\n```python\nlist1[i] = giá_trị_mới\n```\n\n#### Ví dụ\n\nTrong đoạn mã sau, chúng ta thay đổi giá trị tại chỉ mục 2 của danh sách đã cho.\n\n```python\nlist3 = [1, 2, 3, 4, 5]\nprint (\"Danh sách gốc \", list3)\nlist3[2] = 10\nprint (\"Danh sách sau khi thay đổi giá trị tại chỉ mục 2: \", list3)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách gốc [1, 2, 3, 4, 5]\nDanh sách sau khi thay đổi giá trị tại chỉ mục 2: [1, 2, 10, 4, 5]\n```\n\n### Thay Đổi Các Phần Tử Liên Tiếp trong Danh Sách\n\nBạn có thể thay thế nhiều phần tử liên tiếp trong một danh sách bằng một danh sách con khác.\n\n#### Ví dụ\n\nTrong đoạn mã sau, các phần tử tại chỉ mục 1 và 2 được thay thế bằng các phần tử trong một danh sách con khác.\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\n\nprint (\"Danh sách gốc: \", list1)\n\nlist2 = ['Y', 'Z']\nlist1[1:3] = list2\n\nprint (\"Danh sách sau khi thay đổi bằng danh sách con: \", list1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi thay đổi bằng danh sách con: ['a', 'Y', 'Z', 'd']\n```\n\n### Thay Đổi Một Dãy Các Phần Tử trong Danh Sách\n\nNếu danh sách con nguồn có nhiều hơn các phần tử trong phần cắt cần thay thế, các phần tử thêm vào trong nguồn sẽ được chèn vào. Xem đoạn mã dưới đây −\n\n#### Ví dụ\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nprint (\"Danh sách gốc: \", list1)\nlist2 = ['X','Y', 'Z']\nlist1[1:3] = list2\nprint (\"Danh sách sau khi thay đổi bằng danh sách con: \", list1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi thay đổi bằng danh sách con: ['a', 'X', 'Y', 'Z', 'd']\n```\n\n#### Ví dụ\n\nNếu danh sách con mà một phần của danh sách gốc sẽ được thay thế, có ít hơn các phần tử, các phần tử phù hợp sẽ được thay thế và phần còn lại của danh sách gốc sẽ bị loại bỏ.\n\nTrong đoạn mã sau, chúng ta cố gắng thay thế \"b\" và \"c\" bằng \"Z\" (ít hơn một phần tử so với các phần tử cần thay thế). Điều này dẫn đến Z thay thế b và c bị loại bỏ.\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nprint (\"Danh sách gốc: \", list1)\nlist2 = ['Z']\nlist1[1:3] = list2\nprint (\"Danh sách sau khi thay đổi bằng danh sách con: \", list1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi thay đổi bằng danh sách con: ['a', 'Z', 'd']\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 56,
        "fields": {
            "name": "Bài 3. Python - Thêm Phần Tử vào Danh Sách",
            "content": "# Bài 3. Python - Thêm Phần Tử vào Danh Sách\n\n## Thêm Phần Tử vào Danh Sách\n\nTrong Python, có hai phương thức cơ bản để thêm phần tử vào danh sách hiện có: `append()` và `insert()`.\n\n### Phương Thức `append()`\n\nPhương thức `append()` được sử dụng để thêm một phần tử vào cuối của danh sách.\n\n#### Ví dụ\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nprint(\"Danh sách gốc: \", list1)\nlist1.append('e')\nprint(\"Danh sách sau khi thêm: \", list1)\n```\n\n#### Kết Quả\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi thêm: ['a', 'b', 'c', 'd', 'e']\n```\n\n### Phương Thức `insert()`\n\nPhương thức `insert()` chèn một phần tử vào danh sách tại một vị trí cụ thể được chỉ định.\n\n#### Ví dụ\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nprint(\"Danh sách gốc: \", list1)\nlist1.insert(2, 'e')\nprint(\"Danh sách sau khi chèn: \", list1)\n```\n\n#### Kết Quả\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi chèn: ['a', 'b', 'e', 'c', 'd']\n```\n\nTrong ví dụ này, chúng ta chèn phần tử 'e' vào danh sách `list1` tại vị trí có chỉ số là 2, và phần tử 'c' được dịch sang phải.",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 57,
        "fields": {
            "name": "Bài 4. Python - Xóa Phần Tử trong Danh Sách",
            "content": "# Bài 4. Python - Xóa Phần Tử trong Danh Sách\n\n## Xóa Phần Tử trong Danh Sách\n\nTrong Python, các phương thức của lớp list như remove() và pop() đều có thể xóa một phần tử từ danh sách. Sự khác biệt giữa chúng là remove() loại bỏ đối tượng được chỉ định, trong khi pop() loại bỏ một phần tử tại chỉ số đã cho.\n\n### Xóa Phần Tử Được Chỉ Định\n\nPhương thức remove() loại bỏ phần tử được chỉ định khỏi danh sách.\n\n#### Ví dụ\n\n```python\nlist1 = [\"Rohan\", \"Physics\", 21, 69.75]\nprint(\"Danh sách gốc: \", list1)\n\nlist1.remove(\"Physics\")\nprint(\"Danh sách sau khi xóa: \", list1)\n```\n\n#### Kết Quả\n\n```\nDanh sách gốc: ['Rohan', 'Physics', 21, 69.75]\nDanh sách sau khi xóa: ['Rohan', 21, 69.75]\n```\n\n### Xóa Phần Tử Được Chỉ Định Bằng Chỉ Số\n\nPhương thức pop() loại bỏ phần tử được chỉ định khỏi danh sách dựa trên chỉ số đã cho.\n\n#### Ví dụ\n\n```python\nlist2 = [25.50, True, -55, 1+2j]\nprint(\"Danh sách gốc: \", list2)\nlist2.pop(2)\nprint(\"Danh sách sau khi loại bỏ: \", list2)\n```\n\n#### Kết Quả\n\n```\nDanh sách gốc: [25.5, True, -55, (1+2j)]\nDanh sách sau khi loại bỏ: [25.5, True, (1+2j)]\n```\n\n### Xóa Phần Tử Được Chỉ Định Sử Dụng Từ Khóa `del`\n\nPython có từ khóa \"del\" loại bỏ bất kỳ đối tượng Python nào khỏi bộ nhớ.\n\n#### Ví dụ\n\nChúng ta có thể sử dụng \"del\" để xóa một phần tử từ danh sách. Hãy xem ví dụ sau:\n\n```python\nlist1 = [\"a\", \"b\", \"c\", \"d\"]\nprint(\"Danh sách gốc: \", list1)\ndel list1[2]\nprint(\"Danh sách sau khi xóa: \", list1)\n```\n\n#### Kết Quả\n\n```\nDanh sách gốc: ['a', 'b', 'c', 'd']\nDanh sách sau khi xóa: ['a', 'b', 'd']\n```\n\n### Xóa Các Phần Tử Liên Tiếp\n\nBạn có thể xóa một loạt các phần tử liên tiếp từ một danh sách bằng toán tử slice. Hãy xem ví dụ sau:\n\n#### Ví dụ\n\n```python\nlist2 = [25.50, True, -55, 1+2j]\nprint(\"Danh sách trước khi xóa: \", list2)\ndel list2[0:2]\nprint(\"Danh sách sau khi xóa: \", list2)\n```\n\n#### Kết Quả\n\n```\nDanh sách trước khi xóa: [25.5, True, -55, (1+2j)]\nDanh sách sau khi xóa: [-55, (1+2j)]\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 58,
        "fields": {
            "name": "Bài 5. Python - Lặp Qua Danh Sách",
            "content": "# Bài 5. Python - Lặp Qua Danh Sách\n\n## Lặp Qua Các Phần Tử của Danh Sách\n\nBạn có thể duyệt qua các phần tử trong một danh sách bằng cấu trúc vòng lặp for của Python. Việc duyệt qua có thể được thực hiện, sử dụng danh sách như một bộ lặp hoặc với sự giúp đỡ của chỉ số.\n\n### Cú Pháp\n\nDanh sách Python cung cấp một đối tượng bộ lặp. Để lặp qua một danh sách, sử dụng câu lệnh for như sau −\n\n```python\nfor obj in list:\n   . . .\n   . . .\n```\n\n### Ví dụ\n\nHãy xem ví dụ sau −\n\n```python\nlst = [25, 12, 10, -21, 10, 100]\nfor num in lst:\n   print(num, end=' ')\n```\n\n#### Kết Quả\n\n```\n25 12 10 -21 10 100\n```\n\n## Lặp Qua Các Phần Tử của Danh Sách với Chỉ Số\n\nĐể lặp qua các phần tử trong một danh sách, hãy lấy đối tượng phạm vi các số nguyên từ \"0\" đến \"len-1\". Xem ví dụ sau −\n\n### Ví dụ\n\n```python\nlst = [25, 12, 10, -21, 10, 100]\nindices = range(len(lst))\nfor i in indices:\n   print(\"lst[{}]: \".format(i), lst[i])\n```\n\n#### Kết Quả\n\n```\nlst[0]: 25\nlst[1]: 12\nlst[2]: 10\nlst[3]: -21\nlst[4]: 10\nlst[5]: 100\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 59,
        "fields": {
            "name": "Bài 6. Python - List Comprehension",
            "content": "# Bài 6. Python - List Comprehension\n\n## List Comprehension trong Python\n\nList comprehension là một công cụ lập trình rất mạnh mẽ. Nó tương tự như cách xây dựng tập hợp trong toán học. Đây là cách ngắn gọn để tạo ra một danh sách mới bằng cách thực hiện một loại quy trình nào đó trên từng mục trong danh sách hiện tại. List comprehension nhanh hơn đáng kể so với việc xử lý một danh sách bằng vòng lặp for.\n\n### Ví dụ về List Comprehension trong Python\n\nGiả sử chúng ta muốn tách mỗi chữ cái trong một chuỗi và đưa tất cả các chữ cái không phải là nguyên âm vào một đối tượng danh sách. Chúng ta có thể làm điều này bằng một vòng lặp for như sau:\n\n```python\nchars=[]\nfor ch in '8SyncDev':\n   if ch not in 'aeiou':\n      chars.append(ch)\nprint(chars)\n```\n\nĐối tượng danh sách chars sẽ được hiển thị như sau:\n\n```\n['8', 'S', 'y', 'n', 'c', 'D', 'e', 'v']\n```\n\n### Kỹ Thuật List Comprehension trong Python\n\nChúng ta có thể dễ dàng có được kết quả tương tự bằng một kỹ thuật list comprehension. Một cách sử dụng chung của list comprehension là như sau:\n\n```\nlistObj = [x for x in iterable]\n```\n\nÁp dụng điều này, đối tượng danh sách chars có thể được xây dựng bằng câu lệnh sau:\n\n```python\nchars = [char for char in '8SyncDev' if char not in 'kkkk']\nprint(chars)\n```\n\nDanh sách chars sẽ được hiển thị như trước:\n\n```\n['8', 'S', 'y', 'n', 'c', 'D', 'e', 'v']\n```\n\n### Ví dụ\n\nVí dụ sau sử dụng list comprehension để xây dựng một danh sách các bình phương của các số từ 1 đến 10\n\n```python\nsquares = [x*x for x in range(1,11)]\nprint(squares)\n```\n\nĐối tượng danh sách squares là:\n\n```\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```\n\n### Nested Loops trong List Comprehension của Python\n\nTrong ví dụ sau, tất cả các kết hợp của các mục từ hai danh sách dưới dạng một tuple được thêm vào danh sách thứ ba.\n\n```python\nlist1=[1,2,3]\nlist2=[4,5,6]\nCombLst=[(x,y) for x in list1 for y in list2]\nprint(CombLst)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]\n```\n\n### Điều Kiện trong List Comprehension của Python\n\nCâu lệnh sau sẽ tạo ra một danh sách các số chẵn từ 1 đến 20.\n\n```python\nlist1=[x for x in range(1,21) if x%2==0]\nprint(list1)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 60,
        "fields": {
            "name": "Bài 7. Python - Sắp xếp Danh sách",
            "content": "# Bài 7. Python - Sắp xếp Danh sách\n\n## Phương thức sort() của List trong Python\n\nPhương thức sort() của lớp list sắp xếp lại các mục theo thứ tự tăng dần hoặc giảm dần bằng cách sử dụng cơ chế sắp xếp theo thứ tự từ điển. Việc sắp xếp được thực hiện trên chính chúng trong cùng một đối tượng danh sách và nó không trả về một đối tượng mới.\n\n### Cú pháp\n\n```python\nlist1.sort(key, reverse)\n```\n\n### Tham số\n\n- **Key**: Hàm được áp dụng cho từng mục trong danh sách. Giá trị trả về được sử dụng để thực hiện sắp xếp. Tùy chọn.\n  \n- **Reverse**: Giá trị boolean. Nếu được đặt thành True, sắp xếp sẽ được thực hiện theo thứ tự giảm dần. Tùy chọn.\n\n### Giá trị trả về\n\nPhương thức này trả về None.\n\n### Sắp xếp các mục trong danh sách theo thứ tự chữ cái\n\nPhương thức sort() sắp xếp các mục của danh sách theo thứ tự chữ cái.\n\n#### Ví dụ\n\n```python\nlist1 = ['physics', 'Biology', 'chemistry', 'maths']\nprint(\"Danh sách trước khi sắp xếp:\", list1)\nlist1.sort()\nprint(\"Danh sách sau khi sắp xếp:\", list1)\n\nprint(\"Sắp xếp giảm dần\")\n\nlist2 = [10, 16, 9, 24, 5]\nprint(\"Danh sách trước khi sắp xếp:\", list2)\nlist2.sort()\nprint(\"Danh sách sau khi sắp xếp:\", list2)\n```\n\nĐầu ra sẽ là:\n\n```\nDanh sách trước khi sắp xếp: ['physics', 'Biology', 'chemistry', 'maths']\nDanh sách sau khi sắp xếp: ['Biology', 'chemistry', 'maths', 'physics']\nSắp xếp giảm dần\nDanh sách trước khi sắp xếp: [10, 16, 9, 24, 5]\nDanh sách sau khi sắp xếp: [5, 9, 10, 16, 24]\n```\n\n### Sắp xếp các mục trong danh sách với str.lower()\n\nTrong ví dụ này, phương thức str.lower() được sử dụng làm tham số key trong phương thức sort().\n\n#### Ví dụ\n\n```python\nlist1 = ['Physics', 'biology', 'Biomechanics', 'psychology']\nprint(\"Danh sách trước khi sắp xếp:\", list1)\nlist1.sort(key=str.lower)\nprint(\"Danh sách sau khi sắp xếp:\", list1)\n```\n\nĐầu ra sẽ là:\n\n```\nDanh sách trước khi sắp xếp: ['Physics', 'biology', 'Biomechanics', 'psychology']\nDanh sách sau khi sắp xếp: ['biology', 'Biomechanics', 'Physics', 'psychology']\n```\n\n### Sắp xếp các mục trong danh sách với Hàm gọi lại\n\nHàm do người dùng xác định cũng có thể được sử dụng làm tham số key trong phương thức sort().\n\n#### Ví dụ\n\n```python\ndef myfunction(x):\n   return x % 10\n\nlist1 = [17, 23, 46, 51, 90]\nprint(\"Danh sách trước khi sắp xếp:\", list1)\nlist1.sort(key=myfunction)\nprint(\"Danh sách sau khi sắp xếp:\", list1)\n```\n\nĐầu ra sẽ là:\n\n```\nDanh sách trước khi sắp xếp: [17, 23, 46, 51, 90]\nDanh sách sau khi sắp xếp: [90, 51, 23, 46, 17]\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 61,
        "fields": {
            "name": "Bài 8. Python - Sao chép Danh sách",
            "content": "# Bài 8. Python - Sao chép Danh sách\n\nTrong Python, một biến chỉ là một nhãn hoặc tham chiếu đến đối tượng trong bộ nhớ. Do đó, phép gán \"lst1 = lst\" đề cập đến cùng một đối tượng danh sách trong bộ nhớ. Hãy xem ví dụ sau:\n\n```python\nlst = [10, 20]\nprint(\"lst:\", lst, \"id(lst):\", id(lst))\nlst1 = lst\nprint(\"lst1:\", lst1, \"id(lst1):\", id(lst1))\n```\n\nKết quả sẽ là:\n\n```\nlst: [10, 20] id(lst): 1677677188288\nlst1: [10, 20] id(lst1): 1677677188288\n```\n\nDo đó, nếu chúng ta cập nhật \"lst\", nó sẽ tự động phản ánh trong \"lst1\". Thay đổi lst[0] thành 100\n\n```python\nlst[0] = 100\nprint(\"lst:\", lst, \"id(lst):\", id(lst))\nprint(\"lst1:\", lst1, \"id(lst1):\", id(lst1))\n```\n\nKết quả sẽ là:\n\n```\nlst: [100, 20] id(lst): 1677677188288\nlst1: [100, 20] id(lst1): 1677677188288\n```\n\nDo đó, chúng ta có thể nói rằng \"lst1\" không phải là bản sao vật lý của \"lst\".\n\n## Sao chép một Danh sách Python\n\nLớp list của Python có một phương thức copy() để tạo một bản sao vật lý mới của một đối tượng danh sách.\n\n### Cú pháp\n\n```python\nlst1 = lst.copy()\n```\n\nĐối tượng danh sách mới sẽ có một giá trị id() khác nhau.\n\n### Ví dụ về Sao chép Danh sách trong Python\n\n#### Ví dụ 1\n\n```python\nlst = [10, 20]\nlst1 = lst.copy()\nprint(\"lst:\", lst, \"id(lst):\", id(lst))\nprint(\"lst1:\", lst1, \"id(lst1):\", id(lst1))\n```\n\nKết quả sẽ là:\n\n```\nlst: [10, 20] id(lst): 1677678705472\nlst1: [10, 20] id(lst1): 1677678706304\n```\n\nMặc dù hai danh sách có cùng dữ liệu, chúng có các giá trị id() khác nhau, do đó chúng là hai đối tượng khác nhau và \"lst1\" là một bản sao của \"lst\".\n\nNếu chúng ta cố gắng sửa đổi \"lst\", nó sẽ không phản ánh trong \"lst1\". Hãy xem ví dụ sau -\n\n#### Ví dụ 2\n\n```python\nlst[0] = 100\nprint(\"lst:\", lst, \"id(lst):\", id(lst))\nprint(\"lst1:\", lst1, \"id(lst1):\", id(lst1))\n```\n\nKết quả sẽ là:\n\n```\nlst: [100, 20] id(lst): 1677678705472\nlst1: [10, 20] id(lst1): 1677678706304\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 62,
        "fields": {
            "name": "Bài 9. Python - Kết hợp Danh sách",
            "content": "# Bài 9. Python - Kết hợp Danh sách\n\nTrong Python, List được phân loại là một đối tượng loại chuỗi. Đó là một tập hợp các mục, có thể thuộc các loại dữ liệu khác nhau, với mỗi mục có một chỉ số vị trí bắt đầu từ 0. Bạn có thể sử dụng các cách khác nhau để kết hợp hai danh sách Python.\n\nTất cả các đối tượng loại chuỗi đều hỗ trợ toán tử nối (+), với đó hai danh sách có thể được kết hợp.\n\n### Ví dụ\n\n```python\nL1 = [10,20,30,40]\nL2 = ['one', 'two', 'three', 'four']\nL3 = L1 + L2\nprint(\"Danh sách kết hợp:\", L3)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách kết hợp: [10, 20, 30, 40, 'one', 'two', 'three', 'four']\n```\n\nKết hợp Danh sách Python Bằng Cách Sử Dụng Toán Tử Nối Tăng Cường\n\nBạn cũng có thể sử dụng toán tử nối tăng cường với ký hiệu \"+=\" để thêm L2 vào L1\n\n### Ví dụ\n\n```python\nL1 = [10,20,30,40]\nL2 = ['one', 'two', 'three', 'four']\nL1 += L2\nprint(\"Danh sách kết hợp:\", L1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách kết hợp: [10, 20, 30, 40, 'one', 'two', 'three', 'four']\n```\n\nKết quả tương tự có thể được thu được bằng cách sử dụng phương thức extend(). Ở đây, chúng ta cần mở rộng L1 để thêm các phần tử từ L2 vào đó.\n\n```python\nL1 = [10,20,30,40]\nL2 = ['one', 'two', 'three', 'four']\nL1.extend(L2)\nprint(\"Danh sách kết hợp:\", L1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách kết hợp: [10, 20, 30, 40, 'one', 'two', 'three', 'four']\n```\n\nKết hợp Danh sách Python bằng cách Thêm Mục\n\nĐể thêm các mục từ một danh sách vào một danh sách khác, một giải pháp lặp cổ điển cũng hoạt động. Duyệt qua các mục của danh sách thứ hai với một vòng lặp for, và thêm từng mục vào đầu tiên.\n\n### Ví dụ\n\n```python\nL1 = [10,20,30,40]\nL2 = ['one', 'two', 'three', 'four']\n\nfor x in L2:\n   L1.append(x)\n   \nprint(\"Danh sách kết hợp:\", L1)\n```\n\nKết quả sẽ là:\n\n```\nDanh sách kết hợp: [10, 20, 30, 40, 'one', 'two', 'three', 'four']\n```\n\nKết hợp Danh sách Python bằng Cách Sử Dụng Comprehension Danh sách\n\nMột phương pháp phức tạp hơn để kết hợp hai danh sách là sử dụng comprehension danh sách, như đoạn mã sau -\n\n### Ví dụ\n\n```python\nL1 = [10,20,30,40]\nL2 = ['one', 'two', 'three', 'four']\nL3 = [y for x in [L1, L2] for y in x]\nprint(\"Danh sách kết hợp:\", L3)\n```",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 63,
        "fields": {
            "name": "Bài 10. Python - Phương thức của Danh sách",
            "content": "# Bài 10. Python - Phương thức của Danh sách\n\nTrong Python, lớp danh sách bao gồm các phương thức sau mà bạn có thể sử dụng để thêm, cập nhật và xóa các mục trong danh sách:\n\n1. **append(obj)**: Thêm đối tượng obj vào danh sách.\n2. **clear()**: Xóa nội dung của danh sách.\n3. **copy()**: Trả về một bản sao của đối tượng danh sách.\n4. **count(obj)**: Trả về số lần xuất hiện của obj trong danh sách.\n5. **extend(seq)**: Thêm nội dung của seq vào danh sách.\n6. **index(obj)**: Trả về chỉ mục thấp nhất trong danh sách mà obj xuất hiện.\n7. **insert(index, obj)**: Chèn đối tượng obj vào danh sách tại vị trí index.\n8. **pop(obj=list[-1])**: Xóa và trả về đối tượng cuối cùng hoặc obj khỏi danh sách.\n9. **remove(obj)**: Xóa đối tượng obj khỏi danh sách.\n10. **reverse()**: Đảo ngược các đối tượng trong danh sách.\n11. **sort([func])**: Sắp xếp các đối tượng trong danh sách, sử dụng hàm so sánh nếu được chỉ định.",
            "lesson": 4,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 64,
        "fields": {
            "name": "Bài 0. Chuỗi trong Python",
            "content": "# Bài 0. Chuỗi trong Python\n\nTrong Python, một chuỗi là một chuỗi không thể thay đổi của các ký tự Unicode. Mỗi ký tự có một giá trị số duy nhất theo tiêu chuẩn UNICODE. Nhưng, chuỗi như một nguyên tắc, không có bất kỳ giá trị số nào ngay cả khi tất cả các ký tự đều là chữ số. Để phân biệt chuỗi khỏi số và các bộ nhận dạng khác, chuỗi các ký tự được bao quanh bằng dấu ngoặc đơn, kép hoặc ba dấu ngoặc kép trong biểu diễn chữ mạch của nó. Do đó, 1234 là một số (số nguyên) nhưng '1234' là một chuỗi.\n\n### Tạo Chuỗi Python\n\nMiễn là cùng một chuỗi ký tự được bao quanh, dấu ngoặc đơn, kép hoặc ba dấu ngoặc đơn không quan trọng. Do đó, các biểu diễn chuỗi sau là tương đương.\n\n```python\n>>> 'Welcome To 8SyncDev'\n'Welcome To 8SyncDev'\n>>> \"Welcome To 8SyncDev\"\n'Welcome To 8SyncDev'\n>>> '''Welcome To 8SyncDev'''\n'Welcome To 8SyncDev'\n>>> \"\"\"Welcome To 8SyncDev\"\"\"\n'Welcome To 8SyncDev'\n```\n\nNhìn vào các câu lệnh trên, rõ ràng rằng Python lưu trữ chuỗi nội bộ như được bao quanh bằng dấu ngoặc đơn.\n\n### Lấy Loại của Chuỗi Python\n\nMột chuỗi trong Python là một đối tượng của lớp str. Điều này có thể được xác minh với hàm type().\n\n```python\nvar = \"Welcome To 8SyncDev\"\nprint(type(var))\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\n<class 'str'>\n```\n\n### Dấu Ngoặc Đôi trong Chuỗi Python\n\nNếu bạn muốn nhúng một số văn bản trong dấu ngoặc kép như một phần của chuỗi, thì chính chuỗi đó nên được đặt trong dấu ngoặc đơn. Để nhúng một văn bản được trích dẫn bằng dấu ngoặc đơn, chuỗi nên được viết trong dấu ngoặc kép.\n\n```python\nvar = 'Welcome to \"Python Tutorial\" from 8SyncDev'\nprint(\"var:\", var)\n\nvar = \"Welcome to 'Python Tutorial' from 8SyncDev\"\nprint(\"var:\", var)\n```\n\n### Dấu Ngoặc Ba\n\nĐể tạo một chuỗi bằng dấu ngoặc ba, bạn có thể sử dụng ba dấu ngoặc đơn hoặc ba dấu ngoặc kép - cả hai phiên bản đều tương tự.\n\n```python\nvar = '''Welcome to 8SyncDev'''\nprint(\"var:\", var)\n\nvar = \"\"\"Welcome to 8SyncDev\"\"\"\nprint(\"var:\", var)\n```\n\n### Chuỗi Đa Dòng Python\n\nChuỗi được bao quanh bằng ba dấu ngoặc kép hữu ích để tạo ra một chuỗi đa dòng.\n\n```python\nvar = '''\nWelcome To\nPython Tutorial\nfrom 8SyncDev\n'''\nprint(\"var:\", var)\n```\n\nNó sẽ tạo ra đầu ra sau:\n\n```\nvar:\nWelcome To\nPython Tutorial\nfrom 8SyncDev\n```\n\nMột chuỗi là một loại dữ liệu không phải là số. Rõ ràng, chúng ta không thể sử dụng toán tử số học với các toán hạng chuỗi. Python sẽ ném ra TypeError trong trường hợp như vậy.\n\n```python\n>>> \"Hello\" - \"World\"\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n```",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 65,
        "fields": {
            "name": "Bài 1. Slicing Chuỗi trong Python",
            "content": "# Bài 1. Slicing Chuỗi trong Python\n\nTrong Python, một chuỗi là một chuỗi các ký tự Unicode được sắp xếp. Mỗi ký tự trong chuỗi có một chỉ mục duy nhất trong chuỗi. Chỉ mục bắt đầu từ 0. Ký tự đầu tiên trong chuỗi có chỉ mục vị trí của nó là 0. Chỉ mục tiếp tục tăng dần về phía cuối chuỗi.\n\nNếu một biến chuỗi được khai báo như sau: `var = \"HELLO PYTHON\"`, chỉ mục của mỗi ký tự trong chuỗi sẽ như sau:\n\n```\nH   E   L   L   O       P   Y   T   H   O   N\n0   1   2   3   4   5   6   7   8   9   10  11\n```\n\n## Truy cập Ký Tự trong Chuỗi Python\n\nPython cho phép bạn truy cập bất kỳ ký tự nào từ chuỗi bằng cách sử dụng chỉ mục của nó. Trong trường hợp này, 0 là giới hạn dưới và 11 là giới hạn trên của chuỗi. Vì vậy, `var[0]` trả về 'H', `var[6]` trả về 'P'. Nếu chỉ mục trong dấu ngoặc vuông vượt quá giới hạn trên, Python sẽ ném ra IndexError.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(var[0])   # 'H'\nprint(var[7])   # 'Y'\nprint(var[11])  # 'N'\nprint(var[12])  # IndexError: string index out of range\n```\n\n## Chỉ Mục Âm và Dương trong Chuỗi Python\n\nMột trong những tính năng đặc biệt của các loại chuỗi Python (và do đó là một đối tượng chuỗi) là nó có một hệ thống chỉ mục âm. Trong ví dụ trên, một hệ thống chỉ mục dương được sử dụng, trong đó chỉ mục tăng dần từ trái sang phải. Trong trường hợp của chỉ mục âm, ký tự ở cuối có chỉ mục -1 và chỉ mục giảm dần từ phải sang trái, kết quả là ký tự đầu tiên H có chỉ mục -12.\n\n**Ví dụ**\n\n```python\nprint(var[-1])   # 'N'\nprint(var[-5])   # 'Y'\nprint(var[-12])  # 'H'\nprint(var[-13])  # IndexError: string index out of range\n```\n\nMột lần nữa, nếu chỉ mục vượt ra khỏi phạm vi, IndexError sẽ được gặp phải.\n\n## Sử dụng Chỉ Mục Âm và Dương\n\nChúng ta có thể sử dụng chỉ mục dương hoặc âm để truy xuất một ký tự từ chuỗi.\n\n**Ví dụ**\n\n```python\nprint(var[0], var[-12])  # ('H', 'H')\nprint(var[7], var[-5])   # ('Y', 'Y')\nprint(var[11], var[-1])  # ('N', 'N')\n```\n\nTrong Python, chuỗi là một đối tượng không thay đổi. Đối tượng là không thay đổi nếu nó không thể được sửa đổi tại chỗ, sau khi được lưu trữ trong một vị trí bộ nhớ cụ thể. Bạn có thể lấy bất kỳ ký tự nào từ chuỗi bằng cách sử dụng chỉ mục của nó, nhưng bạn không thể thay thế nó bằng một ký tự khác.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nvar[7] = \"y\"  # TypeError: 'str' object does not support item assignment\n```\n\nLỗi TypeError là do chuỗi là không thay đổi.\n\n## Sử dụng Phép Cắt Chuỗi trong Python\n\nPython định nghĩa \":\" như là toán tử cắt chuỗi. Nó trả về một chuỗi con từ chuỗi gốc. Sử dụng như sau:\n\n```\nsubstr = var[x:y]\n```\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\n\nprint(\"var:\", var)\nprint(\"var[3:8]:\", var[3:8])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[3:8]: LO PY\n```\n\n## Sử dụng Chỉ Mục Âm và Dương trong Phép Cắt Chuỗi Python\n\nChỉ mục âm cũng có thể được sử dụng cho việc cắt.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(\"var:\", var)\nprint(\"var[3:8]:\", var[3:8])\nprint(\"var[-9:-4]:\", var[-9:-4])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[3:8]: LO PY\nvar[-9:-4]: LO PY\n```\n\n## Giá trị Mặc định của Chỉ Mục trong Phép Cắt Chuỗi\n\nCả hai toán hạng cho toán tử Cắt của Python là tùy chọn. Toán hạng đầu tiên mặc định là không, điều này có nghĩa là nếu chúng ta không cung cấp toán hạng đầu tiên, cắt bắt đầu từ ký tự ở chỉ mục 0, tức là ký tự đầu tiên. Nó cắt chuỗi con trái nhất lên đến \"y-1\" ký tự.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(\"var:\", var)\nprint(\"var[0:5]:\", var[0:5])\nprint(\"var[:5]:\", var[:5])\n```\n\nKết quả sẽ là:\n\n\n\n```\nvar: HELLO PYTHON\nvar[0:5]: HELLO\nvar[:5]: HELLO\n```\n\nTương tự, toán hạng y cũng là tùy chọn. Mặc định là \"-1\", có nghĩa là chuỗi sẽ được cắt từ vị trí x đến cuối chuỗi.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(\"var:\", var)\nprint(\"var[6:12]:\", var[6:12])\nprint(\"var[6:]:\", var[6:])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[6:12]: PYTHON\nvar[6:]: PYTHON\n```\n\nTự nhiên, nếu cả hai toán hạng đều không được sử dụng, phép cắt sẽ bằng với chuỗi gốc. Điều này bởi vì \"x\" là 0, và \"y\" mặc định là chỉ mục cuối cùng+1 (hoặc -1).\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(\"var:\", var)\nprint(\"var[0:12]:\", var[0:12])\nprint(\"var[:]:\", var[:])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[0:12]: HELLO PYTHON\nvar[:]: HELLO PYTHON\n```\n\nToán hạng bên trái phải nhỏ hơn toán hạng bên phải, để lấy một chuỗi con của chuỗi gốc. Python không ném ra bất kỳ lỗi nào, nếu toán hạng bên trái lớn hơn, nhưng trả về một chuỗi rỗng.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\nprint(\"var:\", var)\nprint(\"var[-1:7]:\", var[-1:7])\nprint(\"var[7:0]:\", var[7:0])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[-1:7]:\nvar[7:0]:\n```\n\n## Kiểu Trả về của Phép Cắt Chuỗi\n\nCắt trả về một chuỗi mới. Bạn hoàn toàn có thể thực hiện các thao tác chuỗi như ghép chuỗi, hoặc cắt trên chuỗi đã được cắt.\n\n**Ví dụ**\n\n```python\nvar = \"HELLO PYTHON\"\n\nprint(\"var:\", var)\nprint(\"var[:6][:2]:\", var[:6][:2])\n\nvar1 = var[:6]\nprint(\"slice:\", var1)\nprint(\"var1[:2]:\", var1[:2])\n```\n\nKết quả sẽ là:\n\n```\nvar: HELLO PYTHON\nvar[:6][:2]: HE\nslice: HELLO\nvar1[:2]: HE\n```",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 66,
        "fields": {
            "name": "Bài 2. Sửa Đổi Chuỗi trong Python",
            "content": "# Bài 2. Sửa Đổi Chuỗi trong Python\n\nTrong Python, một chuỗi (đối tượng của lớp str) thuộc loại không thay đổi. Một đối tượng không thay đổi là đối tượng không thể được sửa đổi tại chỗ, sau khi được tạo trong bộ nhớ. Do đó, khác với một danh sách, bất kỳ ký tự nào trong chuỗi cũng không thể được ghi đè, cũng không thể chèn hoặc thêm các ký tự vào nó trừ khi chúng ta sử dụng một số phương thức chuỗi nhất định trả về một đối tượng chuỗi mới.\n\nTuy nhiên, chúng ta có thể sử dụng một trong các kỹ thuật sau đây như một phương pháp vượt qua để sửa đổi một chuỗi.\n\n## Chuyển đổi một Chuỗi thành Một Danh Sách\n\nVì cả chuỗi và danh sách đều là các chuỗi, chúng có thể được chuyển đổi lẫn nhau. Do đó, nếu chúng ta chuyển đổi một đối tượng chuỗi thành một danh sách, sửa đổi danh sách bằng cách sử dụng các phương thức insert(), append() hoặc remove(), và sau đó chuyển đổi danh sách trở lại thành một chuỗi, chúng ta sẽ nhận được phiên bản đã được sửa đổi.\n\n**Ví dụ**\n\n```python\ns1 = \"WORD\"\nprint(\"Chuỗi gốc:\", s1)\nl1 = list(s1)\n\nl1.insert(3, \"L\")\n\nprint(l1)\n\ns1 = ''.join(l1)\nprint(\"Chuỗi đã sửa đổi:\", s1)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi gốc: WORD\n['W', 'O', 'R', 'L', 'D']\nChuỗi đã sửa đổi: WORLD\n```\n\n## Sử Dụng Mô-đun Array\n\nĐể sửa đổi một chuỗi, ta có thể xây dựng một đối tượng mảng. Thư viện chuẩn của Python bao gồm mô-đun array. Chúng ta có thể có một mảng kiểu Unicode từ một biến chuỗi.\n\n**Ví dụ**\n\n```python\nimport array as ar\n\ns1 = \"WORD\"\nsar = ar.array('u', s1)\n\nsar.insert(3, \"L\")\n\ns1 = sar.tounicode()\n\nprint(\"Chuỗi đã sửa đổi:\", s1)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi đã sửa đổi: WORLD\n```\n\n## Sử Dụng Lớp StringIO\n\nMô-đun io của Python định nghĩa các lớp để xử lý luồng. Lớp StringIO đại diện cho một luồng văn bản sử dụng một bộ đệm văn bản trong bộ nhớ. Một đối tượng StringIO được lấy từ một chuỗi hoạt động giống như một đối tượng File. Do đó, chúng ta có thể thực hiện các thao tác đọc/ghi trên nó. Phương thức getvalue() của lớp StringIO trả về một chuỗi.\n\nHãy sử dụng nguyên tắc này trong chương trình sau để sửa đổi một chuỗi.\n\n**Ví dụ**\n\n```python\nimport io\n\ns1 = \"WORD\"\nprint(\"Chuỗi gốc:\", s1)\n\nsio = io.StringIO(s1)\nsio.seek(3)\nsio.write(\"LD\")\ns1 = sio.getvalue()\n\nprint(\"Chuỗi đã sửa đổi:\", s1)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi gốc: WORD\nChuỗi đã sửa đổi: WORLD\n```\n\nNhư vậy, ta đã tìm hiểu cách sửa đổi chuỗi trong Python bằng các kỹ thuật khác nhau.",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 67,
        "fields": {
            "name": "Bài 3. Ghép Chuỗi trong Python",
            "content": "# Bài 3. Ghép Chuỗi trong Python\n\nToán tử \"+\" được biết đến như một toán tử cộng, trả về tổng của hai số. Tuy nhiên, ký hiệu \"+\" hoạt động như một toán tử ghép chuỗi trong Python. Nó hoạt động với hai toán hạng chuỗi và kết quả là sự ghép nối của hai chuỗi.\n\nCác ký tự của chuỗi bên phải của ký hiệu cộng được nối vào chuỗi bên trái của nó. Kết quả của việc ghép nối là một chuỗi mới.\n\n**Ví dụ**\n\n```python\nstr1 = \"Hello\"\nstr2 = \"World\"\nprint(\"Chuỗi 1:\", str1)\nprint(\"Chuỗi 2:\", str2)\nstr3 = str1 + str2\nprint(\"Chuỗi 3:\", str3)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi 1: Hello\nChuỗi 2: World\nChuỗi 3: HelloWorld\n```\n\n## Chèn Khoảng Trắng Giữa Hai Chuỗi Đã Ghép\n\nĐể chèn một khoảng trắng giữa hai chuỗi, sử dụng một chuỗi trống thứ ba.\n\n**Ví dụ**\n\n```python\nstr1 = \"Hello\"\nstr2 = \"World\"\nkhoang_trang = \" \"\nprint(\"Chuỗi 1:\", str1)\nprint(\"Chuỗi 2:\", str2)\nstr3 = str1 + khoang_trang + str2\nprint(\"Chuỗi 3:\", str3)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi 1: Hello\nChuỗi 2: World\nChuỗi 3: Hello World\n```\n\n## Ghép Chuỗi Bằng Cách Nhân\n\nKý hiệu \"*\", mà chúng ta thường sử dụng để nhân hai số, cũng có thể được sử dụng với các toán hạng chuỗi. Ở đây, \"*\" hoạt động như một toán tử lặp lại trong Python. Một trong các toán hạng phải là một số nguyên và thứ hai là một chuỗi. Toán tử nối nhiều bản sao của chuỗi lại với nhau. Ví dụ −\n\n**Ví dụ**\n\n```python\n>>> \"Hello\" * 3\n'HelloHelloHello'\n```\n\nToán hạng số nguyên là số bản sao của toán hạng chuỗi để được nối.\n\n## Ghép Chuỗi Với Các Toán Tử '+' và '*'\n\nCả hai toán tử chuỗi, (*) toán tử lặp lại và (+) toán tử ghép chuỗi, có thể được sử dụng trong một biểu thức duy nhất. Toán tử \"*\" có độ ưu tiên cao hơn toán tử \"+\".\n\n**Ví dụ**\n\n```python\nstr1 = \"Hello\"\nstr2 = \"World\"\nprint(\"Chuỗi 1:\", str1)\nprint(\"Chuỗi 2:\", str2)\nstr3 = str1 + str2 * 3\nprint(\"Chuỗi 3:\", str3)\nstr4 = (str1 + str2) * 3\nprint(\"Chuỗi 4:\", str4)\n```\n\nĐể tạo chuỗi str3, Python ghép 3 bản sao của World trước, và sau đó nối kết quả vào Hello\n\n```\nChuỗi 3: HelloWorldWorldWorld\n```\n\nTrong trường hợp thứ hai, các chuỗi str1 và str2 được đặt trong dấu ngoặc đơn, do đó việc ghép của chúng diễn ra trước. Kết quả của nó sau đó được lặp lại ba lần.\n\n```\nChuỗi 4: HelloWorldHelloWorldHelloWorld\n```\n\nNgoài \"+\" và \"*\", không có ký hiệu toán hạng số học nào khác có thể được sử dụng với các toán hạng chuỗi.",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 68,
        "fields": {
            "name": "Bài 4. Định Dạng Chuỗi trong Python",
            "content": "# Bài 4. Định Dạng Chuỗi trong Python\n\nĐịnh dạng chuỗi là quá trình xây dựng một biểu diễn chuỗi một cách linh hoạt bằng cách chèn giá trị của các biểu thức số học vào một chuỗi đã tồn tại. Toán tử ghép chuỗi của Python không chấp nhận một toán hạng không phải là chuỗi. Do đó, Python cung cấp các kỹ thuật định dạng chuỗi sau:\n\n1. Sử dụng toán tử % cho sự thay thế\n2. Sử dụng phương thức format() của lớp str\n3. Sử dụng cú pháp f-string\n4. Sử dụng lớp String Template\n\n## Sử Dụng Toán Tử % cho Sự Thay Thế\n\nToán tử % cho phép thay thế các giá trị trong một chuỗi bằng các giá trị đã cho. Đây là cách cũ nhưng vẫn được sử dụng phổ biến.\n\n**Ví dụ**\n\n```python\nname = \"John\"\nage = 30\nprint(\"Tên của tôi là %s và tôi %d tuổi.\" % (name, age))\n```\n\nKết quả sẽ là:\n\n```\nTên của tôi là John và tôi 30 tuổi.\n```\n\n## Sử Dụng Phương Thức format() của Lớp str\n\nPhương thức format() cho phép định dạng một chuỗi bằng cách chèn các giá trị được chỉ định trong chuỗi.\n\n**Ví dụ**\n\n```python\nname = \"Alice\"\nage = 25\nprint(\"Tên của tôi là {} và tôi {} tuổi.\".format(name, age))\n```\n\nKết quả sẽ là:\n\n```\nTên của tôi là Alice và tôi 25 tuổi.\n```\n\n## Sử Dụng Cú Pháp f-string\n\nf-string là một cú pháp mới trong Python (bắt đầu từ Python 3.6) cho phép thực hiện định dạng chuỗi một cách nhanh chóng và dễ dàng.\n\n**Ví dụ**\n\n```python\nname = \"Emma\"\nage = 35\nprint(f\"Tên của tôi là {name} và tôi {age} tuổi.\")\n```\n\nKết quả sẽ là:\n\n```\nTên của tôi là Emma và tôi 35 tuổi.\n```\n\n## Sử Dụng Lớp String Template\n\nLớp String Template cung cấp một cách khác để thực hiện định dạng chuỗi bằng cách chèn các giá trị được chỉ định trong chuỗi.\n\n**Ví dụ**\n\n```python\nfrom string import Template\n\nname = \"Sophia\"\nage = 40\ntemplate = Template(\"Tên của tôi là $name và tôi $age tuổi.\")\nprint(template.substitute(name=name, age=age))\n```\n\nKết quả sẽ là:\n\n```\nTên của tôi là Sophia và tôi 40 tuổi.\n```",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 69,
        "fields": {
            "name": "Bài 5. Ký Tự Escape Trong Python",
            "content": "# Bài 5. Ký Tự Escape Trong Python\n\nTrong Python, một chuỗi trở thành một chuỗi thô nếu nó được tiền tố bằng \"r\" hoặc \"R\" trước các ký hiệu trích dẫn. Do đó, 'Hello' là một chuỗi bình thường trong khi r'Hello' là một chuỗi thô.\n\n```python\n>>> normal = \"Hello\"\n>>> print(normal)\nHello\n>>> raw = r\"Hello\"\n>>> print(raw)\nHello\n```\n\nTrong các hoàn cảnh bình thường, không có sự khác biệt giữa hai loại chuỗi này. Tuy nhiên, khi ký tự thoát được nhúng trong chuỗi, chuỗi bình thường thực sự diễn giải chuỗi thoát, trong khi chuỗi thô không xử lý ký tự thoát.\n\n```python\n>>> normal = \"Hello\\nWorld\"\n>>> print(normal)\nHello\nWorld\n>>> raw = r\"Hello\\nWorld\"\n>>> print(raw)\nHello\\nWorld\n```\n\nTrong ví dụ trên, khi một chuỗi bình thường được in ra, ký tự thoát '\\n' được xử lý để tạo ra một dòng mới. Tuy nhiên, do toán tử chuỗi thô 'r', hiệu ứng của ký tự thoát không được dịch theo ý nghĩa của nó.\n\n## Ký Tự Thoát\n\nMột ký tự thoát là một ký tự được theo sau bởi một dấu gạch chéo (\\) cho biết cho Trình thông dịch rằng ký tự thoát này (chuỗi) có ý nghĩa đặc biệt.\n\n**Ví dụ**\n\nKý tự xuống dòng \\n là một trong các chuỗi thoát được xác định bởi Python. Chuỗi thoát kích hoạt một chuỗi con thay thế cách triển khai khác cho \"\\\". Trong Python, \"\\\" được sử dụng làm ký tự thoát. Bảng sau đây hiển thị danh sách các chuỗi thoát.\n\nTrừ khi có tiền tố 'r' hoặc 'R', các chuỗi thoát trong chuỗi và byte literals được diễn giải theo các quy tắc tương tự như các quy tắc được sử dụng bởi C tiêu chuẩn. Các chuỗi thoát được nhận dạng là −\n\n## Ký Tự Thoát Trong Python\n\nBảng sau đây hiển thị các ký tự thoát khác nhau được sử dụng trong Python -\n\n| STT | Chuỗi Thoát & Ý Nghĩa |\n| --- | --------------------- |\n| 1   | \\\\<dòng mới>          |\n| 2   | \\\\\\\\                  |\n| 3   | \\\\'                   |\n| 4   | \\\\\"                   |\n| 5   | \\\\a                   |\n| 6   | \\\\b                   |\n| 7   | \\\\f                   |\n| 8   | \\\\n                   |\n| 9   | \\\\r                   |\n| 10  | \\\\t                   |\n| 11  | \\\\v                   |\n| 12  | \\\\ooo                 |\n| 13  | \\\\xhh                 |\n\n## Ví dụ về Ký Tự Thoát\n\nĐoạn mã sau đây hiển thị cách sử dụng các chuỗi thoát được liệt kê trong bảng trên -\n\n```python\n# bỏ qua \\\ns = 'Chuỗi này sẽ không bao gồm \\\ndấu gạch chéo hoặc ký tự xuống dòng mới.'\nprint(s)\n\n# ký tự gạch chéo\ns = 'Ký tự \\\\ được gọi là ký tự gạch chéo'\nprint(s)\n\n# ký tự nháy đơn\ns = 'Xin chào \\'Python\\''\nprint(s)\n\n# ký tự nháy kép\ns = \"Xin chào \\\"Python\\\"\"\nprint(s)\n\n# thoát \\b để tạo ra ký tự backspace ASCII\ns = 'Hel\\blo'\nprint(s)\n\n# ký tự chuông ASCII\ns = 'Xin chào\\a'\nprint(s)\n\n# dòng mới\ns = 'Xin chào\\nPython'\nprint(s)\n\n# tab ngang\ns = 'Xin chào\\tPython'\nprint(s)\n\n# trang form\ns = \"xin chào\\fworld\"\nprint(s)\n\n# Chú thích theo hệ bát phân\ns = \"\\101\"\nprint(s)\n\n# Chú thích theo hệ thập lục phân\ns = \"\\x41\"\nprint(s)\n```\n\nKết quả sẽ là:\n\n```\nChuỗi này sẽ không bao gồm dấu gạch chéo hoặc ký tự xuống dòng mới.\nKý tự \\ được gọi là ký tự gạch chéo\nXin chào 'Python'\nXin chào \"Python\"\nHelo\nXin chào\u0007\nXin chào\nPython\nXin chào\tPython\nxin chào\fworld\nA\nA\n```",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 70,
        "fields": {
            "name": "Bài 6. Phương Thức Chuỗi trong Python",
            "content": "# Bài 6. Phương Thức Chuỗi trong Python\n\nLớp str tích hợp sẵn trong Python định nghĩa các phương thức khác nhau. Chúng hỗ trợ trong việc xử lý chuỗi. Do chuỗi là một đối tượng không thể thay đổi, các phương thức này trả về một bản sao của chuỗi gốc, thực hiện các xử lý tương ứng trên nó.\n\nCác phương thức chuỗi có thể được phân loại trong các nhóm sau −\n\n1. Chuyển đổi chữ hoa và chữ thường\n2. Căn chỉnh\n3. Tách và kết hợp\n4. Kiểm tra logic\n5. Tìm kiếm và thay thế\n6. Định dạng\n7. Dịch\n\n## Chuyển Đổi Chữ Hoa và Chữ Thường\n\nCác phương thức trong nhóm này hỗ trợ chuyển đổi các ký tự của chuỗi thành chữ hoa hoặc chữ thường.\n\n**Ví dụ:**\n\n```python\ns = \"hello world\"\nprint(s.upper())  # Chuyển thành chữ hoa\nprint(s.capitalize())  # Chuyển ký tự đầu tiên thành chữ hoa\nprint(s.title())  # Chuyển thành chữ in hoa theo tiêu đề\n```\n\n## Căn Chỉnh\n\nCác phương thức trong nhóm này hỗ trợ căn chỉnh các chuỗi.\n\n**Ví dụ:**\n\n```python\ns = \"hello\"\nprint(s.center(20))  # Căn chỉnh giữa\nprint(s.ljust(20))  # Căn chỉnh trái\nprint(s.rjust(20))  # Căn chỉnh phải\n```\n\n## Tách và Kết Hợp\n\nCác phương thức trong nhóm này hỗ trợ tách chuỗi thành các phần và kết hợp các phần thành một chuỗi mới.\n\n**Ví dụ:**\n\n```python\ns = \"apple,banana,orange\"\nprint(s.split(','))  # Tách chuỗi thành danh sách các phần tử\nprint('-'.join(['apple', 'banana', 'orange']))  # Kết hợp các phần tử thành chuỗi mới\n```\n\n## Kiểm Tra Logic\n\nCác phương thức trong nhóm này hỗ trợ kiểm tra các điều kiện logic trên chuỗi.\n\n**Ví dụ:**\n\n```python\ns = \"hello world\"\nprint(s.startswith(\"hello\"))  # Kiểm tra xem chuỗi có bắt đầu bằng \"hello\" không\nprint(s.endswith(\"world\"))  # Kiểm tra xem chuỗi có kết thúc bằng \"world\" không\nprint(s.isalnum())  # Kiểm tra xem chuỗi có chứa toàn bộ các ký tự hoặc số không\nprint(s.isdigit())  # Kiểm tra xem chuỗi có phải là một số không\nprint(s.islower())  # Kiểm tra xem tất cả các ký tự trong chuỗi có phải là chữ thường không\nprint(s.isupper())  # Kiểm tra xem tất cả các ký tự trong chuỗi có phải là chữ hoa không\n```\n\n## Tìm Kiếm và Thay Thế\n\nCác phương thức trong nhóm này hỗ trợ tìm kiếm và thay thế các phần của chuỗi.\n\n**Ví dụ:**\n\n```python\ns = \"hello world\"\nprint(s.find(\"world\"))  # Tìm vị trí đầu tiên của \"world\" trong chuỗi\nprint(s.replace(\"world\", \"universe\"))  # Thay thế \"world\" bằng \"universe\" trong chuỗi\n```\n\n## Định Dạng\n\nCác phương thức trong nhóm này hỗ trợ định dạng chuỗi.\n\n**Ví dụ:**\n\n```python\ns = \"My name is {name} and I am {age} years old.\"\nprint(s.format(name=\"John\", age=30))  # Sử dụng phương thức format()\nprint(f\"My name is {'John'} and I am {30} years old.\")  # Sử dụng f-string\n```\n\n## Dịch\n\nCác phương thức trong nhóm này hỗ trợ dịch các ký tự trong chuỗi.\n\n**Ví dụ:**\n\n```python\ntable = str.maketrans(\"aeiou\", \"12345\")\ns = \"apple\"\nprint(s.translate(table))  # Dịch các ký tự trong chuỗi theo bảng dịch đã cho\n```\n",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 71,
        "fields": {
            "name": "Bài 7. Python - Bài Tập Chuỗi",
            "content": "# Bài 7. Python - Bài Tập Chuỗi\n\n## Bài Tập 1: Đếm số lượng nguyên âm trong chuỗi\n\n```python\nmystr = \"All animals are equal. Some are more equal\"\nvowels = \"aeiou\"\ncount = 0\nfor x in mystr:\n   if x.lower() in vowels:\n       count += 1\nprint(\"Số lượng nguyên âm:\", count)\n```\n\nKết quả:\n\n```\nSố lượng nguyên âm: 18\n```\n\n## Bài Tập 2: Chuyển chuỗi nhị phân thành số nguyên\n\n```python\nmystr = '10101'\n\ndef strtoint(mystr):\n   for x in mystr:\n      if x not in '01':\n          return \"Lỗi. Chuỗi chứa ký tự không phải nhị phân\"\n   num = int(mystr, 2)\n   return num\n\nprint(\"Nhị phân: {}, Số nguyên: {}\".format(mystr, strtoint(mystr)))\n```\n\nKết quả:\n\n```\nNhị phân: 10101, Số nguyên: 21\n```\n\nNếu thay `mystr` thành `'10, 101'`:\n\n```\nNhị phân: 10, 101, Số nguyên: Lỗi. Chuỗi chứa ký tự không phải nhị phân\n```\n\n## Bài Tập 3: Loại bỏ tất cả các chữ số từ chuỗi\n\n```python\ndigits = [str(x) for x in range(10)]\nmystr = 'He12llo, Py00th55on!'\nchars = []\nfor x in mystr:\n   if x not in digits:\n      chars.append(x)\nnewstr = ''.join(chars)\nprint(newstr)\n```\n\nKết quả:\n\n```\nHello, Python!\n```\n\n## Bài Tập 4: Sắp xếp các ký tự trong chuỗi\n\n## Bài Tập 5: Loại bỏ các ký tự trùng lặp từ chuỗi\n\n## Bài Tập 6: Liệt kê các ký tự duy nhất với số lần xuất hiện của chúng trong chuỗi\n\n## Bài Tập 7: Đếm số từ trong chuỗi\n\n## Bài Tập 8: Loại bỏ tất cả các ký tự không phải chữ cái từ chuỗi\n\nĐây là một số bài tập phổ biến về xử lý chuỗi trong Python. Bạn có thể thực hiện các bài tập này để củng cố kiến thức về xử lý chuỗi và các phương thức chuỗi trong Python.\n\n\n## Bài Tập 1: Đếm số lượng nguyên âm trong chuỗi\n\n### Giải Pháp:\n- Sử dụng một vòng lặp để duyệt qua từng ký tự trong chuỗi.\n- Kiểm tra xem ký tự đó có phải là nguyên âm không bằng cách so sánh với danh sách các nguyên âm.\n- Tăng biến đếm nếu ký tự là nguyên âm.\n\n## Bài Tập 2: Chuyển chuỗi nhị phân thành số nguyên\n\n### Giải Pháp:\n- Kiểm tra từng ký tự trong chuỗi xem có phải là '0' hoặc '1' không.\n- Nếu có ký tự nào không phải nhị phân, trả về thông báo lỗi.\n- Sử dụng hàm `int(mystr, 2)` để chuyển đổi chuỗi nhị phân thành số nguyên.\n\n## Bài Tập 3: Loại bỏ tất cả các chữ số từ chuỗi\n\n### Giải Pháp:\n- Duyệt qua từng ký tự trong chuỗi.\n- Nếu ký tự không phải là số, thêm vào danh sách các ký tự mới.\n- Cuối cùng, kết hợp danh sách các ký tự mới thành một chuỗi mới.\n\n## Bài Tập 4: Sắp xếp các ký tự trong chuỗi\n\n### Giải Pháp:\n- Sử dụng hàm `sorted()` để sắp xếp các ký tự trong chuỗi.\n- Hàm này sẽ trả về một danh sách các ký tự đã được sắp xếp.\n- Sử dụng `''.join()` để kết hợp các ký tự trong danh sách thành một chuỗi mới.\n\n## Bài Tập 5: Loại bỏ các ký tự trùng lặp từ chuỗi\n\n### Giải Pháp:\n- Sử dụng một vòng lặp để duyệt qua từng ký tự trong chuỗi.\n- Thêm mỗi ký tự vào một danh sách nếu nó chưa xuất hiện trong danh sách.\n- Kết hợp các ký tự trong danh sách thành một chuỗi mới.\n\n## Bài Tập 6: Liệt kê các ký tự duy nhất với số lần xuất hiện của chúng trong chuỗi\n\n### Giải Pháp:\n- Sử dụng một từ điển để đếm số lần xuất hiện của mỗi ký tự trong chuỗi.\n- Duyệt qua từng ký tự trong chuỗi và cập nhật số lần xuất hiện trong từ điển.\n- Cuối cùng, in ra các ký tự duy nhất và số lần xuất hiện của chúng.\n\n## Bài Tập 7: Đếm số từ trong chuỗi\n\n### Giải Pháp:\n- Sử dụng phương thức `split()` để tách chuỗi thành danh sách các từ.\n- Đếm số phần tử trong danh sách, đó chính là số từ trong chuỗi.\n\n## Bài Tập 8: Loại bỏ tất cả các ký tự không phải chữ cái từ chuỗi\n\n### Giải Pháp:\n- Duyệt qua từng ký tự trong chuỗi.\n- Nếu ký tự là chữ cái, thêm vào danh sách các ký tự mới.\n- Cuối cùng, kết hợp danh sách các ký tự mới thành một chuỗi mới.\n\nĐây là các giải pháp cho mỗi bài tập, mỗi giải pháp cung cấp một cách tiếp cận cụ thể để giải quyết vấn đề.",
            "lesson": 5,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 72,
        "fields": {
            "name": "Bài 0. Python - Tập hợp (Sets)",
            "content": "# Bài 0. Python - Tập hợp (Sets)\n\nTrong Python, một tập hợp là một trong các loại dữ liệu có sẵn. Trong toán học, tập hợp là một bộ sưu tập các đối tượng riêng biệt. Loại dữ liệu tập hợp là cách thức Python thực hiện một tập hợp. Các đối tượng trong một tập hợp có thể là bất kỳ loại dữ liệu nào.\n\nTập hợp trong Python cũng là một loại dữ liệu tập hợp như danh sách hoặc bộ. Tuy nhiên, nó không phải là một bộ sưu tập có thứ tự, tức là các mục trong một tập hợp không thể truy cập bằng chỉ số vị trí của chúng. Một đối tượng tập hợp là một bộ sưu tập của một hoặc nhiều đối tượng không thay đổi được bao gồm trong dấu ngoặc nhọn {}.\n\n## Ví dụ\n\n### Ví dụ 1\n\nDưới đây là một số ví dụ về các đối tượng tập hợp −\n\n```python\ns1 = {\"Rohan\", \"Physics\", 21, 69.75}\ns2 = {1, 2, 3, 4, 5}\ns3 = {\"a\", \"b\", \"c\", \"d\"}\ns4 = {25.50, True, -55, 1+2j}\nprint (s1)\nprint (s2)\nprint (s3)\nprint (s4)\n```\n\nKết quả sẽ là:\n\n```\n{'Physics', 21, 'Rohan', 69.75}\n{1, 2, 3, 4, 5}\n{'a', 'd', 'c', 'b'}\n{25.5, -55, True, (1+2j)}\n```\n\n### Ví dụ 2\n\nHàm set() cũng xây dựng một đối tượng tập hợp từ một đối tượng chuỗi (danh sách, bộ hoặc chuỗi).\n\n```python\nL1 = [\"Rohan\", \"Physics\", 21, 69.75]\ns1 = set(L1)\nT1 = (1, 2, 3, 4, 5)\ns2 = set(T1)\nstring = \"8SyncDev\"\ns3 = set(string)\n\nprint (s1)\nprint (s2)\nprint (s3)\n```\n\nKết quả sẽ là:\n\n```\n{'Rohan', 69.75, 21, 'Physics'}\n{1, 2, 3, 4, 5}\n{'u', 'a', 'o', 'n', 'r', 's', 'T', 'P', 'i', 't', 'l'}\n```\n\n### Ví dụ 3\n\nTập hợp là một bộ sưu tập các đối tượng riêng biệt. Ngay cả khi bạn lặp lại một đối tượng trong tập hợp, chỉ có một bản sao được giữ lại trong đó.\n\n```python\ns2 = {1, 2, 3, 4, 5, 3,0, 1, 9}\ns3 = {\"a\", \"b\", \"c\", \"d\", \"b\", \"e\", \"a\"}\nprint (s2)\nprint (s3)\n```\n\nKết quả sẽ là:\n\n```\n{0, 1, 2, 3, 4, 5, 9}\n{'a', 'b', 'd', 'c', 'e'}\n```\n\n### Ví dụ 4\n\nChỉ các đối tượng không thể thay đổi được có thể được sử dụng để tạo ra một đối tượng tập hợp. Bất kỳ kiểu số nào, chuỗi và bộ đều được phép, nhưng bạn không thể đặt một danh sách hoặc một từ điển trong một tập hợp.\n\n```python\ns1 = {1, 2, [3, 4, 5], 3,0, 1, 9}\nprint (s1)\ns2 = {\"Rohan\", {\"phy\":50}}\nprint (s2)\n```\n\nKết quả sẽ là:\n\n```\n   s1 = {1, 2, [3, 4, 5], 3,0, 1, 9}\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'\n   s2 = {\"Rohan\", {\"phy\":50}}\n        ^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'dict'\n```\n\nPython sẽ nâng TypeError với thông báo unhashable types 'list' hoặc 'dict'. Việc băm tạo ra một số duy nhất cho một mục không thay đổi mà cho phép tìm kiếm nhanh trong bộ nhớ của máy tính. Python có hàm hash() tích hợp. Hàm này không được hỗ trợ bởi danh sách hoặc từ điển.\n\nMặc dù các đối tượng không thể thay đổi không được lưu trữ trong một tập hợp, nhưng tập hợp chính nó là một đối tượng có thể thay đổi. Python có các toán tử đặc biệt để làm việc với các tập hợp, và có các phương thức khác nhau trong lớp tập hợp để thực hiện các thao tác thêm, loại bỏ, cập nhật trên các phần tử của một đối tượng tập hợp.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 73,
        "fields": {
            "name": "Bài 1. Python - Truy cập Các Phần Tử trong Tập Hợp",
            "content": "# Bài 1. Python - Truy cập Các Phần Tử trong Tập Hợp\n\nVì tập hợp không phải là một loại dữ liệu chuỗi, nên các mục của nó không thể được truy cập một cách cá nhân vì chúng không có chỉ số vị trí (như trong danh sách hoặc bộ). Các mục của tập hợp cũng không có một khóa (như trong từ điển) để truy cập. Bạn chỉ có thể duyệt qua các mục của tập hợp bằng cách sử dụng vòng lặp for.\n\n## Ví dụ\n\n### Ví dụ 1\n\n```python\nlangs = {\"C\", \"C++\", \"Java\", \"Python\"}\nfor lang in langs:\n   print(lang)\n```\n\nKết quả sẽ là:\n\n```\nPython\nC\nC++\nJava\n```\n\n### Kiểm tra Sự Tồn Tại của Phần Tử Trong Tập Hợp\n\nToán tử thành viên của Python cho phép bạn kiểm tra xem một mục cụ thể có sẵn trong tập hợp hay không. Hãy xem ví dụ sau:\n\n### Ví dụ 2\n\n```python\nlangs = {\"C\", \"C++\", \"Java\", \"Python\"}\nprint(\"PHP\" in langs)\nprint(\"Java\" in langs)\n```\n\nKết quả sẽ là:\n\n```\nFalse\nTrue\n```\n\nNhư vậy, bạn không thể truy cập các phần tử của tập hợp một cách trực tiếp nhưng có thể sử dụng vòng lặp for để duyệt qua chúng và sử dụng các toán tử thành viên để kiểm tra sự tồn tại của một phần tử trong tập hợp.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 74,
        "fields": {
            "name": "Bài 2. Python - Thêm Các Phần Tử vào Tập Hợp",
            "content": "# Bài 2. Python - Thêm Các Phần Tử vào Tập Hợp\n\nMặc dù một tập hợp chỉ chứa các đối tượng không thể thay đổi, nhưng tập hợp chính nó là có thể thay đổi. Chúng ta có thể thêm các phần tử mới vào tập hợp bằng cách sử dụng một trong các cách sau đây −\n\n## Thêm Các Phần Tử vào Tập Hợp\n\nPhương thức `add()` trong lớp set thêm một phần tử mới vào tập hợp. Nếu phần tử đã có trong tập hợp, thì không có thay đổi nào trong tập hợp.\n\n**Cú Pháp:**\n```python\nset.add(obj)\n```\n\n**Tham Số:**\n- `obj` − một đối tượng của bất kỳ loại không thể thay đổi nào.\n\n### Ví dụ\n\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nlang1.add(\"Golang\")\nprint(lang1)\n```\n\nKết quả sẽ là:\n\n```\n{'Python', 'C', 'Golang', 'C++', 'Java'}\n```\n\n## Thêm Tập Hợp Sử Dụng Phương thức `update()`\n\nPhương thức `update()` của lớp set bao gồm các mục của tập hợp được chỉ định dưới dạng đối số. Nếu các phần tử trong tập hợp khác có một hoặc nhiều phần tử đã tồn tại, chúng sẽ không được bao gồm.\n\n**Cú Pháp:**\n```python\nset.update(obj)\n```\n\n**Tham Số:**\n- `obj` − một tập hợp hoặc một đối tượng chuỗi (list, tuple, string).\n\n### Ví dụ\n\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nlang2 = {\"PHP\", \"C#\", \"Perl\"}\nlang1.update(lang2)\nprint(lang1)\n```\n\nKết quả sẽ là:\n\n```\n{'Python', 'Java', 'C', 'C#', 'PHP', 'Perl', 'C++'}\n```\n\n## Thêm Bất Kỳ Đối Tượng Chuỗi Nào Như Các Phần Tử của Tập Hợp\n\nPhương thức `update()` cũng chấp nhận bất kỳ đối tượng chuỗi nào là đối số. Ở đây, một tuple là đối số cho phương thức `update()`.\n\n### Ví dụ\n\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nlang2 = (\"PHP\", \"C#\", \"Perl\")\nlang1.update(lang2)\nprint(lang1)\n```\n\nKết quả sẽ là:\n\n```\n{'Java', 'Perl', 'Python', 'C++', 'C#', 'C', 'PHP'}\n```\n\n**Lưu Ý:** Bạn cũng có thể sử dụng phương thức `union()` hoặc phương thức `|` để thực hiện phép hợp các tập hợp.\n\nTrong Python, tập hợp là một loại dữ liệu mạnh mẽ cho việc làm việc với các tập hợp các mục duy nhất, và có nhiều cách để thêm các mục vào một tập hợp một cách linh hoạt.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 75,
        "fields": {
            "name": "Bài 3. Python - Xóa Các Phần Tử của Tập Hợp",
            "content": "# Bài 3. Python - Xóa Các Phần Tử của Tập Hợp\n\nTrong Python, lớp `set` cung cấp các phương thức khác nhau để loại bỏ một hoặc nhiều phần tử từ một đối tượng tập hợp.\n\n## Xóa Các Phần Tử của Tập Hợp\n\n### Phương thức `remove()`\n\nPhương thức `remove()` loại bỏ phần tử được chỉ định khỏi tập hợp, nếu nó tồn tại trong đó. Tuy nhiên, nếu không tồn tại, nó sẽ gây ra lỗi KeyError.\n\n**Cú Pháp:**\n```python\nset.remove(obj)\n```\n\n**Tham Số:**\n- `obj` − một đối tượng bất biến.\n\n**Ví dụ:**\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nprint(\"Tập hợp trước khi xóa: \", lang1)\nlang1.remove(\"Java\")\nprint(\"Tập hợp sau khi xóa: \", lang1)\nlang1.remove(\"PHP\")  # KeyError: 'PHP'\n```\n\n### Phương thức `discard()`\n\nPhương thức `discard()` trong lớp set tương tự như phương thức `remove()`. Sự khác biệt duy nhất là nó không gây ra lỗi nếu đối tượng cần loại bỏ không tồn tại trong tập hợp.\n\n**Cú Pháp:**\n```python\nset.discard(obj)\n```\n\n**Tham Số:**\n- `obj` − Một đối tượng bất biến.\n\n**Ví dụ:**\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nprint(\"Tập hợp trước khi loại bỏ C++: \", lang1)\nlang1.discard(\"C++\")\nprint(\"Tập hợp sau khi loại bỏ C++: \", lang1)\nprint(\"Tập hợp trước khi loại bỏ PHP: \", lang1)\nlang1.discard(\"PHP\")\nprint(\"Tập hợp sau khi loại bỏ PHP: \", lang1)\n```\n\n### Phương thức `pop()`\n\nPhương thức `pop()` trong lớp set loại bỏ một phần tử tùy ý khỏi tập hợp. Phần tử bị loại bỏ sẽ được trả về bởi phương thức. Loại bỏ từ một tập hợp rỗng sẽ gây ra lỗi KeyError.\n\n**Cú Pháp:**\n```python\nobj = set.pop()\n```\n\n**Giá trị Trả về:**\nPhương thức `pop()` trả về đối tượng được loại bỏ từ tập hợp.\n\n**Ví dụ:**\n```python\nlang1 = {\"C\", \"C++\"}\nprint(\"Tập hợp trước khi loại bỏ: \", lang1)\nobj = lang1.pop()\nprint(\"Đối tượng đã bị loại bỏ: \", obj)\nprint(\"Tập hợp sau khi loại bỏ: \", lang1)\nobj = lang1.pop()\nobj = lang1.pop()\n```\n\n### Phương thức `clear()`\n\nPhương thức `clear()` trong lớp set loại bỏ tất cả các phần tử trong tập hợp, tạo ra một tập hợp trống.\n\n**Cú Pháp:**\n```python\nset.clear()\n```\n\n**Ví dụ:**\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nprint(lang1)\nprint(\"Sau khi sử dụng clear():\")\nlang1.clear()\nprint(lang1)\n```\n\n## Kết Luận\n\nTrên đây là một số phương thức trong Python để loại bỏ các phần tử từ một tập hợp. Các phương thức này rất hữu ích trong quá trình làm việc với dữ liệu trong Python.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 76,
        "fields": {
            "name": "Bài 4. Python - Lặp Qua Tập Hợp",
            "content": "# Bài 4. Python - Lặp Qua Tập Hợp\n\n## Lặp Qua Các Phần Tử của Tập Hợp\n\nTập hợp trong Python không phải là một chuỗi, cũng không phải là một lớp kiểu ánh xạ. Do đó, các đối tượng trong một tập hợp không thể được duyệt bằng chỉ số hoặc khóa. Tuy nhiên, bạn có thể duyệt qua từng phần tử trong một tập hợp bằng cách sử dụng một vòng lặp for.\n\n**Ví dụ:**\n```python\nlangs = {\"C\", \"C++\", \"Java\", \"Python\"}\nfor lang in langs:\n   print (lang)\n```\n\nKết quả sẽ là:\n\n```\nC\nPython\nC++\nJava\n```\n\n## Lặp Qua Các Phần Tử của Tập Hợp với Phương Thức `add()`\n\nDưới đây là ví dụ về cách chạy một vòng lặp for qua các phần tử của một tập hợp và sử dụng phương thức `add()` của lớp set để thêm vào một tập hợp khác.\n\n**Ví dụ:**\n```python\ns1={1,2,3,4,5}\ns2={4,5,6,7,8}\nfor x in s2:\n   s1.add(x)\nprint (s1)\n```\n\nKết quả sẽ là:\n\n```\n{1, 2, 3, 4, 5, 6, 7, 8}\n```",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 77,
        "fields": {
            "name": "Bài 5. Python - Kết Hợp Các Tập Hợp",
            "content": "# Bài 5. Python - Kết Hợp Các Tập Hợp\n\n## Sử Dụng Toán Tử \"|\" Để Kết Hợp Các Tập Hợp\n\nKý hiệu \"|\" (dấu đường ống) được định nghĩa như là toán tử hợp nhất. Nó thực hiện phép toán A∪B và trả về một tập hợp các phần tử trong A, B hoặc cả hai. Tập hợp không cho phép các phần tử trùng lặp.\n\n**Ví dụ:**\n```python\ns1={1,2,3,4,5}\ns2={4,5,6,7,8}\ns3 = s1|s2\nprint (s3)\n```\n\nKết quả sẽ là:\n\n```\n{1, 2, 3, 4, 5, 6, 7, 8}\n```\n\n## Sử Dụng Phương Thức `union()` Để Kết Hợp Các Tập Hợp\n\nLớp set có phương thức union() thực hiện cùng một phép toán như toán tử |. Nó trả về một đối tượng tập hợp chứa tất cả các phần tử trong cả hai tập hợp, loại bỏ các phần tử trùng lặp.\n\n**Ví dụ:**\n```python\ns1={1,2,3,4,5}\ns2={4,5,6,7,8}\ns3 = s1.union(s2)\nprint (s3)\n```\n\n## Sử Dụng Phương Thức `update()` Để Kết Hợp Các Tập Hợp\n\nPhương thức update() cũng kết hợp hai tập hợp, nhưng khác với phương thức union(), nó không trả về một đối tượng tập hợp mới. Thay vào đó, các phần tử của tập hợp thứ hai được thêm vào tập hợp đầu tiên, và các phần tử trùng lặp không được phép.\n\n**Ví dụ:**\n```python\ns1={1,2,3,4,5}\ns2={4,5,6,7,8}\ns1.update(s2)\nprint (s1)\n```\n\n## Sử Dụng Toán Tử Unpacking Để Kết Hợp Các Tập Hợp\n\nTrong Python, ký hiệu \"*\" được sử dụng như là toán tử unpacking. Toán tử unpacking gán mỗi phần tử trong một bộ sưu tập cho một biến riêng biệt.\n\n**Ví dụ:**\n```python\ns1={1,2,3,4,5}\ns2={4,5,6,7,8}\ns3 = {*s1, *s2}\nprint (s3)\n```",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 78,
        "fields": {
            "name": "Bài 6. Python - Sao Chép Tập Hợp",
            "content": "# Bài 6. Python - Sao Chép Tập Hợp\n\n## Sử Dụng Phương Thức `copy()` để Sao Chép Tập Hợp\n\nPhương thức `copy()` trong lớp set tạo một bản sao sâu của một đối tượng tập hợp.\n\n**Cú Pháp**\n```python\nset.copy()\n```\n\n**Giá Trị Trả Về**\nPhương thức `copy()` trả về một tập hợp mới là một bản sao sâu của tập hợp hiện tại.\n\n**Ví dụ**\n```python\nlang1 = {\"C\", \"C++\", \"Java\", \"Python\"}\nprint (\"lang1: \", lang1, \"id(lang1): \", id(lang1))\nlang2 = lang1.copy()\nprint (\"lang2: \", lang2, \"id(lang2): \", id(lang2))\nlang1.add(\"PHP\")\nprint (\"After updating lang1\")\nprint (\"lang1: \", lang1, \"id(lang1): \", id(lang1))\nprint (\"lang2: \", lang2, \"id(lang2): \", id(lang2))\n```\n\n**Kết Quả**\n```\nlang1: {'Python', 'Java', 'C', 'C++'} id(lang1): 2451578196864\nlang2: {'Python', 'Java', 'C', 'C++'} id(lang2): 2451578197312\nAfter updating lang1\nlang1: {'Python', 'C', 'C++', 'PHP', 'Java'} id(lang1): 2451578196864\nlang2: {'Python', 'Java', 'C', 'C++'} id(lang2): 2451578197312\n```\n\nTrong ví dụ này, chúng ta sao chép `lang1` thành `lang2` bằng cách sử dụng phương thức `copy()`. Sau đó, khi thêm phần tử \"PHP\" vào `lang1`, `lang2` không bị ảnh hưởng vì chúng là hai tập hợp khác biệt.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 79,
        "fields": {
            "name": "Bài 7. Python - Toán Tử Tập Hợp",
            "content": "# Bài 7. Python - Toán Tử Tập Hợp\n\n## Toán Tử Hợp (Union) Tập Hợp Python (|)\n\nHợp của hai tập hợp là một tập hợp chứa tất cả các phần tử nằm trong A hoặc trong B hoặc cả hai. Ví dụ:\n\n{1,2}∪{2,3}={1,2,3}\n\nPython sử dụng ký hiệu \"|\" như là toán tử hợp. Ví dụ sau sử dụng toán tử \"|\" và trả về hợp của hai tập hợp.\n\n**Ví dụ**\n```python\ns1 = {1,2,3,4,5}\ns2 = {4,5,6,7,8}\ns3 = s1 | s2\nprint (\"Hợp của s1 và s2: \", s3)\n```\n\n**Kết Quả**\n```\nHợp của s1 và s2: {1, 2, 3, 4, 5, 6, 7, 8}\n```\n\n## Toán Tử Giao (Intersection) Tập Hợp Python (&)\n\nGiao của hai tập hợp AA và BB, được ký hiệu bởi A∩B, bao gồm tất cả các phần tử đồng thời thuộc A và B. Ví dụ:\n\n{1,2}∩{2,3}={2}\n\nPython sử dụng ký hiệu \"&\" như là toán tử giao. Ví dụ sau sử dụng toán tử \"&\" và trả về giao của hai tập hợp.\n\n**Ví dụ**\n```python\ns1 = {1,2,3,4,5}\ns2 = {4,5,6,7,8}\ns3 = s1 & s2\nprint (\"Giao của s1 và s2: \", s3)\n```\n\n**Kết Quả**\n```\nGiao của s1 và s2: {4, 5}\n```\n\n## Toán Tử Hiệu (Difference) Tập Hợp Python (-)\n\nHiệu (hoặc sự trừ) được định nghĩa như sau. Tập A−B bao gồm các phần tử thuộc A nhưng không thuộc B. Ví dụ:\n\nNếu A={1,2,3} và B={3,5}, thì A−B={1,2}\n\nPython sử dụng ký hiệu \"-\" như là toán tử hiệu.\n\n**Ví dụ**\n```python\ns1 = {1,2,3,4,5}\ns2 = {4,5,6,7,8}\ns3 = s1 - s2\nprint (\"Hiệu của s1 - s2: \", s3)\ns3 = s2 - s1\nprint (\"Hiệu của s2 - s1: \", s3)\n```\n\n**Kết Quả**\n```\nHiệu của s1 - s2: {1, 2, 3}\nHiệu của s2 - s1: {8, 6, 7}\n```\n\n## Toán Tử Hiệu Đối Xứng (Symmetric Difference) Tập Hợp Python (^)\n\nHiệu đối xứng của A và B được ký hiệu là \"A Δ B\" và được định nghĩa bởi\n\nA Δ B = (A − B) ⋃ (B − A)\n\nPython sử dụng ký hiệu \"^\" như là toán tử hiệu đối xứng.\n\n**Ví dụ**\n```python\ns1 = {1,2,3,4,5}\ns2 = {4,5,6,7,8}\ns3 = s1 - s2\nprint (\"Hiệu của s1 - s2: \", s3)\ns3 = s2 - s1\nprint (\"Hiệu của s2 - s1: \", s3)\ns3 = s1 ^ s2\nprint (\"Hiệu Đối Xứng trong s1 và s2: \", s3)\n```\n\n**Kết Quả**\n```\nHiệu của s1 - s2: {1, 2, 3}\nHiệu của s2 - s1: {8, 6, 7}\nHiệu Đối Xứng trong s1 và s2: {1, 2, 3, 6, 7, 8}\n```",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 80,
        "fields": {
            "name": "Bài 8. Python - Các Phương Thức của Tập Hợp",
            "content": "# Bài 8. Python - Các Phương Thức của Tập Hợp\n\nTrong lớp tập hợp của Python, các phương thức sau được định nghĩa:\n\n1. **add()**: Thêm một phần tử vào tập hợp.\n   \n2. **clear()**: Xóa tất cả các phần tử khỏi tập hợp.\n\n3. **copy()**: Trả về một bản sao nông (shallow copy) của tập hợp.\n\n4. **difference()**: Trả về hiệu của hai hoặc nhiều tập hợp khác nhau dưới dạng một tập hợp mới.\n\n5. **difference_update()**: Xóa tất cả các phần tử của một tập hợp khác ra khỏi tập hợp này.\n\n6. **discard()**: Xóa một phần tử khỏi tập hợp nếu nó là thành viên của tập hợp.\n\n7. **intersection()**: Trả về giao của hai tập hợp dưới dạng một tập hợp mới.\n\n8. **intersection_update()**: Cập nhật một tập hợp với giao của chính nó và một tập hợp khác.\n\n9. **isdisjoint()**: Trả về True nếu hai tập hợp có giao nhau rỗng.\n\n10. **issubset()**: Trả về True nếu một tập hợp khác chứa tập hợp này.\n\n11. **issuperset()**: Trả về True nếu tập hợp này chứa một tập hợp khác.\n\n12. **pop()**: Xóa và trả về một phần tử tùy ý từ tập hợp.\n\n13. **remove()**: Xóa một phần tử khỏi tập hợp; phần tử đó phải là thành viên của tập hợp.\n\n14. **symmetric_difference()**: Trả về hiệu đối xứng của hai tập hợp dưới dạng một tập hợp mới.\n\n15. **symmetric_difference_update()**: Cập nhật một tập hợp với hiệu đối xứng của chính nó và một tập hợp khác.\n\n16. **union()**: Trả về hợp của các tập hợp dưới dạng một tập hợp mới.\n\n17. **update()**: Cập nhật một tập hợp với hợp của chính nó và các tập hợp khác.",
            "lesson": 6,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 81,
        "fields": {
            "name": "Bài 0. Python - Từ Điển (Dictionaries)",
            "content": "# Bài 0. Python - Từ Điển (Dictionaries)\n\nTừ điển (dictionary) là một trong những kiểu dữ liệu tích hợp sẵn trong Python. Từ điển trong Python là một ví dụ về kiểu ánh xạ (mapping type). Một đối tượng ánh xạ \"ánh xạ\" giá trị của một đối tượng khác.\n\nTrong một từ điển ngôn ngữ, chúng ta có các cặp từ và nghĩa tương ứng. Hai phần của cặp là key (từ) và value (nghĩa). Tương tự, từ điển Python cũng là một tập hợp các cặp key:value. Các cặp được phân tách bằng dấu phẩy và đặt trong dấu ngoặc nhọn {}.\n\nDưới đây là một số ví dụ về các đối tượng từ điển Python:\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nnumbers = {10:\"Ten\", 20:\"Twenty\", 30:\"Thirty\",40:\"Forty\"}\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\n```\n\n**Ví dụ 1**:\nChỉ số, chuỗi hoặc tuple có thể được sử dụng làm key. Tất cả chúng đều là bất biến. Bạn có thể sử dụng một đối tượng của bất kỳ kiểu nào làm value. Vì vậy, các định nghĩa từ điển sau cũng hợp lệ:\n\n```python\nd1 = {\"Fruit\":[\"Mango\",\"Banana\"], \"Flower\":[\"Rose\", \"Lotus\"]}\nd2 = {('India, USA'):'Countries', ('New Delhi', 'New York'):'Capitals'}\nprint (d1)\nprint (d2)\n```\n\nKết quả sẽ là:\n\n```\n{'Fruit': ['Mango', 'Banana'], 'Flower': ['Rose', 'Lotus']}\n{'India, USA': 'Countries', ('New Delhi', 'New York'): 'Capitals'}\n```\n\n**Ví dụ 2**:\nPython không chấp nhận các đối tượng có thể thay đổi như danh sách (list) làm key, và sẽ gây ra TypeError.\n\n```python\nd1 = {[\"Mango\",\"Banana\"]:\"Fruit\", \"Flower\":[\"Rose\", \"Lotus\"]}\nprint (d1)\n```\n\nNó sẽ gây ra một TypeError.\n\n**Ví dụ 3**:\nBạn có thể gán một giá trị cho nhiều key trong một từ điển, nhưng một key không thể xuất hiện nhiều hơn một lần trong một từ điển.\n\n```python\nd1 = {\"Banana\":\"Fruit\", \"Rose\":\"Flower\", \"Lotus\":\"Flower\", \"Mango\":\"Fruit\"}\nd2 = {\"Fruit\":\"Banana\",\"Flower\":\"Rose\", \"Fruit\":\"Mango\", \"Flower\":\"Lotus\"}\nprint (d1)\nprint (d2)\n```\n\nKết quả sẽ là:\n\n```\n{'Banana': 'Fruit', 'Rose': 'Flower', 'Lotus': 'Flower', 'Mango': 'Fruit'}\n{'Fruit': 'Mango', 'Flower': 'Lotus'}\n**Toán tử của Từ Điển trong Python**\n\nTrong Python, các toán tử sau được định nghĩa để sử dụng với các toán hạng từ điển. Trong ví dụ, các đối tượng từ điển sau được sử dụng:\n\n```python\nd1 = {'a': 2, 'b': 4, 'c': 30}\nd2 = {'a1': 20, 'b1': 40, 'c1': 60}\n```\n\n| Toán tử   | Mô tả                              | Ví dụ                                                                               |\n| --------- | ---------------------------------- | ----------------------------------------------------------------------------------- |\n| dict[key] | Trích xuất/gán giá trị được ánh xạ | `print (d1['b'])` trích xuất giá trị 4, `d1['b'] = 'Z'` gán giá trị mới cho key 'b' |\n| dict1     | dict2                              | Hợp của hai đối tượng từ điển, trả về đối tượng mới                                 | `d3=d1 | d2 ; print (d3)` trả về `{'a': 2, 'b': 4, 'c': 30, 'a1': 20, 'b1': 40, 'c1': 60}` |\n| dict1     | =dict2                             | Toán tử hợp của từ điển được bổ sung                                                | `d1    | =d2; print (d1)` trả về `{'a': 2, 'b': 4, 'c': 30, 'a1': 20, '                    |\n\nb1': 40, 'c1': 60}` |",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 82,
        "fields": {
            "name": "Bài 1. Python - Truy Cập Các Mục của Từ Điển",
            "content": "# Bài 1. Python - Truy Cập Các Mục của Từ Điển\n\nTrong Python, bạn có thể sử dụng toán tử \"[ ]\" để truy xuất giá trị được liên kết với một key cụ thể trong đối tượng từ điển, mặc dù từ điển không phải là một chuỗi vì các phần tử trong từ điển không được đánh chỉ mục.\n\n**Ví dụ 1**:\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nprint (\"Thủ đô của Gujarat là: \", capitals['Gujarat'])\nprint (\"Thủ đô của Karnataka là: \", capitals['Karnataka'])\n```\n\nKết quả sẽ là:\n\n```\nThủ đô của Gujarat là: Gandhinagar\nThủ đô của Karnataka là: Bengaluru\n```\n\n**Ví dụ 2**:\nPython sẽ gây ra một KeyError nếu key được đưa vào trong dấu ngoặc vuông không có trong đối tượng từ điển.\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nprint (\"Thủ đô của Haryana là: \", capitals['Haryana'])\n```\n\nNó sẽ gây ra một lỗi KeyError.\n\n**Sử dụng Phương thức get()**:\n\nPhương thức get() trong lớp dict của Python trả về giá trị được ánh xạ với key đã cho.\n\n**Cú pháp**:\n\n```python\nval = dict.get(\"key\")\n```\n\n**Tham số**:\n\n- `key`: Một đối tượng không thay đổi được sử dụng làm key trong đối tượng từ điển.\n\n**Giá trị Trả về**:\n\nPhương thức get() trả về đối tượng được ánh xạ với key đã cho.\n\n**Ví dụ 3**:\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nprint (\"Thủ đô của Gujarat là: \", capitals.get('Gujarat'))\nprint (\"Thủ đô của Karnataka là: \", capitals.get('Karnataka'))\n```\n\nKết quả sẽ là:\n\n```\nThủ đô của Gujarat là: Gandhinagar\nThủ đô của Karnataka là: Bengaluru\n```\n\n**Ví dụ 4**:\n\nKhác với toán tử \"[]\", phương thức get() không gây ra lỗi nếu key không được tìm thấy; nó trả về None.\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nprint (\"Thủ đô của Haryana là: \", capitals.get('Haryana'))\n```\n\nKết quả sẽ là:\n\n```\nThủ đô của Haryana là: None\n```\n\n**Ví dụ 5**:\n\nPhương thức get() chấp nhận một đối số chuỗi tùy chọn. Nếu nó được cung cấp và nếu key không được tìm thấy, chuỗi này sẽ trở thành giá trị trả về.\n\n```python\ncapitals = {\"Maharashtra\":\"Mumbai\", \"Gujarat\":\"Gandhinagar\", \"Telangana\":\"Hyderabad\", \"Karnataka\":\"Bengaluru\"}\nprint (\"Thủ đô của Haryana là: \", capitals.get('Haryana', 'Không tìm thấy'))\n```\n\nKết quả sẽ là:\n\n```\nThủ đô của Haryana là: Không tìm thấy\n```",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 83,
        "fields": {
            "name": "Bài 2. Python - Thay Đổi Các Mục của Từ Điển",
            "content": "# Bài 2. Python - Thay Đổi Các Mục của Từ Điển\n\nNgoài cách biểu diễn từ điển bằng cách đặt các cặp key:value phân tách bằng dấu phẩy trong dấu ngoặc nhọn, chúng ta có thể tạo đối tượng từ điển bằng hàm tích hợp sẵn `dict()`.\n\n**Tạo Đối Tượng Từ Điển Rỗng**\n\nSử dụng hàm `dict()` mà không có đối số nào tạo ra một đối tượng từ điển rỗng. Nó tương đương với việc không đặt gì giữa các dấu ngoặc nhọn.\n\n**Ví dụ**:\n\n```python\nd1 = dict()\nd2 = {}\nprint ('d1: ', d1)\nprint ('d2: ', d2)\n```\n\nKết quả sẽ là:\n\n```\nd1: {}\nd2: {}\n```\n\n**Tạo Đối Tượng Từ Điển từ Danh Sách hoặc Bộ Các Tuple**\n\nHàm `dict()` xây dựng một từ điển từ một danh sách hoặc bộ các tuple có hai phần tử. Phần tử đầu tiên trong một tuple được xem xét là key và phần thứ hai là giá trị tương ứng.\n\n**Ví dụ**:\n\n```python\nd1=dict([('a', 100), ('b', 200)])\nd2 = dict((('a', 'one'), ('b', 'two')))\nprint ('d1: ', d1)\nprint ('d2: ', d2)\n```\n\nKết quả sẽ là:\n\n```\nd1: {'a': 100, 'b': 200}\nd2: {'a': 'one', 'b': 'two'}\n```\n\n**Tạo Đối Tượng Từ Điển từ Các Đối Số Từ Khóa**\n\nHàm `dict()` có thể nhận bất kỳ số lượng đối số từ khóa nào với các cặp tên=giá trị. Nó trả về một đối tượng từ điển với tên là key và liên kết nó với giá trị tương ứng.\n\n**Ví dụ**:\n\n```python\nd1=dict(a= 100, b=200)\nd2 = dict(a='one', b='two')\nprint ('d1: ', d1)\nprint ('d2: ', d2)\n```\n\nKết quả sẽ là:\n\n```\nd1: {'a': 100, 'b': 200}\nd2: {'a': 'one', 'b': 'two'}\n```",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 84,
        "fields": {
            "name": "Bài 3. Python - Thêm Mục vào Từ Điển",
            "content": "# Bài 3. Python - Thêm Mục vào Từ Điển\n\n## Sử dụng Toán Tử\nToán tử \"[]\" (được sử dụng để truy cập giá trị được ánh xạ với một key trong từ điển) được sử dụng để cập nhật một cặp key-value hiện có cũng như thêm một cặp mới.\n\n**Cú Pháp**:\n```python\ndict[\"key\"] = val\n```\n\nNếu key đã tồn tại trong đối tượng từ điển, giá trị của nó sẽ được cập nhật thành val. Nếu key không tồn tại trong từ điển, một cặp key-value mới sẽ được thêm vào.\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \", marks)\nmarks['Laxman'] = 95\nprint (\"Từ điển marks sau khi cập nhật: \", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật: {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật: {'Savita': 67, 'Imtiaz': 88, 'Laxman': 95, 'David': 49}\n```\n\n**Ví dụ**:\n\nTuy nhiên, một mục với key 'Krishnan' không có trong từ điển, do đó một cặp key-value mới được thêm vào.\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \", marks)\nmarks['Krishan'] = 74\nprint (\"Từ điển marks sau khi cập nhật: \", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật: {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật: {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49, 'Krishan': 74}\n```\n\n## Sử dụng Phương Thức update()\nBạn có thể sử dụng phương thức `update()` trong lớp dict theo ba cách khác nhau:\n\n### Cập Nhật với Từ Điển Khác\nTrong trường hợp này, đối số của phương thức `update()` là một từ điển khác. Giá trị của các key phổ biến trong cả hai từ điển được cập nhật. Đối với các key mới, cặp key-value được thêm vào từ điển hiện tại.\n\n**Cú Pháp**:\n```python\nd1.update(d2)\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks1 = {\"Sharad\": 51, \"Mushtaq\": 61, \"Laxman\": 89}\nmarks.update(marks1)\nprint (\"Từ điển marks sau khi cập nhật: \\n\", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```\n\n### Cập Nhật với Iterable\nNếu đối số của phương thức `update()` là một danh sách hoặc bộ các tuple có hai phần tử, một mục cho mỗi phần tử sẽ được thêm vào từ điển hiện tại, hoặc được cập nhật nếu key đã tồn tại.\n\n**Cú Pháp**:\n```python\nd1.update([(k1, v1), (k2, v2)])\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks1 = [(\"Sharad\",\n\n 51), (\"Mushtaq\", 61), (\"Laxman\", 89)]\nmarks.update(marks1)\nprint (\"Từ điển marks sau khi cập nhật: \\n\", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```\n\n### Cập Nhật với Các Đối Số Từ Khóa\nPhiên bản thứ ba của phương thức `update()` chấp nhận một danh sách các đối số từ khóa trong định dạng tên=giá trị. Các cặp key-value mới được thêm vào, hoặc giá trị của key hiện có được cập nhật.\n\n**Cú Pháp**:\n```python\nd1.update(k1=v1, k2=v2)\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks.update(Sharad = 51, Mushtaq = 61, Laxman = 89)\nprint (\"Từ điển marks sau khi cập nhật: \\n\", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```\n\n## Sử Dụng Toán Tử Unpack\nKý hiệu \"**\" được đặt trước một đối tượng từ điển giải nén nó thành một danh sách các tuple, mỗi tuple với key và value. Hai đối tượng dict được giải nén và kết hợp lại với nhau để thu được một từ điển mới.\n\n**Cú Pháp**:\n```python\nd3 = {**d1, **d2}\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks1 = {\"Sharad\": 51, \"Mushtaq\": 61, \"Laxman\": 89}\nnewmarks = {**marks, **marks1}\nprint (\"Từ điển marks sau khi cập nhật: \\n\", newmarks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```\n\n## Sử Dụng Toán Tử Union (|)\nPython giới thiệu \"|\" (ký hiệu đường ống) làm toán tử union cho các toán hạng từ điển. Nó cập nhật các key đã tồn tại trong đối tượng dict bên trái và thêm các cặp key-value mới để trả về một đối tượng dict mới.\n\n**Cú Pháp**:\n```python\nd3 = d1 | d2\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks1 = {\"Sharad\": 51, \"Mushtaq\": 61, \"Laxman\": 89}\nnewmarks = marks | marks1\nprint (\"Từ điển marks sau khi cập nhật: \\n\", newmarks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Sav\n\nita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```\n\n## Sử Dụng Toán Tử \"|=\" (|)\nToán tử \"|=\" là một toán tử Union được bổ sung. Nó thực hiện cập nhật trong chỗ trên toán tử từ điển ở bên trái bằng cách thêm các key mới trong toán tử từ điển ở bên phải, và cập nhật các key đã tồn tại.\n\n**Cú Pháp**:\n```python\nd1 |= d2\n```\n\n**Ví dụ**:\n\n```python\nmarks = {\"Savita\":67, \"Imtiaz\":88, \"Laxman\":91, \"David\":49}\nprint (\"Từ điển marks trước khi cập nhật: \\n\", marks)\nmarks1 = {\"Sharad\": 51, \"Mushtaq\": 61, \"Laxman\": 89}\nmarks |= marks1\nprint (\"Từ điển marks sau khi cập nhật: \\n\", marks)\n```\n\nKết quả sẽ là:\n\n```\nTừ điển marks trước khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 91, 'David': 49}\nTừ điển marks sau khi cập nhật:\n {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}\n```",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 85,
        "fields": {
            "name": "Bài 4. Xóa các Phần Tử trong Từ Điển Python",
            "content": "# Bài 4. Xóa các Phần Tử trong Từ Điển Python\n\nTrong Python, có một số cách để xóa các phần tử khỏi một từ điển (dictionary). Dưới đây là các phương pháp thường được sử dụng:\n\n## Sử Dụng Từ Khóa `del`\n\nTừ khóa `del` của Python được sử dụng để xóa một phần tử từ một từ điển.\n\n**Cú pháp:**\n```python\ndel dict['key']\n```\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nprint(\"Từ điển numbers trước khi xóa: \\n\", numbers)\ndel numbers[20]\nprint(\"Từ điển numbers sau khi xóa: \\n\", numbers)\n```\n\nKết quả:\n```\nTừ điển numbers trước khi xóa:\n {10: 'Ten', 20: 'Twenty', 30: 'Thirty', 40: 'Forty'}\nTừ điển numbers sau khi xóa:\n {10: 'Ten', 30: 'Thirty', 40: 'Forty'}\n```\n\n## Sử Dụng Phương Thức `pop()`\n\nPhương thức `pop()` của lớp `dict` gây ra việc loại bỏ một phần tử với key đã chỉ định khỏi từ điển.\n\n**Cú Pháp:**\n```python\nval = dict.pop(key)\n```\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nprint(\"Từ điển numbers trước khi pop: \\n\", numbers)\nval = numbers.pop(20)\nprint(\"Từ điển numbers sau khi pop: \\n\", numbers)\nprint(\"Giá trị pop: \", val)\n```\n\nKết quả:\n```\nTừ điển numbers trước khi pop: \n {10: 'Ten', 20: 'Twenty', 30: 'Thirty', 40: 'Forty'}\nTừ điển numbers sau khi pop: \n {10: 'Ten', 30: 'Thirty', 40: 'Forty'}\nGiá trị pop:  Twenty\n```\n\n## Sử Dụng Phương Thức `popitem()`\n\nPhương thức `popitem()` trong lớp `dict` không nhận bất kỳ đối số nào. Nó loại bỏ cặp key-value được chèn cuối cùng và trả về nó dưới dạng một bộ giá trị.\n\n**Cú Pháp:**\n```python\nval = dict.popitem()\n```\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nprint(\"Từ điển numbers trước khi pop: \\n\", numbers)\nval = numbers.popitem()\nprint(\"Từ điển numbers sau khi pop: \\n\", numbers)\nprint(\"Giá trị pop: \", val)\n```\n\nKết quả:\n```\nTừ điển numbers trước khi pop: \n {10: 'Ten', 20: 'Twenty', 30: 'Thirty', 40: 'Forty'}\nTừ điển numbers sau khi pop: \n {10: 'Ten', 20: 'Twenty', 30: 'Thirty'}\nGiá trị pop:  (40, 'Forty')\n```\n\n## Sử Dụng Phương Thức `clear()`\n\nPhương thức `clear()` trong lớp `dict` loại bỏ tất cả các phần tử từ đối tượng từ điển và trả về một đối tượng trống.\n\n**Cú Pháp:**\n```python\ndict.clear()\n```\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nprint(\"Từ điển numbers trước khi clear: \\n\", numbers)\nnumbers.clear()\nprint(\"Từ điển numbers sau khi clear: \\n\", numbers)\n```\n\nKết quả:\n```\nTừ điển numbers trước khi clear: \n {10: 'Ten', 20: 'Twenty', 30: 'Thirty', 40: 'Forty'}\nTừ điển numbers sau khi clear: \n {}\n```\n\nCác phương thức và từ khóa này cho phép bạn linh hoạt trong việc xóa và quản lý các phần tử trong từ điển Python.",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 86,
        "fields": {
            "name": "Bài 5. Đối Tượng Xem Từ Điển trong Python",
            "content": "# Bài 5. Đối Tượng Xem Từ Điển trong Python\n\nTrong Python, các phương thức items(), keys() và values() của lớp dict trả về các đối tượng xem (view objects). Các xem này được cập nhật động mỗi khi có bất kỳ thay đổi nào trong nội dung của đối tượng từ điển gốc của chúng.\n\n## Phương Thức items()\n\nPhương thức items() trả về một đối tượng dict_items xem. Nó chứa một danh sách các bộ, mỗi bộ được tạo thành từ các cặp key, value tương ứng.\n\n**Cú Pháp:**\n```python\nobj = dict.items()\n```\n\n**Giá Trị Trả Về:**\nPhương thức items() trả về đối tượng dict_items, đó là một xem động của các bộ (key, value).\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nobj = numbers.items()\nprint('Kiểu của obj: ', type(obj))\nprint(obj)\nprint(\"Cập nhật từ điển numbers\")\nnumbers.update({50: \"Fifty\"})\nprint(\"Xem được cập nhật tự động\")\nprint(obj)\n```\n\nKết quả:\n```\nKiểu của obj:  <class 'dict_items'>\ndict_items([(10, 'Ten'), (20, 'Twenty'), (30, 'Thirty'), (40, 'Forty')])\nCập nhật từ điển numbers\nXem được cập nhật tự động\ndict_items([(10, 'Ten'), (20, 'Twenty'), (30, 'Thirty'), (40, 'Forty'), (50, 'Fifty')])\n```\n\n## Phương Thức keys()\n\nPhương thức keys() của lớp dict trả về đối tượng dict_keys, đó là một danh sách của tất cả các key được xác định trong từ điển. Đây là một đối tượng xem, vì nó được cập nhật tự động mỗi khi có bất kỳ hành động cập nhật nào được thực hiện trên đối tượng từ điển.\n\n**Cú Pháp:**\n```python\nobj = dict.keys()\n```\n\n**Giá Trị Trả Về:**\nPhương thức keys() trả về đối tượng dict_keys, đó là một xem của các keys trong từ điển.\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nobj = numbers.keys()\nprint('Kiểu của obj: ', type(obj))\nprint(obj)\nprint(\"Cập nhật từ điển numbers\")\nnumbers.update({50: \"Fifty\"})\nprint(\"Xem được cập nhật tự động\")\nprint(obj)\n```\n\nKết quả:\n```\nKiểu của obj:  <class 'dict_keys'>\ndict_keys([10, 20, 30, 40])\nCập nhật từ điển numbers\nXem được cập nhật tự động\ndict_keys([10, 20, 30, 40, 50])\n```\n\n## Phương Thức values()\n\nPhương thức values() trả về một xem của tất cả các giá trị có trong từ điển. Đối tượng là kiểu dict_values, được cập nhật tự động.\n\n**Cú Pháp:**\n```python\nobj = dict.values()\n```\n\n**Giá Trị Trả Về:**\nPhương thức values() trả về một xem dict_values của tất cả các giá trị có trong từ điển.\n\n**Ví dụ:**\n```python\nnumbers = {10: \"Ten\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\"}\nobj = numbers.values()\nprint('Kiểu của obj: ', type(obj))\nprint(obj)\nprint(\"Cập nhật từ điển numbers\")\nnumbers.update({50: \"Fifty\"})\nprint(\"Xem được cập nhật tự động\")\nprint(obj)\n```\n\nKết quả:\n```\nKiểu của obj:  <class 'dict_values'>\ndict_values(['Ten', 'Twenty', 'Thirty', 'Forty'])\nCập nhật từ điển numbers\nXem được cập nhật tự động\ndict_values(['Ten', 'Twenty', 'Thirty', 'Forty', 'Fifty'])\n```\n\nCác phương thức items(), keys() và values() cho phép bạn truy cập vào dữ liệu trong từ điển một cách linh hoạt và tiện lợi, đồng thời tự động cập nhật các xem của chúng khi có sự thay đổi trong từ điển gốc.",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 87,
        "fields": {
            "name": "Bài 6. Sao Chép Từ Điển trong Python",
            "content": "# Bài 6. Sao Chép Từ Điển trong Python\n\nTrong Python, vì một biến chỉ là một nhãn hoặc tham chiếu đến một đối tượng trong bộ nhớ, toán tử gán đơn giản không tạo ra bản sao của đối tượng.\n\n**Ví dụ 1:**\n\nTrong ví dụ này, chúng ta có một từ điển \"d1\" và chúng ta gán nó cho một biến khác \"d2\". Nếu \"d1\" được cập nhật, các thay đổi cũng phản ánh trong \"d2\".\n\n```python\nd1 = {\"a\":11, \"b\":22, \"c\":33}\nd2 = d1\nprint (\"id:\", id(d1), \"dict: \",d1)\nprint (\"id:\", id(d2), \"dict: \",d2)\n\nd1[\"b\"] = 100\nprint (\"id:\", id(d1), \"dict: \",d1)\nprint (\"id:\", id(d2), \"dict: \",d2)\n```\n\nKết quả:\n```\nid: 2215278891200 dict: {'a': 11, 'b': 22, 'c': 33}\nid: 2215278891200 dict: {'a': 11, 'b': 22, 'c': 33}\nid: 2215278891200 dict: {'a': 11, 'b': 100, 'c': 33}\nid: 2215278891200 dict: {'a': 11, 'b': 100, 'c': 33}\n```\n\nĐể tránh điều này và tạo một bản sao nông (shallow copy) của một từ điển, sử dụng phương thức copy() thay vì toán tử gán.\n\n**Ví dụ 2:**\n\n```python\nd1 = {\"a\":11, \"b\":22, \"c\":33}\nd2 = d1.copy()\nprint (\"id:\", id(d1), \"dict: \",d1)\nprint (\"id:\", id(d2), \"dict: \",d2)\nd1[\"b\"] = 100\nprint (\"id:\", id(d1), \"dict: \",d1)\nprint (\"id:\", id(d2), \"dict: \",d2)\n```\n\nKết quả:\n```\nKhi \"d1\" được cập nhật, \"d2\" sẽ không thay đổi bây giờ vì \"d2\" là bản sao của đối tượng từ điển, không chỉ là một tham chiếu.\n\nid: 1586671734976 dict: {'a': 11, 'b': 22, 'c': 33}\nid: 1586673973632 dict: {'a': 11, 'b': 22, 'c': 33}\nid: 1586671734976 dict: {'a': 11, 'b': 100, 'c': 33}\nid: 1586673973632 dict: {'a': 11, 'b': 22, 'c': 33}\n```\n\nTrong ví dụ thứ hai, khi \"d1\" được cập nhật, \"d2\" không thay đổi, vì \"d2\" là một bản sao của đối tượng từ điển, không chỉ là một tham chiếu.",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 88,
        "fields": {
            "name": "Bài 7. Từ Điển Lồng Nhau trong Python",
            "content": "# Bài 7. Từ Điển Lồng Nhau trong Python\n\nTrong Python, một từ điển được gọi là có cấu trúc lồng nhau nếu giá trị của một hoặc nhiều key là một từ điển khác. Một từ điển lồng nhau thường được sử dụng để lưu trữ một cấu trúc dữ liệu phức tạp.\n\nĐoạn mã sau đại diện cho một từ điển lồng nhau:\n\n```python\nmarklist = {\n   \"Mahesh\" : {\"Phy\" : 60, \"maths\" : 70},\n   \"Madhavi\" : {\"phy\" : 75, \"maths\" : 68},\n   \"Mitchell\" : {\"phy\" : 67, \"maths\" : 71}\n}\n```\n\n**Ví dụ 1:**\nBạn cũng có thể sử dụng một vòng lặp for để duyệt qua từ điển lồng nhau, như trong phần trước.\n\n```python\nmarklist = {\n   \"Mahesh\" : {\"Phy\" : 60, \"maths\" : 70},\n   \"Madhavi\" : {\"phy\" : 75, \"maths\" : 68},\n   \"Mitchell\" : {\"phy\" : 67, \"maths\" : 71}\n}\nfor k,v in marklist.items():\n   print (k, \":\", v)\n```\n\nKết quả:\n```\nMahesh : {'Phy': 60, 'maths': 70}\nMadhavi : {'phy': 75, 'maths': 68}\nMitchell : {'phy': 67, 'maths': 71}\n```\n\n**Ví dụ 2:**\nCó thể truy cập giá trị từ một từ điển lồng nhau bằng cách sử dụng [] hoặc phương thức get().\n\n```python\nprint(marklist.get(\"Madhavi\")['maths'])\nobj = marklist['Mahesh']\nprint(obj.get('Phy'))\nprint(marklist['Mitchell'].get('maths'))\n```\n\nKết quả:\n```\n68\n60\n71\n```\n\nTrong ví dụ này, chúng ta truy cập các giá trị từ từ điển lồng nhau bằng cách sử dụng các key và phương thức get().",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 89,
        "fields": {
            "name": "Bài 8. Các Phương Thức của Từ Điển trong Python",
            "content": "# Bài 8. Các Phương Thức của Từ Điển trong Python\n\nTrong Python, một từ điển là một đối tượng của lớp dict tích hợp, được định nghĩa các phương thức sau:\n\n1. **`dict.clear()`**: Xóa tất cả các phần tử của từ điển `dict`.\n2. **`dict.copy()`**: Trả về một bản sao nông của từ điển `dict`.\n3. **`dict.fromkeys(seq, value)`**: Tạo một từ điển mới với các khóa từ `seq` và các giá trị được đặt thành `value`.\n4. **`dict.get(key, default=None)`**: Đối với khóa `key`, trả về giá trị hoặc `default` nếu `key` không có trong từ điển.\n5. **`dict.has_key(key)`**: Trả về `True` nếu một khóa cụ thể có sẵn trong từ điển, nếu không, trả về `False`.\n6. **`dict.items()`**: Trả về một danh sách các cặp tuple (khóa, giá trị) của từ điển.\n7. **`dict.keys()`**: Trả về danh sách các khóa của từ điển `dict`.\n8. **`dict.pop(key)`**: Xóa phần tử với khóa được chỉ định khỏi từ điển.\n9. **`dict.popitem()`**: Xóa cặp key-value được chèn cuối cùng.\n10. **`dict.setdefault(key, default=None)`**: Tương tự như `get()`, nhưng sẽ đặt `dict[key]=default` nếu `key` chưa tồn tại trong `dict`.\n11. **`dict.update(dict2)`**: Thêm các cặp key-value của từ điển `dict2` vào `dict`.\n12. **`dict.values()`**: Trả về danh sách các giá trị của từ điển `dict`.",
            "lesson": 7,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 90,
        "fields": {
            "name": "Bài 0. Python - Tuple (Bộ)",
            "content": "# Bài 0. Python - Tuple (Bộ)\n\nTrong Python, Tuple là một trong những kiểu dữ liệu có sẵn. Một Tuple Python là một chuỗi các mục được phân tách bằng dấu phẩy, được đặt trong dấu ngoặc đơn (). Các mục trong Tuple Python không nhất thiết phải cùng loại dữ liệu.\n\nDưới đây là một số ví dụ về Tuple Python:\n\n```python\ntup1 = (\"Rohan\", \"Physics\", 21, 69.75)\ntup2 = (1, 2, 3, 4, 5)\ntup3 = (\"a\", \"b\", \"c\", \"d\")\ntup4 = (25.50, True, -55, 1+2j)\n```\n\nTrong Python, Tuple là một kiểu dữ liệu chuỗi. Đó là một bộ sưu tập các mục được sắp xếp. Mỗi mục trong Tuple có một chỉ mục vị trí duy nhất, bắt đầu từ 0.\n\nTrong C/C++/Java, các phần tử mảng phải cùng loại. Tuy nhiên, Tuple Python có thể chứa các đối tượng khác nhau về kiểu dữ liệu.\n\nTuple Python và danh sách đều là các chuỗi. Một khác biệt chính giữa hai loại này là, danh sách Python có thể thay đổi, trong khi Tuple không thể thay đổi. Mặc dù bạn có thể truy cập vào bất kỳ mục nào trong Tuple bằng cách sử dụng chỉ mục của nó và không thể sửa đổi, xóa hoặc thêm.\n\n### Các Phép Toán Tuple Python\n\nTrong Python, Tuple là một chuỗi. Do đó, chúng ta có thể nối hai tuple với toán tử + và nối nhiều bản sao của một tuple với toán tử \"*\". Các toán tử thành viên \"in\" và \"not in\" hoạt động với đối tượng tuple.\n\n| Biểu thức Python      | Kết quả                      | Mô tả           |\n| --------------------- | ---------------------------- | --------------- |\n| (1, 2, 3) + (4, 5, 6) | (1, 2, 3, 4, 5, 6)           | Nối             |\n| ('Hi!',) * 4          | ('Hi!', 'Hi!', 'Hi!', 'Hi!') | Lặp lại         |\n| 3 in (1, 2, 3)        | True                         | Tính thành viên |\n\nLưu ý rằng ngay cả khi chỉ có một đối tượng trong một Tuple, bạn phải đặt một dấu phẩy sau nó. Nếu không, nó sẽ được xem xét là một chuỗi.",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 91,
        "fields": {
            "name": "Bài 1. Python - Truy cập các mục Tuple",
            "content": "# Bài 1. Python - Truy cập các mục Tuple\n\nTrong Python, Tuple là một chuỗi. Mỗi đối tượng trong tuple có thể được truy cập bằng chỉ mục của nó. Chỉ mục bắt đầu từ \"0\". Chỉ mục của phần tử cuối cùng trong tuple là \"length-1\". Để truy cập giá trị trong các tuple, sử dụng dấu ngoặc vuông để cắt cùng với chỉ mục hoặc các chỉ mục để nhận giá trị có sẵn tại chỉ mục đó.\n\nToán tử lát cắt rút ra một hoặc nhiều mục từ tuple.\n\n```python\nobj = tup1[i]\n```\n\nVí dụ:\n\n```python\ntup1 = (\"Rohan\", \"Physics\", 21, 69.75)\ntup2 = (1, 2, 3, 4, 5)\n\nprint (\"Item tại chỉ mục 0 trong tup1: \", tup1[0])\nprint (\"Item tại chỉ mục 2 trong tup2: \", tup2[2])\n```\n\nSẽ cho ra kết quả sau:\n\n```\nItem tại chỉ mục 0 trong tup1: Rohan\nItem tại chỉ mục 2 trong tup2: 3\n```\n\nTruy cập các mục Tuple với Chỉ mục Âm\nPython cho phép sử dụng chỉ mục âm với bất kỳ kiểu dữ liệu chuỗi nào. Chỉ mục \"-1\" đề cập đến mục cuối cùng trong tuple.\n\nVí dụ:\n\n```python\ntup1 = (\"a\", \"b\", \"c\", \"d\")\ntup2 = (25.50, True, -55, 1+2j)\nprint (\"Item tại chỉ mục 0 trong tup1: \", tup1[-1])\nprint (\"Item tại chỉ mục 2 trong tup2: \", tup2[-3])\n```\n\nSẽ cho ra kết quả sau:\n\n```\nItem tại chỉ mục 0 trong tup1: d\nItem tại chỉ mục 2 trong tup2: True\n```\n\nTrích xuất một Tuple con từ một Tuple\nToán tử lát cắt rút ra một tuple con từ tuple gốc.\n\n```python\nSubtup = tup1[i:j]\n```\n\nTham số:\n\n- i − chỉ mục của mục đầu tiên trong subtup.\n- j − chỉ mục của mục tiếp theo sau mục cuối cùng trong subtup.\n\nĐiều này sẽ trả về một lát cắt từ mục thứ i đến (j-1) từ tup1.\n\nVí dụ:\n\n```python\ntup1 = (\"a\", \"b\", \"c\", \"d\")\ntup2 = (25.50, True, -55, 1+2j)\n\nprint (\"Các mục từ chỉ mục 1 đến 2 trong tup1: \", tup1[1:3])\nprint (\"Các mục từ chỉ mục 0 đến 1 trong tup2: \", tup2[0:2])\n```\n\nSẽ cho ra kết quả sau:\n\n```\nCác mục từ chỉ mục 1 đến 2 trong tup1: ('b', 'c')\nCác mục từ chỉ mục 0 đến 1 trong tup2: (25.5, True)\n```\n\nTruy cập phạm vi các mục Tuple với Chỉ mục Âm\nKhi lát cắt, cả hai toán hạng \"i\" và \"j\" đều là tùy chọn. Nếu không được sử dụng, \"i\" là 0 và \"j\" là mục cuối cùng trong tuple. Chỉ mục âm có thể được sử dụng trong lát cắt. Xem ví dụ sau:\n\n```python\ntup1 = (\"a\", \"b\", \"c\", \"d\")\ntup2 = (25.50, True, -55, 1+2j)\ntup4 = (\"Rohan\", \"Physics\", 21, 69.75)\ntup3 = (1, 2, 3, 4, 5)\n\nprint (\"Các mục từ chỉ mục 1 đến cuối cùng trong tup1: \", tup1[1:])\nprint (\"Các mục từ chỉ mục 0 đến 1 trong tup2: \", tup2[:2])\nprint (\"Các mục từ chỉ mục 2 đến cuối cùng trong tup3\", tup3[2:-1])\nprint (\"Các mục từ chỉ mục 0 đến chỉ mục cuối cùng trong tup4\", tup4[:])\n```\n\nSẽ cho ra kết quả sau:\n\n```\nCác mục từ chỉ mục 1 đến cuối cùng trong tup1: ('b', 'c', 'd')\nCác mục từ chỉ mục 0 đến 1 trong tup2: (25.5, True)\nCác mục từ chỉ mục 2 đến cuối cùng trong tup3: (3, 4)\nCác mục từ chỉ mục 0 đến chỉ mục cuối cùng trong tup4: ('Rohan', 'Physics', 21, 69.75)\n```",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 92,
        "fields": {
            "name": "Bài 2. Python - Cập nhật Tuple",
            "content": "# Bài 2. Python - Cập nhật Tuple\n\nTrong Python, tuple là một kiểu dữ liệu không thay đổi. Một đối tượng không thay đổi không thể được sửa đổi sau khi nó được tạo trong bộ nhớ.\n\nVí dụ:\n\nNếu chúng ta cố gắng gán một giá trị mới cho một mục tuple bằng toán tử lát cắt, Python sẽ ném ra TypeError. Xem ví dụ sau:\n\n```python\ntup1 = (\"a\", \"b\", \"c\", \"d\")\ntup1[2] = 'Z'\nprint (\"tup1: \", tup1)\n```\n\nSẽ cho ra kết quả sau:\n\n```\nTraceback (most recent call last):\n File \"C:\\Users\\mlath\\examples\\main.py\", line 2, in <module>\n  tup1[2] = 'Z'\n  ~~~~^^^\nTypeError: 'tuple' object does not support item assignment\n```\n\nDo đó, không thể cập nhật một tuple. Do đó, lớp tuple không cung cấp các phương thức để thêm, chèn, xóa, sắp xếp các mục từ một đối tượng tuple, giống như lớp list.\n\nThay đổi Giá trị của Tuple trong Python\nBạn có thể sử dụng một cách làm phụ để cập nhật một tuple. Sử dụng hàm list(), chuyển đổi tuple thành một danh sách, thực hiện các hoạt động thêm/ chèn/xóa mong muốn và sau đó phân tích cú pháp danh sách trở lại thành đối tượng tuple.\n\nVí dụ:\n\nỞ đây, chúng tôi chuyển đổi tuple thành một danh sách, cập nhật một mục hiện có, thêm một mục mới và sắp xếp danh sách. Danh sách được chuyển đổi trở lại thành đối tượng tuple.\n\n```python\ntup1 = (\"a\", \"b\", \"c\", \"d\")\nprint (\"Tuple trước khi cập nhật\", tup1, \"id(): \", id(tup1))\n\nlist1 = list(tup1)\nlist1[2]='F'\nlist1.append('Z')\nlist1.sort()\nprint (\"danh sách đã cập nhật\", list1)\n\ntup1 = tuple(list1)\nprint (\"Tuple sau khi cập nhật\", tup1, \"id(): \", id(tup1))\n```\n\nSẽ cho ra kết quả sau:\n\n```\nTuple trước khi cập nhật ('a', 'b', 'c', 'd') id(): 2295023084192\ndanh sách đã cập nhật ['F', 'Z', 'a', 'b', 'd']\nTuple sau khi cập nhật ('F', 'Z', 'a', 'b', 'd') id(): 2295021518128\n```\n\nTuy nhiên, lưu ý rằng id() của tup1 trước và sau khi cập nhật là khác nhau. Điều này có nghĩa là một đối tượng tuple mới được tạo ra và đối tượng tuple ban đầu không được sửa đổi tại chỗ.",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 93,
        "fields": {
            "name": "Bài 3. Python - Giải nén các phần tử của Tuple",
            "content": "# Bài 3. Python - Giải nén các phần tử của Tuple\n\nThuật ngữ \"giải nén\" đề cập đến quá trình phân tích các phần tử tuple thành các biến riêng lẻ. Trong Python, dấu ngoặc đơn là các dấu phân cách mặc định cho một biểu diễn chữ của đối tượng chuỗi.\n\nCác câu lệnh sau để khai báo một tuple là giống nhau.\n\n```python\nt1 = (x,y)\nt1 = x,y\ntype (t1)\n<class 'tuple'>\n```\n\nVí dụ:\n\nĐể lưu trữ các phần tử tuple trong các biến riêng lẻ, hãy sử dụng nhiều biến trên bên trái của toán tử gán, như được thể hiện trong ví dụ sau:\n\n```python\ntup1 = (10,20,30)\nx, y, z = tup1\nprint (\"x: \", x, \"y: \", y, \"z: \", z)\n```\n\nSẽ cho ra kết quả sau:\n\n```\nx: 10 y: 20 z: 30\n```\n\nĐó là cách mà tuple được giải nén thành các biến riêng lẻ.\n\nTrong ví dụ trên, số lượng biến bên trái của toán tử gán bằng số phần tử trong tuple. Điều gì sẽ xảy ra nếu số lượng không bằng số phần tử?\n\n# ValueError Khi Giải nén một Tuple\n\nNếu số lượng biến nhiều hơn hoặc ít hơn so với độ dài của tuple, Python sẽ ném ra một ValueError.\n\nVí dụ:\n\n```python\ntup1 = (10,20,30)\nx, y = tup1\nx, y, p, q = tup1\n```\n\nSẽ cho ra kết quả sau:\n\n```\n  x, y = tup1\n  ^^^^\nValueError: too many values to unpack (expected 2)\n  x, y, p, q = tup1\n  ^^^^^^^^^^\nValueError: not enough values to unpack (expected 4, got 3)\n```\n\n# Giải nén các phần tử của Tuple Sử Dụng Dấu * (Asterisk)\n\nTrong trường hợp như vậy, ký hiệu \"*\" được sử dụng để giải nén. Tiền tố \"*\" cho \"y\", như được thể hiện dưới đây −\n\n## Ví dụ 1\n\n```python\ntup1 = (10,20,30)\nx, *y = tup1\nprint (\"x: \", x, \"y: \", y)\n```\n\nSẽ cho ra kết quả sau:\n\n```\nx: 10 y: [20, 30]\n```\n\nGiá trị đầu tiên trong tuple được gán cho \"x\", và phần còn lại được gán cho \"y\" và trở thành một danh sách.\n\n## Ví dụ 2\n\nTrong ví dụ này, tuple chứa 6 giá trị và các biến để giải nén là 3. Chúng ta thêm \"*\" vào biến thứ hai.\n\n```python\ntup1 = (10,20,30, 40, 50, 60)\nx, *y, z = tup1\nprint (\"x: \", x, \"y: \", y, \"z: \", z)\n```\n\nSẽ cho ra kết quả sau:\n\n```\nx: 10 y: [20, 30, 40, 50] z: 60\n```\n\nỞ đây, giá trị được giải nén trong \"x\" và \"z\" trước, và sau đó các giá trị còn lại được gán cho \"y\" dưới dạng một danh sách.\n\n## Ví dụ 3\n\nĐiều gì sẽ xảy ra nếu chúng ta thêm \"*\" vào biến đầu tiên?\n\n```python\ntup1 = (10,20,30, 40, 50, 60)\n*x, y, z = tup1\nprint (\"x: \", x, \"y: \", y, \"z: \", z)\n```\n\nSẽ cho ra kết quả sau:\n\n```\nx: [10, 20, 30, 40] y: 50 z: 60\n```\n\nỞ đây, một lần nữa, tuple được giải nén sao cho các biến riêng lẻ lấy giá trị trước, để lại các giá trị còn lại cho danh sách \"x\".",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 94,
        "fields": {
            "name": "Bài 4. Lặp Qua Các Phần Tử của Tuple trong Python",
            "content": "# Bài 4. Lặp Qua Các Phần Tử của Tuple trong Python\n\nTrong Python, bạn có thể duyệt qua các phần tử của một tuple bằng cách sử dụng vòng lặp `for`. Việc duyệt này có thể thực hiện bằng cách sử dụng tuple chính nó như một trình lặp hoặc với sự trợ giúp của một chỉ mục.\n\n## Ví dụ\n\nDưới đây là một ví dụ đơn giản về cách sử dụng vòng lặp `for` trong Python:\n\n```python\ntup1 = (25, 12, 10, -21, 10, 100)\nfor num in tup1:\n    print(num, end=' ')\n# Output: 25 12 10 -21 10 100\n```\n\nTrong ví dụ trên, chúng ta duyệt qua mỗi phần tử trong tuple `tup1` và in ra giá trị của từng phần tử.\n\n## Lặp Qua Các Phần Tử của Tuple sử Dụng Chỉ Mục\n\nNgoài việc sử dụng vòng lặp trực tiếp, bạn cũng có thể duyệt qua các phần tử của một tuple bằng cách sử dụng chỉ mục của chúng.\n\n### Ví dụ\n\n```python\ntup1 = (25, 12, 10, -21, 10, 100)\nindices = range(len(tup1))\nfor i in indices:\n    print(\"tup1[{}]: \".format(i), tup1[i])\n# Output:\n# tup1[0]: 25\n# tup1[1]: 12\n# tup1[2]: 10\n# tup1[3]: -21\n# tup1[4]: 10\n# tup1[5]: 100\n```\n\nTrong ví dụ này, chúng ta duyệt qua các phần tử của tuple `tup1` bằng cách sử dụng chỉ mục và in ra mỗi phần tử cùng với chỉ mục tương ứng của nó.",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 95,
        "fields": {
            "name": "Bài 5. Python - Gộp Tuple",
            "content": "# Bài 5. Python - Gộp Tuple\n\n## Gộp Tuple trong Python\n\nTrong Python, Tuple được phân loại là một đối tượng loại chuỗi (sequence type). Đó là một tập hợp các mục, có thể thuộc các kiểu dữ liệu khác nhau, với mỗi mục có chỉ số vị trí bắt đầu từ 0. Mặc dù định nghĩa này cũng áp dụng cho danh sách (list), có hai sự khác biệt chính giữa danh sách (list) và tuple. Đầu tiên, trong khi các mục được đặt trong dấu ngoặc vuông trong trường hợp của danh sách (ví dụ: [10,20,30,40]), thì tuple được tạo thành bằng cách đặt các mục trong dấu ngoặc đơn (ví dụ: (10,20,30,40)).\n\nTrong Python, Tuple là một đối tượng không thể thay đổi (immutable). Do đó, không thể thay đổi nội dung của một tuple sau khi nó được tạo ra trong bộ nhớ.\n\nTuy nhiên, bạn có thể sử dụng các cách khác nhau để gộp hai tuple Python.\n\n### Gộp Tuple trong Python\n\nTất cả các đối tượng loại chuỗi (sequence type) đều hỗ trợ toán tử nối (+), với đó hai tuple có thể được gộp.\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nT3 = T1 + T2\nprint (\"Tuple đã gộp:\", T3)\n```\n\nKết quả:\n\n```\nTuple đã gộp: (10, 20, 30, 40, 'one', 'two', 'three', 'four')\n```\n\n### Gộp Tuple trong Python sử dụng toán tử nối tăng cường\n\nBạn cũng có thể sử dụng toán tử nối tăng cường với ký hiệu \"+=\" để thêm T2 vào T1.\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nT1 += T2\nprint (\"Tuple đã gộp:\", T1)\n```\n\n### Gộp Tuple trong Python bằng cách mở rộng Tuple\n\nKết quả tương tự có thể được đạt được bằng cách sử dụng phương thức extend(). Ở đây, chúng ta cần chuyển đổi hai đối tượng tuple thành danh sách (list), mở rộng để thêm các phần tử từ một danh sách vào danh sách khác, và sau đó chuyển đổi danh sách đã gộp thành một tuple.\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nL1 = list(T1)\nL2 = list(T2)\nL1.extend(L2)\nT1 = tuple(L1)\nprint (\"Tuple đã gộp:\", T1)\n```\n\n### Gộp Tuple trong Python sử dụng phương thức sum()\n\nHàm sum() có sẵn trong Python cũng giúp trong việc nối các tuple. Chúng ta sử dụng một biểu thức\n\nsum((t1, t2), ())\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nT3 = sum((T1, T2), ())\nprint (\"Tuple đã gộp:\", T3)\n```\n\n### Gộp Tuple trong Python sử dụng List Comprehension\n\nMột cách tiếp cận phức tạp hơn để gộp hai tuple là sử dụng list comprehension.\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nL1, L2 = list\n\n(T1), list(T2)\nL3 = [y for x in [L1, L2] for y in x]\nT3 = tuple(L3)\nprint (\"Tuple đã gộp:\", T3)\n```\n\n### Gộp Tuple trong Python sử dụng vòng lặp for\n\nBạn có thể chạy một vòng lặp for trên các phần tử trong tuple thứ hai, chuyển đổi mỗi phần tử thành một tuple chỉ chứa một phần tử và nối nó vào tuple đầu tiên với toán tử \"+=\"\n\n**Ví dụ**:\n\n```python\nT1 = (10,20,30,40)\nT2 = ('one', 'two', 'three', 'four')\nfor t in T2:\n    T1 += (t,)\nprint (T1)\n```",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 96,
        "fields": {
            "name": "Bài 6. Python - Phương thức Tuple",
            "content": "# Bài 6. Python - Phương thức Tuple\n\nTrong Python, vì một tuple là không thể thay đổi, nên lớp tuple không định nghĩa các phương thức để thêm hoặc loại bỏ các mục. Lớp tuple chỉ định nghĩa hai phương thức.\n\n## 1. tuple.count(obj)\n\nTrả về số lần xuất hiện của obj trong tuple.\n\n## 2. tuple.index(obj)\n\nTrả về chỉ số thấp nhất trong tuple mà obj xuất hiện.\n\n### Tìm Chỉ Số của Một Phần Tử trong Tuple\n\nPhương thức index() của lớp tuple trả về chỉ số của sự xuất hiện đầu tiên của mục được cung cấp.\n\n**Cú pháp**:\n\n```python\ntuple.index(obj)\n```\n\n**Giá trị trả về**:\n\nPhương thức index() trả về một số nguyên, đại diện cho chỉ số của sự xuất hiện đầu tiên của \"obj\".\n\n**Ví dụ**:\n\n```python\ntup1 = (25, 12, 10, -21, 10, 100)\nprint (\"Tup1:\", tup1)\nx = tup1.index(10)\nprint (\"Chỉ số đầu tiên của 10:\", x)\n```\n\n### Đếm Các Mục trong Tuple\n\nPhương thức count() trong lớp tuple trả về số lần một đối tượng cụ thể xuất hiện trong tuple.\n\n**Cú pháp**:\n\n```python\ntuple.count(obj)\n```\n\n**Giá trị trả về**:\n\nSố lần xuất hiện của đối tượng. Phương thức count() trả về một số nguyên.\n\n**Ví dụ**:\n\n```python\ntup1 = (10, 20, 45, 10, 30, 10, 55)\nprint (\"Tup1:\", tup1)\nc = tup1.count(10)\nprint (\"Số lần xuất hiện của 10:\", c)\n```\n\n### Ví dụ\n\nKể cả nếu các mục trong tuple chứa biểu thức, chúng sẽ được đánh giá để lấy số lần đếm.\n\n```python\nTup1 = (10, 20/80, 0.25, 10/40, 30, 10, 55)\nprint (\"Tup1:\", tup1)\nc = tup1.count(0.25)\nprint (\"Số lần xuất hiện của 10:\", c)\n```\n\n### Kết luận\n\nCác phương thức `count()` và `index()` của tuple giúp bạn thao tác và truy vấn dữ liệu trong các tuple một cách thuận tiện và hiệu quả.",
            "lesson": 8,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 97,
        "fields": {
            "name": "Xử Lý Tệp Trong Python",
            "content": "# Xử Lý Tệp Trong Python\n\nKhi sử dụng bất kỳ ứng dụng máy tính nào, đôi khi cần cung cấp dữ liệu. Dữ liệu được lưu trữ trong bộ nhớ chính của máy tính (RAM) cho đến khi ứng dụng đang chạy. Sau đó, nội dung bộ nhớ từ RAM sẽ bị xóa.\n\nChúng ta muốn lưu trữ nó theo cách sao cho có thể được truy xuất khi cần thiết trên một phương tiện lưu trữ liên tục như một tệp đĩa.\n\nPython sử dụng các hàm input() và print() tích hợp để thực hiện các hoạt động nhập/ xuất tiêu chuẩn. Chương trình Python tương tác với các thiết bị IO thông qua các đối tượng dòng tiêu chuẩn stdin và stdout được xác định trong mô-đun sys.\n\nHàm input() đọc các byte từ một thiết bị dòng nhập tiêu chuẩn, tức là bàn phím. Do đó, cả hai câu lệnh sau đều đọc đầu vào từ người dùng.\n\n```python\nname = input()\n# tương đương với\nimport sys\nname = sys.stdin.readline()\n```\n\nHàm print() gửi dữ liệu đến thiết bị dòng xuất tiêu chuẩn, tức là màn hình hiển thị. Đó là một hàm tiện ích mô phỏng phương thức write() của đối tượng stdout.\n\n```python\nprint(name)\n# tương đương với\nimport sys\nsys.stdout.write(name)\n```\n\nBất kỳ đối tượng nào tương tác với dòng nhập và dòng xuất được gọi là đối tượng Tệp. Hàm tích hợp open() của Python trả về một đối tượng tệp.\n\n## Hàm open()\n\nHàm này tạo một đối tượng tệp, sẽ được sử dụng để gọi các phương thức hỗ trợ khác liên quan đến nó.\n\n**Cú pháp**\n```python\nđối tượng tệp = open(tên_tệp [, chế_độ_truy_cập][, đệm])\n```\n\nDưới đây là chi tiết về các tham số:\n\n- `tên_tệp` − Đối số `tên_tệp` là một chuỗi chứa tên của tệp mà bạn muốn truy cập.\n\n- `chế_độ_truy_cập` − `chế_độ_truy_cập` xác định chế độ mà tệp phải được mở, tức là đọc, ghi, thêm, v.v. Một danh sách hoàn chỉnh các giá trị có thể có được đưa ra dưới dạng bảng bên dưới. Đây là một tham số tùy chọn và chế độ truy cập tệp mặc định là đọc (r).\n\n- `đệm` − Nếu giá trị `đệm` được đặt thành 0, không có việc đệm nào xảy ra. Nếu giá trị `đệm` được đặt thành 1, việc đệm dòng được thực hiện khi truy cập một tệp. Nếu bạn chỉ định giá trị `đệm` là một số nguyên lớn hơn 1, sau đó hành động đệm được thực hiện với kích thước đệm chỉ định. Nếu âm, kích thước đệm là mặc định của hệ thống (hành vi mặc định).\n\n## Chế Độ Mở Tệp\n\nDưới đây là các chế độ mở tệp:\n\n| Chế Độ | Mô Tả |\n|--------|-------|\n| `r`    | Mở tệp chỉ để đọc. Trình chỉ mục tệp được đặt ở đầu tệp. Đây là chế độ mặc định. |\n| `rb`   | Mở tệp chỉ để đọc ở định dạng nhị phân. Trình chỉ mục tệp được đặt ở đầu tệp. Đây là chế độ mặc định. |\n| `r+`   | Mở tệp để cả đọc và ghi. Trình chỉ mục tệp được đặt ở đầu tệp. |\n| `rb+`  | Mở tệp để cả đọc và ghi ở định dạng nhị phân. Trình chỉ mục tệp được đặt ở đầu tệp. |\n| `w`    | Mở tệp chỉ để ghi. Nếu tệp đã tồn tại, tệp sẽ bị ghi đè. Nếu tệp không tồn tại, tạo tệp mới để ghi. |\n| `b`    | Mở tệp trong chế độ nhị phân |\n| `t`    | Mở tệp trong chế độ văn bản (mặc định) |\n| `+`    | Mở tệp để cập nhật (đọc và ghi) |\n| `wb`   | Mở tệp chỉ để ghi ở định dạng nhị phân. Nếu tệp đã tồn tại, tệp sẽ bị ghi đè. Nếu tệp không tồn tại, tạo tệp mới để ghi. |\n| `w+`   | Mở tệp để cả ghi và đọc. Nếu tệp đã tồn tại, tệp sẽ bị ghi đè. Nếu tệp không tồn tại, tạo tệp mới để đọc và ghi. |\n| `wb+`  | Mở tệp để cả ghi và đọc ở định dạng nhị phân. Nếu tệp đã tồn tại, tệp sẽ bị ghi đè. Nếu tệp không tồn tại, tạo tệp mới để đọc và ghi. |\n| `a`    | Mở tệp để thêm. Trình chỉ mục tệp được đặt ở cuối tệp. Nếu tệp không tồn tại, tạo tệp mới để thêm. |\n| `ab`   | Mở tệp để thêm ở định dạng nhị phân. Trình chỉ mục tệp được đặt ở cuối tệp. Nếu tệp không tồn tại, tạo tệp mới để thêm. |\n| `a+`   | Mở tệp để cả thêm và đọc. Trình chỉ mục tệp được đặt ở cuối tệp. Nếu tệp không tồn tại, tạo tệp mới để thêm và đọc. |\n| `ab+`  | Mở tệp để cả thêm và đọc ở định dạng nhị phân. Trình chỉ mục tệp được đặt ở cuối tệp. Nếu tệp không tồn tại, tạo tệp mới để thêm và đọc. |\n| `x`    | Mở để tạo mới, không ghi đè nếu tệp đã tồn tại |\n\nMột khi một tệp đã được mở và bạn có một đối tượng tệp, bạn có thể lấy được các thông tin khác nhau liên quan đến tệp đó.\n\n**Ví dụ**\n\n```python\n# Mở một tệp\nfo = open(\"foo.txt\", \"wb\")\nprint(\"Tên của tệp: \", fo.name)\nprint(\"Đã đóng hay chưa: \", fo.closed)\nprint(\"Chế độ mở: \", fo.mode)\nfo.close()\n```\n\nKết quả sẽ là:\n\n```\nTên của tệp:  foo.txt\nĐã đóng hay chưa:  False\nChế độ mở:  wb\n```",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 98,
        "fields": {
            "name": "Ghi vào Tệp Trong Python",
            "content": "# Ghi vào Tệp Trong Python\n\nĐể ghi dữ liệu vào một tệp trong Python, bạn cần mở một tệp. Bất kỳ đối tượng nào tương tác với dòng nhập và dòng xuất được gọi là Đối tượng Tệp. Hàm tích hợp open() của Python trả về một đối tượng tệp.\n\n```python\nđối_tượng_tệp = open(tên_tệp [, chế_độ_truy_cập][, đệm])\n```\n\n## Ghi vào Một Tệp Mới\n\nSau khi bạn có được đối tượng tệp với hàm open(), bạn có thể sử dụng phương thức write() để ghi bất kỳ chuỗi nào vào tệp được biểu diễn bởi đối tượng tệp. Quan trọng phải lưu ý rằng chuỗi Python có thể chứa dữ liệu nhị phân và không chỉ là văn bản.\n\nPhương thức write() không thêm ký tự xuống dòng ('\\n') vào cuối chuỗi.\n\n**Cú pháp**\n```python\nđối_tượng_tệp.write(chuỗi)\n```\n\nTrong đó, tham số truyền vào là nội dung cần được ghi vào tệp đã mở.\n\n**Ví dụ**\n\n```python\n# Mở một tệp\nfo = open(\"foo.txt\", \"w\")\nfo.write(\"Python là một ngôn ngữ tuyệt vời.\\nYeah, nó thật tuyệt!!\\n\")\n\n# Đóng tệp đã mở\nfo.close()\n```\n\nPhương pháp trên sẽ tạo tệp foo.txt và sẽ ghi nội dung đã cho vào tệp đó và cuối cùng nó sẽ đóng tệp đó. Chương trình không hiển thị bất kỳ đầu ra cụ thể nào, tuy nhiên nếu bạn mở tệp này với bất kỳ ứng dụng soạn thảo văn bản nào như Notepad, nó sẽ có nội dung sau đây.\n\n```\nPython là một ngôn ngữ tuyệt vời.\nYeah, nó thật tuyệt!!\n```\n\n## Ghi vào Một Tệp Mới ở Chế Độ Nhị Phân\n\nMặc định, các hoạt động đọc/viết trên một đối tượng tệp được thực hiện trên dữ liệu chuỗi văn bản. Nếu chúng ta muốn xử lý các tệp của các loại khác nhau như phương tiện (mp3), các tập tin thực thi (exe), hình ảnh (jpg) vv, chúng ta cần thêm tiền tố 'b' vào chế độ đọc/viết.\n\nCâu lệnh sau sẽ chuyển đổi một chuỗi thành byte và ghi vào một tệp.\n\n```python\nf = open('test.bin', 'wb')\ndữ_liệu = b\"Hello World\"\nf.write(dữ_liệu)\nf.close()\n```\n\nChuyển đổi từ chuỗi văn bản sang byte cũng có thể được thực hiện bằng cách sử dụng hàm encode().\n\n```python\ndữ_liệu = \"Hello World\".encode('utf-8')\n```\n\n## Ghi vào Một Tệp Đã Tồn Tại\n\nKhi bất kỳ tệp nào đã tồn tại được mở trong chế độ 'w' để lưu trữ thêm văn bản, nội dung trước đó của nó sẽ bị xóa. Khi một tệp được mở với quyền ghi, nó được xử lý như là một tệp mới. Để thêm dữ liệu vào một tệp đã tồn tại, sử dụng 'a' cho chế độ nối.\n\n**Cú Pháp**\n```python\nđối_tượng_tệp = open(tên_tệp,\"a\")\n```\n\n**Ví dụ**\n```python\n# Mở một tệp trong chế độ nối\nfo = open(\"foo.txt\", \"a\")\nvăn_bản = \"TutorialsPoint có một hướng dẫn Python tuyệt vời\"\nfo.write(văn_bản)\n\n# Đóng tệp đã mở\nfo.close()\n```\n\nKhi chương trình trên được thực thi, không có đầu ra nào được hiển thị, nhưng một dòng mới được thêm vào foo.txt. Để xác\n\n minh, hãy mở với một trình soạn thảo văn bản.\n\n```\nPython là một ngôn ngữ tuyệt vời.\nYeah, nó thật tuyệt!!\nTutorialsPoint có một hướng dẫn Python tuyệt vời\n```\n\n## Ghi vào Một Tệp Trong Chế Độ Đọc và Viết\n\nKhi một tệp được mở để ghi (với 'w' hoặc 'a'), không thể thực hiện hoạt động ghi tại bất kỳ vị trí byte nào trước đó trong tệp. Chế độ 'w+' cho phép sử dụng các phương thức write() cũng như read() mà không cần đóng một tệp. Đối tượng Tệp hỗ trợ hàm seek() để tua lại luồng đến bất kỳ vị trí byte nào mong muốn.\n\nDưới đây là cú pháp cho phương thức seek().\n\n```python\nđối_tượng_tệp.seek(vị_trí[, cách])\n```\n\n**Tham số**\n- **vị_trí**. Đây là vị trí của con trỏ đọc/viết trong tệp.\n- **cách**. Đây là tùy chọn và mặc định là 0 nghĩa là vị trí tệp tuyệt đối, các giá trị khác là 1 nghĩa là tua liên quan đến vị trí hiện tại và 2 nghĩa là tua liên quan đến cuối tệp.\n\nHãy sử dụng phương thức seek() để hiển thị cách thực hiện các hoạt động đọc/viết đồng thời trên một tệp.\n\n**Ví dụ**\n\nChương trình dưới đây mở tệp trong chế độ w+ (là chế độ đọc-viết), thêm một số dữ liệu. Sau đó nó tìm kiếm một vị trí cụ thể trong tệp và ghi đè nội dung trước đó bằng văn bản mới.\n\n```python\n# Mở một tệp trong chế độ đọc-viết\nfo = open(\"foo.txt\", \"w+\")\nfo.write(\"Đây là một cuộc đua chuột\")\nfo.seek(10, 0)\ndữ_liệu = fo.read(3)\nfo.seek(10, 0)\nfo.write('mèo')\nfo.close()\n```\n\n**Kết quả**\n\nNếu chúng ta mở tệp trong chế độ Đọc (hoặc tua về vị trí bắt đầu trong chế độ w+), và đọc nội dung, nó sẽ hiển thị.\n\n```\nĐây là một cuộc mèo chuột\n```",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 99,
        "fields": {
            "name": "Đọc Tệp Trong Python",
            "content": "# Đọc Tệp Trong Python\n\nĐể đọc dữ liệu từ một tệp bằng cách sử dụng mã nguồn trong Python, trước tiên tệp đó phải được mở. Sử dụng hàm tích hợp open() như sau:\n\n```python\nđối_tượng_tệp = open(tên_tệp [, chế_độ_truy_cập][, đệm])\n```\n\nDưới đây là chi tiết về các tham số −\n\n- **file_name**: Đối số file_name là một giá trị chuỗi chứa tên của tệp mà bạn muốn truy cập.\n- **access_mode**: Tham số access_mode xác định chế độ mà tệp phải được mở, tức là, đọc, viết, thêm, vv. Đây là một tham số tùy chọn và chế độ truy cập tệp mặc định là đọc (r).\n\nHai câu lệnh sau là tương đương nhau −\n\n```python\nfo = open(\"foo.txt\", \"r\")\nfo = open(\"foo.txt\")\n```\n\nĐể đọc dữ liệu từ tệp đã mở, sử dụng phương thức read() của Đối tượng Tệp. Quan trọng phải lưu ý rằng chuỗi Python có thể chứa dữ liệu nhị phân ngoài dữ liệu văn bản.\n\n**Cú pháp**\n```python\nđối_tượng_tệp.read([số_lượng])\n```\n\n**Tham số**\n- **số_lượng**: Số byte cần đọc.\n\nỞ đây, tham số truyền vào là số byte cần đọc từ tệp đã mở. Phương thức này bắt đầu đọc từ đầu của tệp và nếu số_lượng bị thiếu, thì nó cố gắng đọc càng nhiều càng tốt, có thể đến cuối tệp.\n\n**Ví dụ: Đọc Một Tệp Trong Python**\n```python\n# Mở một tệp\nfo = open(\"foo.txt\", \"r\")\ntext = fo.read()\nprint (text)\n\n# Đóng tệp đã mở\nfo.close()\n```\n\nKết quả sẽ là:\n\n```\nPython is a great language.\nYeah its great!!\n```\n\n## Đọc Một Tệp Trong Chế Độ Nhị Phân\n\nMặc định, các hoạt động đọc/viết trên một đối tượng tệp được thực hiện trên dữ liệu chuỗi văn bản. Nếu chúng ta muốn xử lý các tệp của các loại khác nhau như phương tiện (mp3), các tập tin thực thi (exe), hình ảnh (jpg) vv, chúng ta cần thêm tiền tố 'b' vào chế độ đọc/viết.\n\nGiả sử rằng tệp test.bin đã được viết trước đó với chế độ nhị phân.\n\n```python\nf = open('test.bin', 'wb')\ndata = b\"Hello World\"\nf.write(data)\nf.close()\n```\n\n**Ví dụ: Đọc Một Tệp Trong Chế Độ Nhị Phân**\n\nChúng ta cần sử dụng chế độ 'rb' để đọc tệp nhị phân. Giá trị trả về của phương thức read() được giải mã trước khi in ra.\n\n```python\nf = open('test.bin', 'rb')\ndata = f.read()\nprint(data.decode(encoding='utf-8'))\n```\n\nKết quả sẽ là:\n\n```\nHello World\n```\n\n## Đọc Số (Dữ Liệu Kiểu Số Nguyên) Từ Một Tệp\n\nĐể viết dữ liệu số nguyên vào một tệp nhị phân, đối tượng số nguyên phải được chuyển đổi thành bytes bằng phương thức to_bytes().\n\n```python\nn = 25\nn.to_bytes(8, 'big')\nf = open('test.bin', 'wb')\ndata = n.to_bytes(8, 'big')\nf.write(data)\n```\n\nĐể đọc lại từ một tệp nhị phân, chuyển đổi kết quả của hàm read() thành số nguyên bằng cách sử dụng hàm from_bytes().\n\n```python\nf = open('test.bin', 'rb')\ndata = f.read()\nn = int.from_bytes(data, 'big')\nprint(n)\n```\n\n## Đọc Số (Dữ Liệu Kiểu Số Thực) Từ Một Tệp\n\nĐối với dữ liệu số thực, chúng ta cần sử dụng module struct từ thư viện chuẩn của Python.\n\n```python\nimport struct\nx = 23.50\ndata = struct.pack('f', x)\nf = open('test.bin', 'wb')\nf.write(data)\n```\n\n**Ví dụ: Đọc Số Th\n\nực Từ Một Tệp**\n\nGiải nén chuỗi từ hàm read() để lấy dữ liệu số thực từ tệp nhị phân.\n\n```python\nf = open('test.bin', 'rb')\ndata = f.read()\nx = struct.unpack('f', data)\nprint(x)\n```\n\n## Đọc Một Tệp Sử Dụng Chế Độ Đọc-Viết (r+)\n\nKhi một tệp được mở để đọc (với 'r' hoặc 'rb'), không thể ghi dữ liệu vào tệp đó. Chúng ta cần đóng tệp trước khi thực hiện hoạt động khác. Để thực hiện cả hai hoạt động đồng thời, chúng ta phải thêm ký tự '+' vào tham số chế độ. Do đó, chế độ 'w+' hoặc 'r+' cho phép sử dụng cả hai phương thức write() và read() mà không cần đóng tệp.\n\nĐối tượng Tệp cũng hỗ trợ hàm seek() để tua lại dòng để đọc từ bất kỳ vị trí byte mong muốn nào.\n\nDưới đây là cú pháp cho phương thức seek() −\n\n```python\nđối_tượng_tệp.seek(vị_trí[, cách])\n```\n\n**Tham số**\n- **vị_trí**: Đây là vị trí của con trỏ đọc/viết trong tệp.\n- **cách**: Đây là tùy chọn và mặc định là 0 nghĩa là vị trí tuyệt đối của tệp, các giá trị khác là 1 nghĩa là tua liên quan đến vị trí hiện tại và 2 nghĩa là tua liên quan đến cuối tệp.\n\nHãy sử dụng phương thức seek() để hiển thị cách thực hiện các hoạt động đọc/viết đồng thời trên một tệp.\n\n**Ví dụ**\n\nChương trình dưới đây mở tệp trong chế độ w+ (là chế độ đọc-viết), thêm một số dữ liệu. Sau đó nó tìm kiếm một vị trí cụ thể trong tệp và ghi đè nội dung trước đó bằng văn bản mới.\n\n```python\n# Mở một tệp trong chế độ đọc-viết\nfo = open(\"foo.txt\", \"w+\")\nfo.write(\"Đây là một cuộc đua chuột\")\nfo.seek(10, 0)\ndữ_liệu = fo.read(3)\nfo.seek(10, 0)\nfo.write('mèo')\nfo.close()\n```\n\n**Kết quả**\n\nNếu chúng ta mở tệp trong chế độ Đọc (hoặc tua về vị trí bắt đầu trong chế độ w+), và đọc nội dung, nó sẽ hiển thị −\n\n```\nĐây là một cuộc mèo chuột\n```\n\nĐọc Một Tệp Từ Vị Trí Xác Định\nPhương thức seek() đặt vị trí hiện tại của tệp tại offset. Tham số whence là tùy chọn và mặc định là 0, nghĩa là định vị tệp tuyệt đối, các giá trị khác là 1 nghĩa là định vị liên quan đến vị trí hiện tại và 2 nghĩa là định vị liên quan đến cuối tệp.\n\nKhông có giá trị trả về. Lưu ý rằng nếu tệp được mở để ghi vào sử dụng 'a' hoặc 'a+', bất kỳ hoạt động seek() nào cũng sẽ bị hủy tại lần ghi tiếp theo.\n\nNếu tệp chỉ được mở để ghi trong chế độ thêm sử dụng 'a', phương thức này về cơ bản là một hoạt động không có tác dụng, nhưng nó vẫn hữu ích cho các tệp được mở trong chế độ thêm với việc đọc được kích hoạt (chế độ 'a+').\n\nNếu tệp được mở trong chế độ văn bản sử dụng 't', chỉ các định vị được tr\n\nả về bởi tell() là hợp lệ. Việc sử dụng các định vị khác gây ra hành vi không xác định.\n\nLưu ý rằng không phải tất cả các đối tượng tệp đều có thể được tua.\n\n**Cú pháp**\n\nDưới đây là cú pháp cho phương thức seek() −\n\n```python\nđối_tượng_tệp.seek(vị_trí[, cách])\n```\n\n**Tham số**\n\n- **vị_trí**: Đây là vị trí của con trỏ đọc/viết trong tệp.\n- **cách**: Đây là tùy chọn và mặc định là 0 nghĩa là vị trí tuyệt đối của tệp, các giá trị khác là 1 nghĩa là tua liên quan đến vị trí hiện tại và 2 nghĩa là tua liên quan đến cuối tệp.\n\n**Ví dụ**\n\nDưới đây là chương trình mở tệp trong chế độ w+ (là chế độ đọc-viết), thêm một số dữ liệu. Sau đó nó tìm kiếm một vị trí cụ thể trong tệp và ghi đè nội dung trước đó bằng văn bản mới.\n\n```python\n# Mở một tệp trong chế độ đọc-viết\nfo = open(\"foo.txt\", \"w+\")\nfo.write(\"Đây là một cuộc đua chuột\")\nfo.seek(10, 0)\ndữ_liệu = fo.read(3)\nfo.seek(10, 0)\nfo.write('mèo')\nfo.seek(0, 0)\ndữ_liệu = fo.read()\nprint(dữ_liệu)\nfo.close()\n```\n\n**Kết quả**\n\n```\nĐây là một cuộc mèo chuột\n```\n\n# Kết Luận\n\nThông qua các ví dụ và giải thích chi tiết, bạn đã học cách đọc dữ liệu từ một tệp trong Python, bao gồm cả chế độ văn bản và chế độ nhị phân, cũng như cách xử lý số nguyên và số thực. Bạn cũng đã hiểu về cách thực hiện các hoạt động đọc và viết đồng thời trên một tệp bằng cách sử dụng chế độ 'r+' hoặc 'w+'.",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 100,
        "fields": {
            "name": "Python - Đổi Tên và Xóa Tệp Tin",
            "content": "# Python - Đổi Tên và Xóa Tệp Tin\n\nModule `os` trong Python cung cấp các phương thức giúp bạn thực hiện các hoạt động xử lý tệp tin như đổi tên và xóa tệp tin.\n\nĐể sử dụng module này, bạn cần import nó trước và sau đó bạn có thể gọi bất kỳ hàm liên quan nào.\n\n## Phương thức `rename()`\n\nPhương thức `rename()` nhận hai đối số, tên tệp tin hiện tại và tên tệp tin mới.\n\n**Cú Pháp**\n```python\nos.rename(ten_tep_hien_tai, ten_tep_moi)\n```\n\n**Ví dụ**\n\n```python\nimport os\n# Đổi tên tệp từ \"test1.txt\" thành \"test2.txt\"\nos.rename(\"test1.txt\", \"test2.txt\")\n```\n\n## Phương thức `remove()`\n\nBạn có thể sử dụng phương thức `remove()` để xóa tệp tin bằng cách cung cấp tên của tệp tin cần xóa làm đối số.\n\n**Cú Pháp**\n```python\nos.remove(ten_tep)\n```\n\n**Ví dụ**\n\n```python\nimport os\n# Xóa tệp tin \"test2.txt\"\nos.remove(\"test2.txt\")\n```",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 101,
        "fields": {
            "name": "Python - Thư mục",
            "content": "# Python - Thư mục\n\nTất cả các tệp tin được chứa trong các thư mục khác nhau và Python không gặp vấn đề nào khi xử lý chúng. Module os có một số phương thức giúp bạn tạo, xóa và thay đổi các thư mục.\n\n## Phương thức `mkdir()`\n\nBạn có thể sử dụng phương thức `mkdir()` của module os để tạo thư mục trong thư mục hiện tại. Bạn cần cung cấp một đối số cho phương thức này, chứa tên của thư mục cần tạo.\n\n**Cú Pháp**\n```python\nos.mkdir(\"ten_thu_muc_moi\")\n```\n\n**Ví dụ**\n\n```python\nimport os\n\n# Tạo một thư mục \"test\"\nos.mkdir(\"test\")\n```\n\n## Phương thức `chdir()`\n\nBạn có thể sử dụng phương thức `chdir()` để thay đổi thư mục hiện tại. Phương thức `chdir()` nhận một đối số, là tên của thư mục mà bạn muốn làm thư mục hiện tại.\n\n**Cú Pháp**\n```python\nos.chdir(\"ten_thu_muc\")\n```\n\n**Ví dụ**\n\n```python\nimport os\n\n# Thay đổi thư mục thành \"/home/newdir\"\nos.chdir(\"/home/newdir\")\n```\n\n## Phương thức `getcwd()`\n\nPhương thức `getcwd()` hiển thị thư mục làm việc hiện tại.\n\n**Cú Pháp**\n```python\nos.getcwd()\n```\n\n**Ví dụ**\n\n```python\nimport os\n\n# Hiển thị thư mục làm việc hiện tại\nos.getcwd()\n```\n\n## Phương thức `rmdir()`\n\nPhương thức `rmdir()` xóa thư mục được chuyển làm đối số trong phương thức.\n\nTrước khi xóa một thư mục, tất cả các nội dung trong đó cần được xóa.\n\n**Cú Pháp**\n```python\nos.rmdir('ten_thu_muc')\n```\n\n**Ví dụ**\n\n```python\nimport os\n\n# Xóa thư mục \"/tmp/test\"\nos.rmdir(\"/tmp/test\")\n```",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 102,
        "fields": {
            "name": "Python - Các Phương Thức File",
            "content": "# Python - Các Phương Thức File\n\nMột đối tượng tệp tin được tạo bằng cách sử dụng hàm `open()`. Lớp tệp tin định nghĩa các phương thức sau đây để thực hiện các hoạt động IO tệp tin khác nhau. Các phương thức có thể được sử dụng với bất kỳ đối tượng tệp tin nào như luồng byte hoặc luồng mạng.\n\n## Các Phương Thức\n\n1. **`file.close()`**\n   - Đóng tệp tin. Một tệp tin đã đóng không thể được đọc hoặc ghi thêm.\n\n2. **`file.flush()`**\n   - Xả bộ đệm nội bộ, tương tự như fflush của stdio. Điều này có thể không có tác dụng trên một số đối tượng giống như tệp tin.\n\n3. **`file.fileno()`**\n   - Trả về số hiệu tệp nguyên mà được sử dụng bởi triển khai cơ sở để yêu cầu các hoạt động IO từ hệ điều hành.\n\n4. **`file.isatty()`**\n   - Trả về True nếu tệp tin được kết nối với một thiết bị tty (giống như), ngược lại trả về False.\n\n5. **`file.next()`**\n   - Trả về dòng tiếp theo từ tệp mỗi khi được gọi.\n\n6. **`file.read([size])`**\n   - Đọc tối đa size byte từ tệp (ít hơn nếu đọc đến cuối tệp trước khi nhận size byte).\n\n7. **`file.readline([size])`**\n   - Đọc một dòng toàn bộ từ tệp. Một ký tự dòng mới dư thừa được giữ trong chuỗi.\n\n8. **`file.readlines([sizehint])`**\n   - Đọc đến EOF bằng cách sử dụng readline() và trả về một danh sách chứa các dòng. Nếu đối số sizehint tùy chọn được cung cấp, thay vì đọc đến EOF, các dòng toàn bộ có tổng cộng khoảng sizehint byte (có thể sau khi làm tròn lên đến kích thước bộ đệm nội bộ) được đọc.\n\n9. **`file.seek(offset[, whence])`**\n   - Đặt vị trí hiện tại của tệp\n\n10. **`file.tell()`**\n    - Trả về vị trí hiện tại của tệp\n\n11. **`file.truncate([size])`**\n    - Cắt giảm kích thước của tệp. Nếu đối số size tùy chọn được cung cấp, tệp sẽ được cắt giảm thành (tối đa) kích thước đó.\n\n12. **`file.write(str)`**\n    - Ghi một chuỗi vào tệp. Không có giá trị trả về.\n\n13. **`file.writelines(sequence)`**\n    - Ghi một chuỗi các dòng vào tệp. Chuỗi có thể là bất kỳ đối tượng lặp lại nào sản xuất chuỗi, thường là một danh sách các chuỗi.",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 103,
        "fields": {
            "name": "Python OS - Các Phương Thức File/Thư Mục",
            "content": "# Python OS - Các Phương Thức File/Thư Mục\n\nModule os trong Python cung cấp một loạt các phương thức hữu ích để thao tác với tệp tin và thư mục. Dưới đây là danh sách các phương thức hữu ích nhất:\n\n## Các Phương Thức với Mô Tả\n\n1. **`os.access(path, mode)`**\n   - Sử dụng uid/gid thực để kiểm tra quyền truy cập vào path.\n\n2. **`os.chdir(path)`**\n   - Thay đổi thư mục làm việc hiện tại thành path.\n\n3. **`os.chflags(path, flags)`**\n   - Đặt cờ của path thành các cờ số.\n\n4. **`os.chmod(path, mode)`**\n   - Thay đổi chế độ của path thành chế độ số.\n\n5. **`os.chown(path, uid, gid)`**\n   - Thay đổi chủ sở hữu và nhóm id của path thành uid và gid số.\n\n6. **`os.chroot(path)`**\n   - Thay đổi thư mục gốc của quá trình hiện tại thành path.\n\n7. **`os.close(fd)`**\n   - Đóng bộ điều khiển tệp fd.\n\n8. **`os.closerange(fd_low, fd_high)`**\n   - Đóng tất cả các bộ điều khiển tệp từ fd_low (bao gồm) đến fd_high (không bao gồm), bỏ qua lỗi.\n\n9. **`os.dup(fd)`**\n   - Trả về một bản sao của bộ điều khiển tệp fd.\n\n10. **`os.dup2(fd, fd2)`**\n    - Sao chép bộ điều khiển tệp fd thành fd2, đóng fd2 trước nếu cần thiết.\n\n11. **`os.fchdir(fd)`**\n    - Thay đổi thư mục làm việc hiện tại thành thư mục được đại diện bởi bộ điều khiển tệp fd.\n\n12. **`os.fchmod(fd, mode)`**\n    - Thay đổi chế độ của tệp được chỉ định bởi fd thành chế độ số.\n\n13. **`os.fchown(fd, uid, gid)`**\n    - Thay đổi chủ sở hữu và nhóm id của tệp được chỉ định bởi fd thành uid và gid số.\n\n14. **`os.fdatasync(fd)`**\n    - Buộc ghi của tệp với bộ điều khiển tệp fd xuống đĩa.\n\n15. **`os.fdopen(fd[, mode[, bufsize]])`**\n    - Trả về một đối tượng tệp mở kết nối với bộ điều khiển tệp fd.\n\n16. **`os.fpathconf(fd, name)`**\n    - Trả về thông tin cấu hình hệ thống liên quan đến một tệp mở. Tên chỉ định giá trị cấu hình cần lấy.\n\n17. **`os.fstat(fd)`**\n    - Trả về trạng thái cho bộ điều khiển tệp fd, giống như stat().\n\n18. **`os.fstatvfs(fd)`**\n    - Trả về thông tin về hệ thống tệp chứa tệp được liên kết với bộ điều khiển tệp fd, giống như statvfs().\n\n19. **`os.fsync(fd)`**\n    - Buộc ghi của tệp với bộ điều khiển tệp fd xuống đĩa.\n\n20. **`os.ftruncate(fd, length)`**\n    - Cắt giảm kích thước của tệp tương ứng với bộ điều khiển tệp fd, để nó tối đa là length byte.\n\n21. **`os.getcwd()`**\n    - Trả về một chuỗi đại diện cho thư mục làm việc hiện tại.\n\n22. **`os.getcwdu()`**\n    - Trả về một đối tượng Unicode đại diện cho thư mục làm việc hiện tại.\n\n23. **`os.isatty(fd)`**\n    - Trả về True nếu bộ điều khiển tệp fd mở và được kết nối với thiết bị tty(-giống), ngược lại trả về False.\n\n24. **`os.lchflags(path, flags)`**\n    - Đặt cờ của path thành các cờ số, giống như chflags(), nhưng không theo dõi liên kết tượng trưng.\n\n25. **`os.lchmod(path, mode)`**\n    - Thay đổi chế độ của path thành chế độ số.\n\n26. **`os.lchown(path, uid, gid)`**\n    - Thay đổi chủ sở hữu và nhóm id của path thành uid và gid. Hàm này sẽ không theo dõi các liên kết tượng trưng.\n\n27. **`os.link(src, dst)`**\n    - Tạo một liên kết cứng trỏ đến src được đặt tên là dst.\n\n28. **`os.listdir(path)`**\n    - Trả về một danh sách chứa tên của các mục trong thư mục được chỉ định bởi path.\n\n29. **`os.lseek(fd, pos, how)`**\n    - Đặt vị trí hiện tại của bộ điều khiển tệp fd thành vị trí pos, được sửa đổi bởi cách.\n\n30. **`os.lstat(path)`**\n    - Giống như stat(), nhưng không theo dõi các liên kết tượng trưng.\n\n31. **`os.major(device)`**\n    - Trích xuất số trình điều khiển chính từ một số thiết bị thô.\n\n32. **`os.makedev(major, minor)`**\n    - Tạo một số thiết bị thô từ số trình điều khiển chính và số trình điều khiển phụ.\n\n33. **`os.makedirs(path[, mode])`**\n    - Hàm tạo thư mục đệ quy.\n\n34. **`os.minor(device)`**\n    - Trích xuất số trình điều khiển phụ từ một số thiết bị thô.\n\n35. **`os.mkdir(path[, mode])`**\n    - Tạo một thư mục có tên là path với mode số.\n\n36. **`os.mkfifo(path[, mode])`**\n    - Tạo một FIFO (một ống đặt tên) có tên là path với mode số. Chế độ mặc định là 0666 (hệ bát phân).\n\n37. **`os.mknod(filename[, mode=0600, device])`**\n    - Tạo một nút hệ thống tệp (tệp, tệp đặc biệt thiết bị hoặc ống đặt tên) có tên là filename.\n\n38. **`os.open(file, flags[, mode])`**\n    - Mở tệp file và thiết lập các cờ khác nhau tùy thuộc vào flags và có thể là chế độ của nó tùy thuộc vào mode.\n\n39. **`os.openpty()`**\n    - Mở một cặp pseudo-terminal mới. Trả về một cặp bộ điều khiển tệp (master, slave) cho pty và tty, tương ứng.\n\n40. **`os.pathconf(path, name)`**\n    - Trả về thông tin cấu hình hệ thống liên quan đến một tệp có tên.\n\n41. **`os.pipe()`**\n    - Tạo một ống. Trả về một cặp bộ điều khiển tệp (r, w) có thể sử dụng để đọc và ghi, tương ứng.\n\n42. **`os.popen(command[, mode[, bufsize]])`**\n    - Mở một ống vào hoặc ra khỏi lệnh command.\n\n43. **`os.read(fd, n)`**\n    - Đọc tối đa n byte từ bộ điều khiển tệp fd. Trả về một chuỗi chứa các byte được đọc.\n\n44. **`os.readlink(path)`**\n    - Trả về một chuỗi đại diện cho đường dẫn mà liên kết tượng trưng trỏ đến.\n\n45. **`os.remove(path)`**\n    - Xóa tệp path.\n\n46. **`os.removedirs(path)`**\n    - Xóa các thư mục đệ quy.\n\n47. **`os.rename(src, dst)`**\n    - Đổi tên tệp hoặc thư mục src thành dst.\n\n48. **`os.renames(old, new)`**\n    - Hàm đổi tên đệ quy thư mục hoặc tệp.\n\n49. **`os.rmdir(path)`**\n    - Xóa thư mục path.\n\n50. **`os.stat(path)`**\n    - Thực hiện một cuộc gọi hệ thống stat trên đường dẫn được chỉ định.\n\n51. **`os.stat_float_times([newvalue])`**\n    - Xác định xem stat_result có đại diện cho dấu thời gian dưới dạng đối tượng float không.\n\n52. **`os.statvfs(path)`**\n    - Thực hiện một cuộc gọi hệ thống statvfs trên đường dẫn được chỉ định.\n\n53. **`os.symlink(src, dst)`**\n    - Tạo một liên kết tượng trưng trỏ đến src có tên là dst.\n\n54. **`os.tcgetpgrp(fd)`**\n    - Trả về nhóm quá trình được liên kết với thiết bị ký tự được chỉ định bởi fd.\n\n55. **`os.tcsetpgrp(fd, pg)`**\n    - Đặt nhóm quá trình được liên kết với thiết bị ký tự được chỉ định bởi fd thành pg.\n\n56. **`os.tempnam([dir[, prefix]])`**\n    - Trả về một tên đường dẫn duy nhất hợp lý để tạo một tệp tạm thời.\n\n57. **`os.tmpfile()`**\n    - Trả về một đối tượng tệp mới được mở ở chế độ cập nhật (w+b).\n\n58. **\n\n`os.tmpnam()`**\n    - Trả về một tên đường dẫn duy nhất hợp lý để tạo một tệp tạm thời.\n\n59. **`os.ttyname(fd)`**\n    - Trả về một chuỗi chỉ định thiết bị ký tự được liên kết với bộ điều khiển tệp fd. Nếu fd không được liên kết với thiết bị ký tự, một ngoại lệ sẽ được ném.\n\n60. **`os.unlink(path)`**\n    - Xóa tệp path.\n\n61. **`os.utime(path, times)`**\n    - Đặt thời gian truy cập và sửa đổi của tệp được chỉ định bởi path.\n\n62. **`os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])`**\n    - Tạo ra các tên tệp trong một cây thư mục bằng cách duyệt cây từ trên xuống hoặc từ dưới lên.\n\n63. **`os.write(fd, str)`**\n    - Ghi chuỗi str vào bộ điều khiển tệp fd. Trả về số byte thực sự được ghi.",
            "lesson": 10,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 104,
        "fields": {
            "name": "Python - Mảng",
            "content": "# Python - Mảng\n\nMảng là một cấu trúc dữ liệu có thể chứa một số lượng cố định các phần tử và các phần tử này phải cùng loại dữ liệu. Hầu hết các cấu trúc dữ liệu sử dụng mảng để triển khai các thuật toán của chúng. Dưới đây là các thuật ngữ quan trọng để hiểu về khái niệm của Mảng.\n\n## 1. Phần Tử (Element)\nMỗi phần tử được lưu trữ trong một mảng được gọi là một phần tử.\n\n## 2. Chỉ Số (Index)\nMỗi vị trí của một phần tử trong một mảng có một chỉ số số học, được sử dụng để xác định phần tử.\n\n## 3. Biểu Diễn Mảng\nMảng có thể được khai báo theo nhiều cách khác nhau trong các ngôn ngữ khác nhau. Dưới đây là một minh họa.\n\n![](../../../assets/array/array_declaration.jpg)\n\n### Khai Báo Mảng\nDựa trên minh họa trên, sau đây là những điểm quan trọng cần xem xét.\n\n- Chỉ số bắt đầu từ 0.\n- Độ dài của mảng là 10, có nghĩa là nó có thể lưu trữ 10 phần tử.\n- Mỗi phần tử có thể được truy cập qua chỉ số của nó. Ví dụ, chúng ta có thể truy cập vào phần tử tại chỉ số 6 như 9.\n\n## 4. Các Thao Tác Cơ Bản\nDưới đây là các thao tác cơ bản được hỗ trợ bởi một mảng.\n\n- **Duyệt (Traverse)**: In ra tất cả các phần tử của mảng một cách tuần tự.\n- **Chèn (Insertion)**: Thêm một phần tử tại chỉ số đã cho.\n- **Xóa (Deletion)**: Xóa một phần tử tại chỉ số đã cho.\n- **Tìm Kiếm (Search)**: Tìm kiếm một phần tử sử dụng chỉ số đã cho hoặc giá trị của phần tử.\n- **Cập Nhật (Update)**: Cập nhật một phần tử tại chỉ số đã cho.\n\n## 5. Mảng trong Python\nCác kiểu dữ liệu tiêu chuẩn của Python như list, tuple và string là các chuỗi. Một đối tượng chuỗi là một tập hợp có thứ tự các mục. Mỗi mục được đặc trưng bằng chỉ số tăng dần bắt đầu từ số 0. Hơn nữa, các mục trong một chuỗi không nhất thiết phải cùng loại dữ liệu. Nói cách khác, một danh sách hoặc tuple có thể bao gồm các mục của các loại dữ liệu khác nhau.\n\nĐiều này khác biệt với khái niệm của một mảng trong C hoặc C++. Trong C/C++, một mảng cũng là một tập hợp có chỉ số của các mục, nhưng các mục phải cùng loại dữ liệu. Trong C/C++, bạn có một mảng các số nguyên hoặc số thực, hoặc chuỗi, nhưng bạn không thể có một mảng với một số phần tử thuộc loại số nguyên và một số thuộc loại khác. Một mảng trong C/C++ do đó là một tập hợp đồng nhất của các loại dữ liệu.\n\nThư viện tiêu chuẩn của Python có một mô-đun mảng. Lớp mảng trong đó cho phép bạn xây dựng một mảng của ba loại cơ bản, số nguyên, số thực và ký tự Unicode.\n\n### Cú Pháp\nCú pháp tạo mảng là:\n\n```python\nimport array\nobj = array.array(typecode[, initializer])\n```\n\n#### Tham số\n- **typecode**: Ký tự typecode được sử dụng để tạo mảng.\n- **initializer**: mảng được khởi tạo từ giá trị tùy chọn, phải là một danh sách, một đối tượng giống như bytes hoặc có thể lặp lại qua các phần tử của loại thích hợp.\n\n#### Kiểu Trả Về\nConstructor array() trả về một đối tượng của lớp array.array.\n\n### Ví dụ\n```python\nimport array as arr\n\n# Tạo một mảng với kiểu số nguyên\na = arr.array('i', [1, 2, 3])\nprint (type(a), a)\n\n# Tạo một mảng với kiểu ký tự\na = arr.array('u', 'BAT')\nprint (type(a), a)\n\n# Tạo một mảng với kiểu số thực\na = arr.array('d', [1.1, 2.2, 3.3])\nprint (type(a), a)\n```\n\nKết quả sẽ là:\n```python\n<class 'array.array'> array('i', [1, 2, 3])\n<class 'array.array'> array('u', 'BAT')\n<class 'array.array'> array('d', [1.1, 2.2, 3.3])\n```\n\nMảng là các kiểu chuỗi và hoạt động rất giống như danh sách, trừ việc kiểu đối tượng được lưu trữ trong chúng được hạn chế.\n\nLoại mảng Python được quyết định bởi một ký tự Typecode duy nhất. Các mã loại và kiểu dữ liệu Python dự định của mảng được liệt kê dưới đây:\n\n| typecode | Kiểu dữ liệu Python | Kích thước byte |\n|----------|---------------------|------------------|\n| 'b'      | số nguyên có dấu   | 1                |\n| 'B'      | số nguyên không dấu| 1                |\n| 'u'      | ký tự Unicode       | 2                |\n| 'h'      | số nguyên có dấu   | 2                |\n| 'H'      | số nguyên không dấu| 2                |\n| 'i'      | số nguyên có dấu   | 2                |\n| 'I'      | số nguyên không dấu| 2                |\n| 'l'      | số nguyên có dấu   | 4                |\n| 'L'      | số nguyên không dấu| 4                |\n| 'q'      | số nguyên có dấu   | 8                |\n| 'Q'      | số nguyên không dấu| 8                |\n| 'f'      | số thực động        | 4                |\n| 'd'      | số thực động        | 8                |\n\nTrước khi xem xét các thao tác mảng khác nhau, hãy tạo và in một mảng bằng Python. Mã dưới đây tạo một mảng có tên là array1.\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\nfor x in array1:\n print(x)\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau:\n\n```python\n10\n20\n30\n40\n50\n```\n\n## Truy Cập Phần Tử Mảng\nChúng ta có thể truy cập từng phần tử của một mảng bằng cách sử dụng chỉ số của phần tử đó. Mã dưới đây cho thấy cách\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\nprint (array1[0])\nprint (array1[2])\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau, cho thấy phần tử được chèn vào vị trí chỉ số 1.\n\n```python\n10\n30\n```\n\n## Thao Tác Chèn (Insertion)\nThao tác chèn là để chèn một hoặc nhiều phần tử dữ liệu vào một mảng. Dựa trên yêu cầu, một phần tử mới có thể được thêm vào đầu, cuối hoặc bất kỳ chỉ số đã cho nào của mảng.\n\nỞ đây, chúng tôi thêm một phần tử dữ liệu vào giữa mảng bằng phương thức insert() tích hợp của Python.\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\narray1.insert(1,60)\nfor x in array1:\n print(x)\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau, cho thấy phần tử được chèn vào vị trí chỉ số 1.\n\n```python\n10\n60\n20\n30\n40\n50\n```\n\n## Thao Tác Xóa (Deletion)\nXóa đề cập đến việc loại bỏ một phần tử hiện có khỏi mảng và tổ chức lại tất cả các phần tử của mảng.\n\nỞ đây, chúng tôi loại bỏ một phần tử dữ liệu ở giữa mảng bằng phương thức remove() tích hợp của Python.\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\narray1.remove(40)\nfor x in array1:\n   print(x)\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau, cho thấy phần tử được loại bỏ từ mảng.\n\n```python\n10\n20\n30\n50\n```\n\n## Thao Tác Tìm Kiếm (Search)\nBạn có thể thực hiện tìm kiếm một phần tử mảng dựa trên giá trị hoặc chỉ số của nó. Ở đây, chúng ta tìm kiếm một phần tử dữ liệu bằng cách sử dụng phương thức index() tích hợp của Python.\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\nprint (array1.index(40))\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau, cho thấy chỉ số của phần tử. Nếu giá trị không có trong mảng thì chương trình sẽ trả về một lỗi.\n\n```python\n3\n```\n\n## Thao Tác Cập Nhật (Update)\nThao tác cập nhật đề cập đến việc cập nhật một phần tử hiện có từ mảng tại một chỉ số đã cho. Ở đây, chúng ta chỉ đơn giản là gán một giá trị mới cho chỉ số mong muốn mà chúng ta muốn cập nhật.\n\n```python\nfrom array import *\narray1 = array('i', [10,20,30,40,50])\narray1[2] = 80\nfor x in array1:\n   print(x)\n```\n\n### Kết Quả\nKhi chúng ta biên dịch và thực thi chương trình trên, nó sẽ tạo ra kết quả sau, cho thấy giá trị mới tại chỉ số 2.\n\n```python\n10\n20\n80\n40\n50\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 105,
        "fields": {
            "name": "Python - Truy Cập Phần Tử của Mảng",
            "content": "# Python - Truy Cập Phần Tử của Mảng\n\nVì đối tượng mảng hoạt động rất giống như một chuỗi, bạn có thể thực hiện các thao tác chỉ mục và cắt mảnh với nó.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3])\n# chỉ mục\nprint (a[1])\n# cắt mảnh\nprint (a[1:])\n```\n\n## Thay Đổi Phần Tử của Mảng\n\nBạn có thể gán giá trị cho một phần tử trong mảng giống như bạn gán giá trị cho một phần tử trong một danh sách.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3])\na[1] = 20\nprint (a[1])\n```\n\nỞ đây, bạn sẽ nhận được \"20\" là kết quả đầu ra. Tuy nhiên, Python không cho phép gán giá trị của bất kỳ loại nào khác ngoài loại được sử dụng khi tạo một mảng. Phép gán sau đây sẽ gây ra TypeError.\n\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3])\n# gán giá trị\na[1] = 'A'\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```\nTypeError: 'str' object cannot be interpreted as an integer\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 106,
        "fields": {
            "name": "Python - Thêm Phần Tử vào Mảng",
            "content": "# Python - Thêm Phần Tử vào Mảng\n\n## Thêm Phần Tử vào Mảng\n\nPhương thức append() thêm một phần tử mới vào cuối mảng đã cho.\n\n### Cú Pháp\n```python\narray.append(v)\n```\n\n#### Tham số\n- **v**: Giá trị mới được thêm vào cuối mảng. Giá trị mới phải cùng loại dữ liệu như đối số datatype được sử dụng khi khai báo đối tượng mảng.\n\n### Ví dụ: Thêm Phần Tử vào Mảng\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3])\na.append(10)\nprint (a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 2, 3, 10])\n```\n\n## Thêm Phần Tử vào Chỉ Mục Cụ Thể của Mảng\n\nLớp mảng cũng xác định phương thức insert(). Có thể chèn một phần tử mới vào chỉ mục được chỉ định.\n\n### Cú Pháp\n```python\narray.insert(i, v)\n```\n\n#### Tham số\n- **i**: Chỉ mục mà giá trị mới sẽ được chèn vào.\n- **v**: Giá trị sẽ được chèn vào. Phải là kiểu dữ liệu của mảng.\n\n### Ví dụ: Thêm Phần Tử vào Chỉ Mục Cụ Thể của Mảng\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3])\na.insert(1,20)\nprint (a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 20, 2, 3])\n```\n\n## Thêm Phần Tử từ Chuỗi Khác vào Mảng\n\nPhương thức extend() trong lớp mảng nối thêm tất cả các phần tử từ một mảng khác cùng loại mã typecode.\n\n### Cú Pháp\n```python\narray.extend(x)\n```\n\n#### Tham số\n- **x**: Đối tượng của lớp array.array.\n\n### Ví dụ: Mở Rộng Mảng\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 4, 5])\nb = arr.array('i', [6,7,8,9,10])\na.extend(b)\nprint (a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 107,
        "fields": {
            "name": "Python - Xóa Phần Tử khỏi Mảng",
            "content": "# Python - Xóa Phần Tử khỏi Mảng\n\nLớp mảng xác định hai phương thức giúp chúng ta loại bỏ một phần tử khỏi mảng. Nó có các phương thức remove() và pop().\n\n## Xóa Sự Xuất Hiện Đầu Tiên\n\nPhương thức remove() loại bỏ sự xuất hiện đầu tiên của một giá trị đã cho từ mảng.\n\n### Cú Pháp\n```python\narray.remove(v)\n```\n\n#### Tham số\n- **v**: Giá trị cần loại bỏ khỏi mảng.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 1, 4, 2])\na.remove(2)\nprint (a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 1, 4, 2])\n```\n\n## Xóa Phần Tử từ Chỉ Mục Cụ Thể\n\nPhương thức pop() loại bỏ một phần tử tại chỉ mục được chỉ định từ mảng và trả về phần tử đã loại bỏ.\n\n### Cú Pháp\n```python\narray.pop(i)\n```\n\n#### Tham số\n- **i**: Chỉ mục của phần tử cần loại bỏ. Phương thức trả về phần tử tại vị trí i sau khi loại bỏ.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 1, 4, 2])\na.pop(2)\nprint (a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 2, 4, 2])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 108,
        "fields": {
            "name": "Python - Lặp qua Mảng",
            "content": "# Python - Lặp qua Mảng\n\nVì đối tượng mảng hoạt động như một chuỗi, bạn có thể lặp qua các phần tử của nó với sự giúp đỡ của vòng lặp for hoặc while.\n\n## Vòng Lặp \"for\" với Mảng\n\nXem ví dụ sau:\n\n```python\nimport array as arr\na = arr.array('d', [1, 2, 3])\nfor x in a:\n   print (x)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```\n1.0\n2.0\n3.0\n```\n\n## Vòng Lặp \"while\" với Mảng\n\nVí dụ sau cho thấy cách bạn có thể lặp qua một mảng bằng cách sử dụng một vòng lặp while −\n\n```python\nimport array as arr\na = arr.array('d', [1, 2, 3])\nl = len(a)\nidx =0\nwhile idx<l:\n   print (a[idx])\n   idx+=1\n```\n\n## Vòng Lặp \"for\" với Chỉ Số của Mảng\n\nChúng ta có thể tìm độ dài của mảng bằng hàm tích hợp len(). Sử dụng nó để tạo một đối tượng range để có được dãy chỉ số và sau đó truy cập các phần tử của mảng trong một vòng lặp for.\n\n```python\nimport array as arr\na = arr.array('d', [1, 2, 3])\nl = len(a)\nfor x in range(l):\n   print (a[x])\n```\n\nBạn sẽ nhận được cùng một kết quả như trong ví dụ đầu tiên.",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 109,
        "fields": {
            "name": "Python - Sao Chép Mảng",
            "content": "# Python - Sao Chép Mảng\n\nCác loại chuỗi tích hợp sẵn trong Python như list, tuple và string là các tập hợp được chỉ mục của các mục. Tuy nhiên, khác với các mảng trong C/C++, Java v.v., chúng không đồng nhất, trong ý nghĩa rằng các phần tử trong các loại tập hợp này có thể thuộc các loại khác nhau. Module mảng của Python giúp bạn tạo đối tượng tương tự như các mảng trong Java. Trong chương này, chúng ta sẽ thảo luận về cách sao chép một đối tượng mảng sang một đối tượng khác.\n\nCác mảng Python có thể là chuỗi, số nguyên hoặc số thực. Constructor của lớp mảng được sử dụng như sau:\n\n```python\nimport array\nobj = array.array(typecode[, initializer])\n```\n\ntypecode có thể là một hằng số ký tự đại diện cho kiểu dữ liệu.\n\n## Sao Chép Mảng Bằng Toán Tử Gán\n\nChúng ta có thể gán một mảng cho một mảng khác bằng toán tử gán.\n\n### Ví dụ\n```python\na = arr.array('i', [1, 2, 3, 4, 5])\nb = a.copy()\n```\n\nTuy nhiên, việc gán như vậy không tạo ra một mảng mới trong bộ nhớ. Trong Python, một biến chỉ là một nhãn hoặc tham chiếu đến đối tượng trong bộ nhớ. Vì vậy, a là tham chiếu đến một mảng, và b cũng vậy. Kiểm tra id() của cả a và b. Cùng một giá trị id xác nhận rằng phép gán đơn giản không tạo ra một bản sao.\n\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 4, 5])\nb = a\nprint (id(a), id(b))\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\n2771967068656 2771967068656\n```\n\nBởi vì \"a\" và \"b\" trỏ đến cùng một đối tượng mảng, bất kỳ thay đổi nào trong \"a\" cũng sẽ phản ánh trong \"b\".\n\n```python\na[2]=10\nprint (a,b)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\narray('i', [1, 2, 10, 4, 5]) array('i', [1, 2, 10, 4, 5])\n```\n\n## Sao Chép Mảng Bằng Sao Chép Sâu\n\nĐể tạo ra một bản sao vật lý khác của một mảng, chúng ta sử dụng một module khác trong thư viện Python, có tên là copy và sử dụng hàm deepcopy() trong module đó. Một bản sao sâu tạo ra một đối tượng hợp thành mới và sau đó, đệ quy chèn các bản sao vào nó của các đối tượng được tìm thấy trong ban đầu.\n\n### Ví dụ\n```python\nimport array, copy\na = arr.array('i', [1, 2, 3, 4, 5])\nb = copy.deepcopy(a)\n```\n\nBây giờ hãy kiểm tra id() của cả \"a\" và \"b\". Bạn sẽ thấy các id khác nhau.\n\n```python\nprint (id(a), id(b))\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\n2771967069936 2771967068976\n```\nĐiều này chứng minh rằng một đối tượng mới \"b\" được tạo ra là một bản sao thực sự của \"a\". Nếu chúng ta thay đổi một phần tử trong \"a\", nó sẽ không phản ánh trong \"b\".\n\n```python\na[2]=10\nprint (a,b)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\narray('i', [1, 2, 10, 4, 5]) array('i', [1, 2, 3, 4, 5])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 110,
        "fields": {
            "name": "",
            "content": "",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 111,
        "fields": {
            "name": "Python - Sắp Xếp Mảng",
            "content": "# Python - Sắp Xếp Mảng\n\nModule mảng của Python định nghĩa lớp mảng. Một đối tượng của lớp mảng tương tự như mảng trong Java hoặc C/C++. Khác với các chuỗi Python tích hợp sẵn, mảng là một tập hợp đồng nhất của chuỗi, số nguyên hoặc đối tượng float.\n\nLớp mảng không có bất kỳ hàm/phương thức nào để cung cấp một sắp xếp của các phần tử của nó. Tuy nhiên, chúng ta có thể đạt được điều này với một trong những phương pháp sau:\n\n1. Sử dụng một thuật toán sắp xếp\n2. Sử dụng phương thức sort() từ List\n3. Sử dụng hàm sorted() tích hợp sẵn\n\nHãy thảo luận về mỗi phương pháp này một cách chi tiết.\n\n## Sắp Xếp Mảng Sử Dụng Một Thuật Toán Sắp Xếp\n\nChúng ta sẽ thực hiện thuật toán sắp xếp bubble để có được mảng đã sắp xếp. Để làm điều này, chúng ta sử dụng hai vòng lặp lồng nhau và hoán đổi các phần tử để sắp xếp lại theo thứ tự.\n\n### Ví dụ\nLưu mã sau bằng một trình soạn mã Python −\n\n```python\nimport array as arr\na = arr.array('i', [10,5,15,4,6,20,9])\nfor i in range(0, len(a)):\n   for j in range(i+1, len(a)):\n      if(a[i] > a[j]):\n         temp = a[i];\n         a[i] = a[j];\n         a[j] = temp;\nprint (a)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\narray('i', [4, 5, 6, 9, 10, 15, 20])\n```\n\n## Sắp Xếp Mảng Sử Dụng Phương Thức sort() của List\n\nNgay cả khi mảng không có phương thức sort(), lớp List tích hợp sẵn của Python vẫn có một phương thức sort. Chúng ta sẽ sử dụng nó trong ví dụ tiếp theo.\n\nĐầu tiên, khai báo một mảng và lấy một đối tượng danh sách từ đó, sử dụng phương thức tolist() −\n\n### Ví dụ\n```python\na = arr.array('i', [10,5,15,4,6,20,9])\nb=a.tolist()\n```\n\nChúng ta có thể dễ dàng có được danh sách đã sắp xếp như sau:\n\n```python\nb.sort()\n```\n\nTất cả những gì chúng ta cần làm là chuyển danh sách này trở lại thành một đối tượng mảng −\n\n```python\na.fromlist(b)\n```\n\nDưới đây là mã hoàn chỉnh −\n\n```python\nfrom array import array as arr\na = arr.array('i', [10,5,15,4,6,20,9])\nb=a.tolist()\nb.sort()\na = arr.array('i')\na.fromlist(b)\nprint (a)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\narray('i', [4, 5, 6, 9, 10, 15, 20])\n```\n\n## Sắp Xếp Mảng Sử Dụng Phương Thức sorted()\n\nPhương pháp thứ ba để sắp xếp một mảng là sử dụng hàm sorted(), một hàm tích hợp sẵn.\n\nCú pháp của hàm sorted() như sau:\n\n```python\nsorted(iterable, reverse=False)\n```\n\nHàm trả về một danh sách mới chứa tất cả các mục từ iterable theo thứ tự tăng dần. Đặt tham số reverse thành True để có thứ tự giảm dần của các mục.\n\nHàm sorted() có thể được sử dụng cùng với bất kỳ iterable nào. Mảng Python là một iterable vì nó là một tập hợp được chỉ mục. Do đó\n\n, một mảng có thể được sử dụng làm tham số cho hàm sorted().\n\n### Ví dụ\n```python\nfrom array import array as arr\na = arr.array('i', [4, 5, 6, 9, 10, 15, 20])\nsorted(a)\nprint (a)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```python\narray('i', [4, 5, 6, 9, 10, 15, 20])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 112,
        "fields": {
            "name": "Python - Gộp Mảng",
            "content": "# Python - Gộp Mảng\n\nTrong Python, mảng là một tập hợp đồng nhất của các loại dữ liệu được tích hợp sẵn của Python như chuỗi, số nguyên hoặc đối tượng float. Tuy nhiên, mảng chính nó không phải là một loại dữ liệu tích hợp sẵn, thay vào đó, chúng ta cần sử dụng lớp mảng trong module mảng tích hợp sẵn của Python.\n\n## Gộp Mảng bằng Cách Thêm Các Phần Tử\nĐể gộp hai mảng, chúng ta có thể làm điều đó bằng cách thêm mỗi mục từ một mảng vào mảng khác.\n\nDưới đây là hai mảng Python:\n\n```python\na = arr.array('i', [10,5,15,4,6,20,9])\nb = arr.array('i', [2,7,8,11,3,10])\n```\n\nChạy một vòng lặp for trên mảng \"b\". Lấy mỗi số từ \"b\" và thêm nó vào mảng \"a\" với câu lệnh vòng lặp sau:\n\n```python\nfor i in range(len(b)):\n   a.append(b[i])\n```\n\nMảng \"a\" bây giờ chứa các phần tử từ \"a\" cũng như \"b\".\n\n### Ví dụ: Gộp Hai Mảng bằng Cách Thêm Các Phần Tử\nDưới đây là mã hoàn chỉnh.\n\n```python\nimport array as arr\na = arr.array('i', [10,5,15,4,6,20,9])\nb = arr.array('i', [2,7,8,11,3,10])\nfor i in range(len(b)):\n   a.append(b[i])\nprint (a, b)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```\narray('i', [10, 5, 15, 4, 6, 20, 9, 2, 7, 8, 11, 3, 10])\n```\n\n## Gộp Mảng bằng Cách Chuyển Đổi thành Đối Tượng Danh Sách\nSử dụng một phương pháp khác để gộp hai mảng, đầu tiên chuyển đổi các mảng thành các đối tượng danh sách.\n\n```python\na = arr.array('i', [10,5,15,4,6,20,9])\nb = arr.array('i', [2,7,8,11,3,10])\nx=a.tolist()\ny=b.tolist()\n```\n\nCác đối tượng danh sách có thể được nối với toán tử '+'.\n\n```python\nz=x+y\n```\n\nNếu danh sách \"z\" được chuyển đổi lại thành một mảng, bạn sẽ có một mảng đại diện cho các mảng đã gộp.\n\n```python\na.fromlist(z)\n```\n\n### Ví dụ: Gộp Hai Mảng bằng Cách Chuyển Đổi thành Đối Tượng Danh Sách\nDưới đây là mã hoàn chỉnh.\n\n```python\nfrom array import array as arr\na = arr.array('i', [10,5,15,4,6,20,9])\nb = arr.array('i', [2,7,8,11,3,10])\nx=a.tolist()\ny=b.tolist()\nz=x+y\na=arr.array('i')\na.fromlist(z)\nprint (a)\n```\n\n## Gộp Mảng Bằng Cách Sử Dụng Phương Thức extend()\nChúng ta cũng có thể sử dụng phương thức extend() từ lớp List để thêm các phần tử từ một danh sách vào một danh sách khác.\n\nĐầu tiên, chuyển đổi mảng thành một danh sách và sau đó gọi phương thức extend() để hợp nhất hai danh sách.\n\n### Ví dụ: Gộp Hai Mảng Bằng Cách Sử Dụng Phương Thức extend()\n```python\nfrom array import array as arr\na = arr.array('i', [10,5,15,4,6,20,9])\nb = arr.array('i', [2,7,8,11,3,10])\na.extend(b)\nprint (a)\n```\n\nNó sẽ tạo ra kết quả sau:\n\n```\narray('i', [10, 5, 15, 4, 6, 20, 9, 2, 7, 8, 11, 3, 10])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 113,
        "fields": {
            "name": "Python - Phương Thức Mảng",
            "content": "# Python - Phương Thức Mảng\n\n## Phương Thức `array.reverse()`\n\nGiống như các loại chuỗi, lớp array cũng hỗ trợ phương thức `reverse()` để sắp xếp lại các phần tử theo thứ tự ngược lại.\n\n### Cú pháp\n```python\narray.reverse()\n```\n\n### Tham số\nPhương thức này không có tham số.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 4, 5])\na.reverse()\nprint(a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [5, 4, 3, 2, 1])\n```\n\n## Phương Thức `array.count()`\n\nPhương thức `count()` trả về số lần một phần tử cụ thể xuất hiện trong mảng.\n\n### Cú pháp\n```python\narray.count(v)\n```\n\n### Tham số\n- `v`: Giá trị cần đếm số lần xuất hiện.\n\n### Giá trị trả về\nPhương thức `count()` trả về một số nguyên tương ứng với số lần `v` xuất hiện trong mảng.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 2, 5, 6, 2, 9])\nc = a.count(2)\nprint(\"Số lần xuất hiện của 2:\", c)\n```\n\nKết quả sẽ là:\n\n```\nSố lần xuất hiện của 2: 3\n```\n\n## Phương Thức `array.index()`\n\nPhương thức `index()` trong lớp array tìm vị trí xuất hiện đầu tiên của một phần tử cụ thể trong mảng.\n\n### Cú pháp\n```python\narray.index(v)\n```\n\n### Tham số\n- `v`: Giá trị cần tìm vị trí.\n\n### Ví dụ\n```python\na = arr.array('i', [1, 2, 3, 2, 5, 6, 2, 9])\nc = a.index(2)\nprint(\"Vị trí xuất hiện đầu tiên của 2:\", c)\n```\n\nKết quả sẽ là:\n\n```\nVị trí xuất hiện đầu tiên của 2: 1\n```\n\n## Phương Thức `array.fromlist()`\n\nPhương thức `fromlist()` nối các phần tử từ một danh sách Python vào đối tượng mảng.\n\n### Cú pháp\n```python\narray.fromlist(l)\n```\n\n### Tham số\n- `l`: Danh sách các phần tử sẽ được nối vào mảng. Tất cả các phần tử trong danh sách phải có cùng kiểu dữ liệu với mảng.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 4, 5])\nlst = [6, 7, 8, 9, 10]\na.fromlist(lst)\nprint(a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n```\n\n## Phương Thức `array.tofile()`\n\nPhương thức `tofile()` trong lớp array ghi tất cả các phần tử (dưới dạng giá trị máy) trong mảng vào đối tượng tệp.\n\n### Cú pháp\n```python\narray.tofile(f)\n```\n\n### Tham số\n- `f`: Đối tượng tệp thu được từ hàm `open()`. Tệp cần mở trong chế độ `wb`.\n\n### Ví dụ\n```python\nimport array as arr\nf = open('list.txt', 'wb')\narr.array(\"i\", [10, 20, 30, 40, 50]).tofile(f)\nf.close()\n```\n\nSau khi chạy mã trên, một tệp có tên \"list.txt\" sẽ được tạo trong thư mục hiện tại.\n\n## Phương Thức `array.fromfile()`\n\nPhương thức `fromfile()` đọc một tệp nhị phân và nối một số lượng phần tử đã chỉ định vào đối tượng mảng.\n\n### Cú pháp\n```python\narray.fromfile(f, n)\n```\n\n### Tham số\n- `f`: Đối tượng tệp đang tham chiếu đến một tệp đĩa đã mở trong chế độ `rb`.\n- `n`: Số lượng phần tử cần được nối vào mảng.\n\n### Ví dụ\n```python\nimport array as arr\na = arr.array('i', [1, 2, 3, 4, 5])\nf = open(\"list.txt\", \"rb\")\na.fromfile(f, 5)\nprint(a)\n```\n\nKết quả sẽ là:\n\n```\narray('i', [1, 2, 3, 4, 5, 10, 20, 30, 40, 50])\n```",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    },
    {
        "model": "web_app.detaillesson",
        "pk": 114,
        "fields": {
            "name": "Bài Tập Về Mảng trong Python",
            "content": "# Bài Tập Về Mảng trong Python\n\n## Bài 1: Tìm số lớn nhất trong mảng\n\nViết chương trình Python để tìm số lớn nhất trong một mảng.\n\n```python\nimport array as arr\n\na = arr.array('i', [10, 5, 15, 4, 6, 20, 9])\nprint(\"Mảng ban đầu:\", a)\n\nlargest = a[0]\nfor i in range(1, len(a)):\n    if a[i] > largest:\n        largest = a[i]\n\nprint(\"Số lớn nhất:\", largest)\n```\n\nKết quả sẽ là:\n\n```\nMảng ban đầu: array('i', [10, 5, 15, 4, 6, 20, 9])\nSố lớn nhất: 20\n```\n\n## Bài 2: Lưu trữ tất cả số chẵn từ một mảng vào một mảng khác\n\nViết chương trình Python để lưu trữ tất cả các số chẵn từ một mảng vào một mảng khác.\n\n```python\nimport array as arr\n\na = arr.array('i', [10, 5, 15, 4, 6, 20, 9])\nprint(\"Mảng ban đầu:\", a)\n\nb = arr.array('i')\nfor i in range(len(a)):\n    if a[i] % 2 == 0:\n        b.append(a[i])\n\nprint(\"Các số chẵn:\", b)\n```\n\nKết quả sẽ là:\n\n```\nMảng ban đầu: array('i', [10, 5, 15, 4, 6, 20, 9])\nCác số chẵn: array('i', [10, 4, 6, 20])\n```\n\n## Bài 3: Tìm trung bình của tất cả các số trong một mảng\n\nViết chương trình Python để tính trung bình của tất cả các số trong một mảng.\n\n```python\nimport array as arr\n\na = arr.array('i', [10, 5, 15, 4, 6, 20, 9])\nprint(\"Mảng ban đầu:\", a)\n\ns = 0\nfor i in range(len(a)):\n    s += a[i]\navg = s / len(a)\nprint(\"Trung bình:\", avg)\n\n# Sử dụng hàm sum()\navg = sum(a) / len(a)\nprint(\"Trung bình:\", avg)\n```\n\nKết quả sẽ là:\n\n```\nMảng ban đầu: array('i', [10, 5, 15, 4, 6, 20, 9])\nTrung bình: 9.857142857142858\nTrung bình: 9.857142857142858\n```\n\n## Bài Tập Thêm\n\n1. Viết chương trình Python để tìm sự khác biệt giữa mỗi số trong mảng và trung bình của tất cả các số.\n2. Viết chương trình Python để chuyển đổi một chuỗi thành một mảng.\n3. Viết chương trình Python để chia một mảng thành hai và lưu trữ các số chẵn trong một mảng và số lẻ trong một mảng khác.\n4. Viết chương trình Python để thực hiện sắp xếp chèn trên một mảng.\n5. Viết chương trình Python để lưu trữ giá trị Unicode của mỗi ký tự trong mảng được cho.",
            "lesson": 9,
            "extent": 1,
            "created_at": "2024-04-07T08:34:47.002Z",
            "updated_at": "2024-04-07T08:34:47.002Z"
        }
    }
]